<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java类加载机制</title>
    <url>/2020/06/25/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="类生命周期"><a href="#类生命周期" class="headerlink" title="类生命周期"></a>类生命周期</h1><p>&emsp;在Java 虚拟机中，类的生命周期包括7个阶段：加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载。</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>&emsp;类的加载过程主要完成3件事：</p>
<ol>
<li>通过类的全限定名获取该类的二进制字节流，这个过程并没有规定从哪里获取，具有很大的操作空间。</li>
<li>将字节流的静态存储结构转为方法区或元空间的动态存储结构。</li>
<li>生成这个类的Class对象，作为该类各种数据的访问入口。</li>
</ol>
<a id="more"></a>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>&emsp;确保字节流中包含的信息符合虚拟机的要求，不会危害到虚拟机。主要包括文件格式验证，验证是否以魔数开头，版本号是否被虚拟机接收；元数据验证，验证类的方法，字段是否与父类矛盾；字节码验证，通过数据流与控制流分析，确定程序语义，不会危害虚拟机。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>&emsp;为类变量分配内存并设置默认零值，类变量是指 static 修饰的变量，如果类变量是常量，会初始化为定义的值。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>&emsp;将能替换的符号引用替换为直接引用，为了支持多态，有的符号引用在这个阶段不能被替换掉。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>&emsp;在这个阶段虚拟机会收集赋值语句与静态语句合并为一个clinit方法执行，为类的静态赋予正确的初始值。静态语句的顺序由源文件的顺序决定。</p>
<p>&emsp;执行一个类的clinit方法前，会先执行父类的clinit方法(故虚拟机中第一个执行的类是Object)，但是接口不需要，接口的实现类也不需要。只有接口中定义的变量使用时，才会执行接口的clinit方法。</p>
<p>&emsp;虚拟机会保证一个类的clinit方法在多线程环境下被正确的加锁和同步。</p>
<h1 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h1><h2 id="主动引用"><a href="#主动引用" class="headerlink" title="主动引用"></a>主动引用</h2><p>虚拟机规定在以下五种情况下，必须立即进行初始化：</p>
<ul>
<li>使用 new 关键字实例化对象时，访问类的静态字段，调用类的静态方法时。</li>
<li>使用java.lang.reflect 包的方法对类进行反射调用时。</li>
<li>初始化一个类时，它的父类还没有被初始化。</li>
<li>虚拟机启动时，包含 main() 方法的主类会先被初始化。</li>
<li>java.lang.invoke.MethodHandle 解析结果涉及静态字段与静态方法时，对应的类应该先被初始化。</li>
</ul>
<h2 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h2><p>处理主动引用外的所有引用方式都不会立即触发初始化，称为被动以用，比如：</p>
<ul>
<li>用过字类引用父类的静态字段，子类不会立即初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sytem.out.println(SubClass.value); <span class="comment">// value是父类的静态字段</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过数组定义引用类，不会触发类的初始化，会触发数组类的初始化，数组类是虚拟机自动生成的，包含了数组的属性和方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OneClass[] os = <span class="keyword">new</span> OneClass[<span class="number">100</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>引用一个类的常量也不会导致类的初始化，常量在编译阶段就存入常量池中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(OneClass.MAX_VALUE);</span><br></pre></td></tr></table></figure>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>&emsp;类加载器可以加载类，每一个类加载器都有独立的命名空间，对于任意一个类，它的<strong>类加载器和它本身确定唯一性</strong>。</p>
<h2 id="默认类加载器"><a href="#默认类加载器" class="headerlink" title="默认类加载器"></a>默认类加载器</h2><p>&emsp;启动类加载器 (Bootstrap ClassLoader)负责将存放在\<JRE_HOME\>下的lib目录中的指定类库加载，用户无法直接引用这个加载器，如果用户需要把加载请求委派给启动类加载器，用null代替即可。</p>
<p>&emsp;扩展类加载器负责加载指定扩展目录下的类库。</p>
<p>&emsp;应用程序类加载器，也叫系统类加载器，根据程序的类路径加载Java类，是程序默认的类加载器。用户自定义的加载器默认父加载器是应用程序类加载器。</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>&emsp;双亲委派模型要求除了顶层的启动类加载器外，所有加载器都有父类加载器，在收到类加载请求时，优先将请求委派给父加载器，父加载器无法处理时，子加载器才会自己加载类。这样做的好处是Java类随着它的类加载器具备一种天然的优先级层次。</p>
<h2 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h2><p>&emsp;线程上下文类加载器能打破双亲委派模型的桎梏，在一些场景十分有用，比如web服务器。</p>
]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>虚拟机</tag>
        <tag>类加载</tag>
      </tags>
  </entry>
  <entry>
    <title>Java垃圾收集机制</title>
    <url>/2020/06/25/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="判断对象是否可回收"><a href="#判断对象是否可回收" class="headerlink" title="判断对象是否可回收"></a>判断对象是否可回收</h1><p>&emsp;判断一个对象是否可以被回收，即还有没有其它指针指向它，如果没有了，说明这个对象已经不可以再被使用到了，就可以回收掉它的内存空间。主要有两种方式可以判断：</p>
<p>&emsp;- 引用计数法：每当有一个引用引用到对象，就给对象的引用计数加一，这样当某个对象的引用计数为0时，就说明该对象已经可以被回收了，但是该方法有循环引用的问题。</p>
<p>&emsp;- 可达性分析算法：以GC Roots对象为起点开始搜索引用链，凡是能搜索到的对象都是存活的对象，未能搜索到的对象都是可回收的对象。</p>
<a id="more"></a>
<p>&emsp;Java虚拟机中多使用可达性分析算法，其中GC Roots对象有4类：</p>
<ul>
<li>方法区中的常量引用的对象。</li>
<li>方法区中静态变量引用的对象。</li>
<li>栈中局部变量引用的对象。</li>
<li>本地方法栈中引用的对象。</li>
</ul>
<p>&emsp;Java中对象有四种引用：强引用，一定不会被垃圾收集；软引用，空间不足时会被收集；弱引用，下一次垃圾收集就被收集；虚引用，不会对对象的生命周期产生任何影响。</p>
<h2 id="对类的回收"><a href="#对类的回收" class="headerlink" title="对类的回收"></a>对类的回收</h2><p>&emsp;虚拟机对类的回收十分严苛，需要满足三个条件，并且满足了也不一定会回收：</p>
<ol>
<li>类的所有实例已经被回收。</li>
<li>加载该类的ClassLoader已经被回收。</li>
<li>该类对应的Class对象没有被引用，不能通过反射获得该类。</li>
</ol>
<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><ol>
<li>标记-清除算法：虚拟机标记可达对象后，将不可达的对象统一清除。这种算法效率比较低，而且容易造成空间碎片。</li>
<li>标记-整理算法：虚拟机将可达的对象全部移动到内存的一侧，将边界以外的空间一起释放。好处是无内存碎片，缺点是效率低。</li>
<li>复制算法：将内存分两块，只使用一块，在垃圾收集时将存活对象移动到另一块即可。好处是效率高，但是内存只使用到一半。虚拟机内实现一般分为一块Eden与两块Survivor，比例8：1：1，每次使用Eden与一块Survivor，留一块Survivor做垃圾收集时的复制空间，这样可以提高空间利用率。</li>
</ol>
<h1 id="Stop-the-world"><a href="#Stop-the-world" class="headerlink" title="Stop the world"></a>Stop the world</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;由于不能出现可达性分析过程中对象引用关系还在不断变化的情况，因此<strong>GC时必须停顿所有的Java执行线程</strong>，会影响系统响应以及用户体验，在HotSpot实现中，使用一组称为OopMap的数据结构来存储哪些地方存放着对象引用，这样可以减少GC时扫描全局引用的时间。<br>&nbsp;&nbsp;&nbsp;&nbsp;HotSpot并没有为每条指令都生成OopMap，只在“特定的位置”记录，这些位置称为安全点，因此程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能。但还有一个问题需要考虑，如何在GC时让所有线程都跑到最近的安全点上停顿，有两种方式：</p>
<ul>
<li>抢先示中中断，不需要线程的执行代码配合，在GC时，中断所有线程，如果发现有线程中断的地方不在安全点上，就让它跑到安全点上，现在几乎没有虚拟机采用这种方法。</li>
<li><strong>主动式中断，当GC需要中断线程时，设置一个标志，各个线程主动轮询这个标志，发现为真时自己中断挂起。</strong>    </li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;当线程处于挂起状态时，无法响应中断请求，这种时候需要安全区域来解决。<strong>安全区域是指在一段代码片段中，引用关系不会发生变化。在这个区域中的任何地方开始GC都是安全的，安全区域可以看作是扩展的安全区域。</strong></p>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>&emsp;很多垃圾收集器采用分代收集的方式，将堆中的内存分为新生代和老年代，新生代的对象通常存活时间较短，回收比较频繁，采用效率高的复制算法，老年代的对象存活时间很长，回收不频繁，采用标记-清除或标记-整理算法。</p>
<ul>
<li>Serial 与 Serial Old 收集器：单线程收集器，垃圾收集时需要暂停其它工作线程，直到收集结束。主要用在Client模式下的虚拟机。</li>
<li>ParNew 收集器： Serial收集器的多线程版本，主要用在Server模式的虚拟机上，能与CMS收集器配合工作。</li>
<li>Parallel Scavenge 与 Parallel Old 收集器，多线程吞吐量优先收集器。</li>
</ul>
<h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>&emsp;目标是获得最短的回收停顿时间，基于标记清除算法实现，在Server端使用比较多。运作过程包括<strong>初始标记，并发标记，重新标记与并发清除</strong>。初始标记只标记GC Roots能直接关联到的对象，速度很快；并发标记就是进行可达性分析的过程；重新标记修正并发标记期间引用关系发生变化的部分；并发清除则是清除不可达对象，回收空间。</p>
<p>&emsp;整个过程中，并发标记与并发清楚可以和用户线程一起工作，因此停顿时间只有初始标记和重新标记的过程，但时间并不长。</p>
<p>&emsp;CMS收集器的缺点是有空间碎片产生，无法处理浮动垃圾以及对CPU资源十分敏感。</p>
<h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>&emsp;G1收集器主要应用在Server端。它将对划分为多个大小相等的独立区域，新生代和老年代不再物理隔离。它会跟踪每个区域垃圾堆积的大小，维护一个优先列表，回收时回收价值最大的区域。运作工程包括初始标记，并发标记，最终标记，筛选回收。由于可以控制回收多少块区域，因此可以得到一个<strong>可预测的停顿时间</strong>。</p>
<h1 id="对象内存分配"><a href="#对象内存分配" class="headerlink" title="对象内存分配"></a>对象内存分配</h1><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><ul>
<li>对象优先在新生代的Eden分配</li>
<li>大对象直接进入老年代</li>
<li>长期存活的对象进入老年代，可以设定年龄阈值或者动态年龄判断</li>
</ul>
<h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><p>&emsp;在堆上为对象分配内存是，如果内存是绝对规整的，可以使用<strong>指针碰撞</strong>，直接让指针偏移出对象内存大小即可。如果内存不规则，需要维护一个<strong>空闲列表</strong>，从列表中选择能满足对象内存需求的内存块分配给对象。</p>
<p>&emsp;对象在分配时，也需要保证线程的安全，通常本地线程会预先分到一块内存空间作为<strong>本地线程缓冲</strong>，该线程创建的对象都在这块空间内分配，当缓冲用完后，需要申请新的空间时才需要同步锁定。</p>
<h1 id="Minor-GC-与-Full-GC"><a href="#Minor-GC-与-Full-GC" class="headerlink" title="Minor GC 与 Full GC"></a>Minor GC 与 Full GC</h1><p>&emsp;Minor GC 主要回收新生代的空间，Major GC 主要回收老年代空间，Full GC 回收老年代与新生代与元空间。</p>
<p>&emsp;触发full gc 的条件：</p>
<ul>
<li>调用System.gc() 方法，但是不一定会执行</li>
<li>老年代空间不足</li>
<li>空间分配担保失败</li>
<li>永久代( jdk 1.7 之前) 或 元空间不足</li>
<li>CMS GC 发生错误</li>
</ul>
<h1 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h1><p>&emsp;对象被回收时，如果对象覆盖了Object类的finalize()方法，虚拟机会在回收前执行对象的finalize()方法，但是不保证什么时候开始执行，也并不保证一定会执行完这个方法。</p>
]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>虚拟机</tag>
        <tag>垃圾收集</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2020/06/24/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="部分背包问题"><a href="#部分背包问题" class="headerlink" title="部分背包问题"></a>部分背包问题</h1><p>&emsp;部分背包问题即装入背包的物品可分割，可以用简单的贪心算法解决，物品平均价值由高到低排序，依次放入背包，直到放不下。</p>
<p>&emsp;例如：有一堆金粉，银粉，铜粉和铁粉，用一个固定大小的袋子去装，只要从平均价值最大的金粉开始装，装完后装下一堆平均价值最大的物品，直到袋子装满为止即可。</p>
<h1 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>&emsp;有N件物品，第 i 件物品重Ci，价值Wi，你有一个能装重量V的背包，每件物品只有一个，你需要装入哪些物品才能使背包内的价值总和最大？<br><a id="more"></a></p>
<h2 id="动态规划公式"><a href="#动态规划公式" class="headerlink" title="动态规划公式"></a>动态规划公式</h2><p>&emsp;定义dp[i, v]表示将前 i 件物品放入容量为 v 的背包可以获得最大价值总和，那么在这个情况下，有两种可能，要么第 i 件物品放入了背包内， 要么第 i 件物品没有放入背包内。</p>
<p>&emsp;如果第 i 件物品没有放入背包内，相当于<strong>dp[i, v] = dp[i - 1, v]</strong>，即将前面 i - 1件物品放入容量为v的背包中的最大价值总和。</p>
<p>&emsp;如果第 i 件物品放入了背包内，相当于<strong>dp[i, v] = dp[i - 1, v - Ci] + Wi</strong>，因为第 i 件物品放入了背包，所以相当于前面 i - 1 件物品占用v - Ci的空间的最大价值总和再加上第 i 件物品的价值。</p>
<p>&emsp;但是两种可能只能选择一种，价值最大的那种，所以01背包的递推公式为：<strong>dp[i, v] = max{dp[i - 1, v], dp[i - 1, v - Ci] + Wi}</strong></p>
<h2 id="解法与优化"><a href="#解法与优化" class="headerlink" title="解法与优化"></a>解法与优化</h2><p>&emsp;既然已经得到了递推公式，根据递推公式不断计算，最终算到<code>dp[N, V]</code>就是问题的答案了，可以创建一个二维数组计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bagProblem</span><span class="params">(<span class="keyword">int</span>[] C, <span class="keyword">int</span>[] W, <span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> dp[C.length + <span class="number">1</span>][V + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C.length; i++)&#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> j = C[i]; j &lt;= V; j++)&#123;</span><br><span class="line">        	dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - C[i]] + W[i]);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;   </span><br><span class="line">    <span class="keyword">return</span> dp[C.length][[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;从代码中不难看出，二维数组在计算过程中是逐行计算的，并且第 i 行的数据只依赖于第 i - 1行的数据，因此前面已经计算过的行其实已经无用了，可以删掉它们优化空间。最佳的优化下，可以只使用一维数组来计算。<br>&emsp;只用一维数组来计算的关键点在于，每一行数据在计算的时候，都依赖前面已经计算的元素，依赖于前面的 j - C[i]位置上的元素，<strong>如果依旧从前到后依次计算，拿到的这个位置的元素的值就是错的。所以这个时候需要从后到前计算</strong>，这样就能保证每次取 j - C[i]位置上的元素，都是上一次计算的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bagProblem</span><span class="params">(<span class="keyword">int</span>[] C, <span class="keyword">int</span>[] W, <span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> dp[V + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = V; j &gt;= C[i]; j--)&#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - C[i] + W[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[V];                                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;另外，在这个代码中，可以抽象出处理一件01背包问题的代码作为一个函数调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zeroOneBag</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> c, <span class="keyword">int</span> V, <span class="keyword">int</span>[] dp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = V; j &gt;= c; j--)</span><br><span class="line">    	dp[j] = Math.max(dp[j], dp[j - c] + w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bagProblem</span><span class="params">(<span class="keyword">int</span>[] C, <span class="keyword">int</span>[] W, <span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> dp[V + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C.length; i++)</span><br><span class="line">    	zeroOneBag(W[i], C[i], V, dp);</span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>&emsp;完全背包问题与01背包问题唯一的区别在于，每一种物品都有无限多个，可以拿0个，1个，任意个。很显然，直觉上看，这种情况下问题的复杂性十分高，可能的情况实在太多。</p>
<h2 id="动态规划公式推导"><a href="#动态规划公式推导" class="headerlink" title="动态规划公式推导"></a>动态规划公式推导</h2><p>&emsp;完全背包问题的递推式如下所示：</p>
<p>&emsp; $ dp[i, j] = max( dp[i - 1, j - k<em>C[i]] + k </em> W[i] )  其中 0 &lt;= k &lt;= V/C[i]  $</p>
<p>&emsp;即利用穷举的方式从不拿第 i 件物品到拿第 i 件物品装满背包都试一遍，看哪一种方案价值更大就选择哪一种方案。对于这种思路，就是将完全背包问题转化为01背包问题来求解，也有一些优化手段，比如如果两件物品 i 与 j 满足 C[i]  &lt;= C[j] &amp;&amp; W[i] &gt;= W[j]， 那么可以直接不用考虑 j 物品，因为每个物品可以拿无限多个，所以用价值高费用小的 i 替换 j 是显然不亏的。再比如用二进制编码的思想降低复杂度。</p>
<p>&emsp;但是，通过完全背包问题的递推式推导，却可以得到一个简单易懂的解决方法：</p>
<p>&emsp;完全背包问题递推式可以写成：</p>
<p>&emsp;$dp[i, j] = max( dp[i - 1, j], dp[i - 1, j - k<em>C[i]] + k </em> W[i] )  其中 1 &lt;= k &lt;= V/C[i]$       (2)</p>
<p>&emsp;由(1)式可得：</p>
<p>&emsp;$dp[i, j - C[i]] = max( dp[i - 1, j - C[i] - k<em>C[i]] + k </em> W[i] )  其中 1 &lt;= k + 1 &lt;= V/C[i]$</p>
<p>&emsp;$dp[i, j - C[i]] = max( dp[i - 1, j - (k + 1)<em>C[i]] + (k + 1) </em> W[i] - W[i] )  其中 1 &lt;= k + 1 &lt;= V/C[i]$</p>
<p>&emsp;令 m = k + 1 则可推导出：</p>
<p>&emsp;$dp[i, j - C[i]] = max( dp[i - 1, j - m<em>C[i]] + m </em> W[i] - W[i] )  其中 1 &lt;= m&lt;= V/C[i]$</p>
<p>&emsp;故可以得到：</p>
<p>&emsp;$dp[i, j - C[i]] + W[i] = max( dp[i - 1, j - m<em>C[i]] + m </em> W[i] )   其中 1 &lt;= m &lt;= V/C[i]$   (3)</p>
<p>&emsp;将(3)代入(2)中有：</p>
<p>&emsp;$dp[i, j] = max( dp[i - 1, j], dp[i, j - C[i]] + W[i] )$</p>
<p>&emsp;最终的这个公式与01背包的递推式相比较只有一处不同，而且由01背包需要逆序求解容易推导出，完全背包问题只需正序求解就能在一维数组下解决问题：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeBag</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> c, <span class="keyword">int</span> V, <span class="keyword">int</span>[] dp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = c; j &lt;= V; j++)</span><br><span class="line">    	dp[j] = Math.max(dp[j], dp[j - c] + w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bagProblem</span><span class="params">(<span class="keyword">int</span>[] C, <span class="keyword">int</span>[] W, <span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> dp[V + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C.length; i++)</span><br><span class="line">    	completeBag(W[i], C[i], V, dp);</span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h1><p>&emsp;多重背包问题就是每个物品能拿的数量是有限数m，这种情况下，如果一个物品的费用与能拿的次数的积大于背包容量，那么可以转化为完全背包问题求解，否则，要转化为01背包问题求解，可以用二进制编码优化时间复杂度。二进制编码优化是指，可以不用从0遍历到m次，可以转为1，2，4，2^k-1 与m - 2^k  + 1，其中k表示使2^k - 1 &lt;  m的最大k值。例如，m = 19，可以转为1， 2， 4， 8， 12，这样从1到19都能用这几个数组合得到，可以优化时间复杂度。<br>&emsp;传入一个数组M表示第i件物品只能拿M[i]次：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiBag</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> c, <span class="keyword">int</span> V, <span class="keyword">int</span>[] dp, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m * c &gt;= V)</span><br><span class="line">        completeBag(w, c, V, dp);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">2</span> * k - <span class="number">1</span> &lt; m)&#123;</span><br><span class="line">            zeroOneBag(w * k, c * k, V, dp);</span><br><span class="line">            k = <span class="number">2</span> * k;</span><br><span class="line">        &#125;</span><br><span class="line">        m = m - k / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        zeroOneBag(w * m, c * m, V, dp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bagProblem</span><span class="params">(<span class="keyword">int</span>[] C, <span class="keyword">int</span>[] W, <span class="keyword">int</span> V, <span class="keyword">int</span>[] M)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> dp[V + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C.length; i++)</span><br><span class="line">    	multiBag(W[i], C[i], V, dp, M[i]);</span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;假设每件物品平均能拿K次，多重背包问题在这种情况下时间复杂度为 $O(NVlgK)$ 。多重背包问题其实存在更好的方法可以达到 $O(NV)$ 的时间复杂度。</p>
<h1 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h1><p>&emsp;混合背包问题即之前三种背包问题的混合，有的物品最多只能拿1次，有的能拿无限次，有的能拿有限次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bagProblem</span><span class="params">(<span class="keyword">int</span>[] C, <span class="keyword">int</span>[] W, <span class="keyword">int</span> V, <span class="keyword">int</span>[] M)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> dp[V + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(M[i] == <span class="number">1</span>)</span><br><span class="line">        	zeroOneBag(w, c, V, dp);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(M[i] == <span class="number">0</span>) <span class="comment">// 表示能拿无限次</span></span><br><span class="line">        	completeBag(w, c, V, dp);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	multiBag(w[i], c[i], V, dp, M[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>背包问题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/06/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
