<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java反射机制</title>
    <url>/2020/06/27/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="java-lang-reflect"><a href="#java-lang-reflect" class="headerlink" title="java.lang.reflect"></a>java.lang.reflect</h1><p>&emsp;java.lang.reflect 包提供用于获取类和对象反射信息的类和接口。反射是指允许通过编程访问有关类的字段、方法和构造函数的信息，并允许使用反射的字段、方法和构造函数在封装和安全限制范围内对其基础对应项进行操作。</p>
<a id="more"></a>
<p>&emsp;该包下的类有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">AccessibleObject</th>
<th>是Filed，Method，Constructor类的父类，提供与权限相关的一些方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Array</td>
<td>提供了动态创建和访问Java数据的静态方法</td>
</tr>
<tr>
<td style="text-align:center">Constructor<T></td>
<td>提供类的单个构造函数的信息和访问</td>
</tr>
<tr>
<td style="text-align:center">Executable</td>
<td>Method和Constructor的父类</td>
</tr>
<tr>
<td style="text-align:center">Field</td>
<td>提供类的单个字段的信息和访问</td>
</tr>
<tr>
<td style="text-align:center">Method</td>
<td>提供类的单个方法的信息和访问</td>
</tr>
<tr>
<td style="text-align:center">Modifier</td>
<td>提供静态方法和常量来解码类和成员的访问修饰符</td>
</tr>
<tr>
<td style="text-align:center">Parameter</td>
<td>提供方法参数的信息</td>
</tr>
<tr>
<td style="text-align:center">Proxy</td>
<td>提供静态方法创建充当接口实例但允许自定义方法调用的对象( Jdk 动态代理)</td>
</tr>
<tr>
<td style="text-align:center">ReflectPermission</td>
<td>反射操作的权限类</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;通常使用到的类是 Constructor，Field，Method 与 Proxy 类。通常使用到的接口是 InvocationHandler 接口。其中 Proxy 类与 InvocationHandler 用在 jdk 动态代理上。</p>
<h1 id="反射获得类信息"><a href="#反射获得类信息" class="headerlink" title="反射获得类信息"></a>反射获得类信息</h1><p>&emsp;通过反射可以获得类的信息，定义 User 类如下，包含了一个私有构造函数，一个私有方法与三个私有字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"公共无参数构造函数"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> id, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.password = <span class="string">"protected Constructor"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">User</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = <span class="number">9999</span>;</span><br><span class="line">        <span class="keyword">this</span>.password = <span class="string">"private Constructor"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">testPrivateMethod</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打印传入字符串"</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......省略了getter，setter方法与toString()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反射获得与调用构造函数"><a href="#反射获得与调用构造函数" class="headerlink" title="反射获得与调用构造函数"></a>反射获得与调用构造函数</h2><p>&emsp;接下来，可以通过反射调用这些私有字段与方法，<strong>反射需要先获得类对象，获得类对象有三种方法</strong>，会体现在接下来的代码中，首先是调用构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] s)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="comment">// 第一种获得类Class对象的方法，调用对象的getClass()方法，该方法继承自Object</span></span><br><span class="line">    Class clazz = user.getClass();</span><br><span class="line"></span><br><span class="line">    Constructor[] constructors = clazz.getConstructors(); <span class="comment">// 获得public修饰的构造函数</span></span><br><span class="line">    <span class="keyword">for</span>(Constructor c : constructors)</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line"></span><br><span class="line">    constructors = clazz.getDeclaredConstructors();<span class="comment">// 获得所有构造函数</span></span><br><span class="line">    <span class="keyword">for</span>(Constructor c : constructors)</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line"></span><br><span class="line">    Constructor constructor = clazz.getConstructor(); <span class="comment">// 获得公共无参数构造函数</span></span><br><span class="line">    System.out.println(constructor.newInstance()); <span class="comment">// 调用Constructor的newInstance创建对象</span></span><br><span class="line"></span><br><span class="line">    constructor = clazz.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>; <span class="comment">// 获得被保护的构造函数，传入参数类型</span></span><br><span class="line">    System.out.println(constructor.newInstance(<span class="string">"protected Constructor"</span>, <span class="number">111</span>));</span><br><span class="line"></span><br><span class="line">    constructor = clazz.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">// 获得私有构造函数</span></span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);                                    <span class="comment">// 必须先解除私有限定！！！！</span></span><br><span class="line">    System.out.println(constructor.newInstance(<span class="string">"private constructor"</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">public fanshedemo.User(java.lang.String,int,java.lang.String)</span><br><span class="line">public fanshedemo.User()</span><br><span class="line">--------------------</span><br><span class="line">private fanshedemo.User(java.lang.String)</span><br><span class="line">protected fanshedemo.User(java.lang.String,int)</span><br><span class="line">public fanshedemo.User(java.lang.String,int,java.lang.String)</span><br><span class="line">public fanshedemo.User()</span><br><span class="line">--------------------</span><br><span class="line">User&#123;name=<span class="string">'公共无参数构造函数'</span>, id=<span class="number">0</span>, password=<span class="string">'null'</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">'protected Constructor'</span>, id=<span class="number">111</span>, password=<span class="string">'protected Constructor'</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">'private constructor'</span>, id=<span class="number">9999</span>, password=<span class="string">'private Constructor'</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反射获得与调用类方法"><a href="#反射获得与调用类方法" class="headerlink" title="反射获得与调用类方法"></a>反射获得与调用类方法</h2><p>&emsp;接下来，是反射获得类的方法，运行如下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] s)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Class clazz = User<span class="class">.<span class="keyword">class</span></span>; <span class="comment">// 第二种获得类Class对象的方法，访问它的静态字段class即可</span></span><br><span class="line"></span><br><span class="line">    Method[] methods = clazz.getMethods(); <span class="comment">// 获得非私有方法，包含父类方法</span></span><br><span class="line">    <span class="keyword">for</span>(Method m : methods)</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    System.out.println(<span class="string">"---------以上方法包含非私有方法与父类Object方法-----------"</span>);</span><br><span class="line"></span><br><span class="line">    methods = clazz.getDeclaredMethods(); <span class="comment">// 获得所有方法，不包含父类方法</span></span><br><span class="line">    <span class="keyword">for</span>(Method m : methods)</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line"></span><br><span class="line">    User u = <span class="keyword">new</span> User(<span class="string">"name"</span>, <span class="number">88</span>, <span class="string">"password"</span>);</span><br><span class="line">    System.out.println(u);</span><br><span class="line">    Method method = clazz.getMethod(<span class="string">"setName"</span>, String<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">// 传入方法名与参数获得方法</span></span><br><span class="line">    method.invoke(u,<span class="string">"new Name"</span>);      <span class="comment">// 调用时需要传入调用该方法的对象u</span></span><br><span class="line">    System.out.println(u);</span><br><span class="line"></span><br><span class="line">    method = clazz.getDeclaredMethod(<span class="string">"testPrivateMethod"</span>, String<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">// getDeclaredMethod方法可以获得private方法</span></span><br><span class="line">    method.setAccessible(<span class="keyword">true</span>);                               <span class="comment">// 解除私有限定</span></span><br><span class="line">    Object o = method.invoke(u,<span class="string">"invoke private method"</span>);      <span class="comment">// 获得返回值</span></span><br><span class="line">    System.out.println(<span class="string">"返回值是"</span> + o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp; 以上代码运行后结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">public java.lang.String fanshedemo.User.toString()</span><br><span class="line">public java.lang.String fanshedemo.User.getName()</span><br><span class="line">public void fanshedemo.User.setName(java.lang.String)</span><br><span class="line">public int fanshedemo.User.getId()</span><br><span class="line">public void fanshedemo.User.setPassword(java.lang.String)</span><br><span class="line">public java.lang.String fanshedemo.User.getPassword()</span><br><span class="line">public void fanshedemo.User.setId(int)</span><br><span class="line">public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span><br><span class="line">public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span><br><span class="line">public final void java.lang.Object.wait() throws java.lang.InterruptedException</span><br><span class="line">public boolean java.lang.Object.equals(java.lang.Object)</span><br><span class="line">public native int java.lang.Object.hashCode()</span><br><span class="line">public final native java.lang.Class java.lang.Object.getClass()</span><br><span class="line">public final native void java.lang.Object.notify()</span><br><span class="line">public final native void java.lang.Object.notifyAll()</span><br><span class="line">---------以上方法包含非私有方法与父类Object方法-----------</span><br><span class="line">public java.lang.String fanshedemo.User.toString()</span><br><span class="line">public java.lang.String fanshedemo.User.getName()</span><br><span class="line">public void fanshedemo.User.setName(java.lang.String)</span><br><span class="line">public int fanshedemo.User.getId()</span><br><span class="line">private java.lang.String fanshedemo.User.testPrivateMethod(java.lang.String)</span><br><span class="line">public void fanshedemo.User.setPassword(java.lang.String)</span><br><span class="line">public java.lang.String fanshedemo.User.getPassword()</span><br><span class="line">public void fanshedemo.User.setId(int)</span><br><span class="line">--------------------</span><br><span class="line">User&#123;name=<span class="string">'name'</span>, id=<span class="number">88</span>, password=<span class="string">'password'</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">'new Name'</span>, id=<span class="number">88</span>, password=<span class="string">'password'</span>&#125;</span><br><span class="line">打印传入字符串invoke private method</span><br><span class="line">返回值是invoke private method</span><br></pre></td></tr></table></figure>
<h2 id="反射获得与访问类的字段"><a href="#反射获得与访问类的字段" class="headerlink" title="反射获得与访问类的字段"></a>反射获得与访问类的字段</h2><p>&emsp;接下来，是反射获得类的字段，运行如下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] s)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 第三种获得Class对象的方法，通过Class的静态方法forName，需传入类的全限定名</span></span><br><span class="line">    Class clazz = Class.forName(<span class="string">"fanshedemo.User"</span>);</span><br><span class="line"></span><br><span class="line">    Field[] fields = clazz.getFields(); <span class="comment">// 获得非私有字段，包含父类</span></span><br><span class="line">    <span class="keyword">for</span>(Field field : fields)</span><br><span class="line">        System.out.println(field);</span><br><span class="line">    System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line">    fields = clazz.getDeclaredFields(); <span class="comment">// 获得所有字段，不包含父类</span></span><br><span class="line">    <span class="keyword">for</span>(Field field : fields)</span><br><span class="line">        System.out.println(field);</span><br><span class="line">    System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line"></span><br><span class="line">    User u = <span class="keyword">new</span> User(<span class="string">"name"</span>, <span class="number">111</span>, <span class="string">"password"</span>);</span><br><span class="line">    System.out.println(u);</span><br><span class="line">    Field field = clazz.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);       <span class="comment">// 解除私有限定</span></span><br><span class="line">    field.set(u, <span class="string">"new name"</span>);        <span class="comment">// 调用Field的set方法设置新值</span></span><br><span class="line">    System.out.println(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;以上代码运行后结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">--------------------</span><br><span class="line">private java.lang.String fanshedemo.User.name</span><br><span class="line">private int fanshedemo.User.id</span><br><span class="line">private java.lang.String fanshedemo.User.password</span><br><span class="line">--------------------</span><br><span class="line">User&#123;name=<span class="string">'name'</span>, id=<span class="number">111</span>, password=<span class="string">'password'</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">'new name'</span>, id=<span class="number">111</span>, password=<span class="string">'password'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;通过反射，可以在运行时获取对象的构造函数，方法，字段信息并访问它们，除此之外，Class 类还有 getInterfaces() 方法可以获得类所有实现的接口，getSuperClass() 可以获得类的父类等方法。</p>
<h1 id="利用反射运行指定方法"><a href="#利用反射运行指定方法" class="headerlink" title="利用反射运行指定方法"></a>利用反射运行指定方法</h1><p>&emsp;利用反射读取配置文件信息，根据配置文件信息运行指定方法。之前的 User 类不必改动，创建配置文件，填上如下内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">className=fanshedemo.User</span><br><span class="line">methodName=testPrivateMethod</span><br></pre></td></tr></table></figure>
<p>&emsp;之后修改 main 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] s)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"src/main/java/fanshedemo/config.properties"</span>);</span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    properties.load(in);</span><br><span class="line">    in.close();</span><br><span class="line">    String className = properties.getProperty(<span class="string">"className"</span>);</span><br><span class="line">    String methodName = properties.getProperty(<span class="string">"methodName"</span>);</span><br><span class="line">    Class clazz = Class.forName(className);</span><br><span class="line">    Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">    Object o = clazz.getConstructor().newInstance(); <span class="comment">// 获得对象</span></span><br><span class="line">    <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">        <span class="keyword">if</span>(method.getName().equals(methodName))&#123; <span class="comment">//找到对应方法名的方法</span></span><br><span class="line">            Parameter[] parameters = method.getParameters(); <span class="comment">// 获得方法定义的所有参数对象</span></span><br><span class="line">            Object[] objects = <span class="keyword">new</span> Object[parameters.length]; <span class="comment">// 传入方法的参数数组</span></span><br><span class="line">            <span class="comment">// 根据参数的类型新建参数默认参数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameters.length; i++)</span><br><span class="line">                objects[i] = Class.forName(parameters[i].getType().getName()).getConstructor().newInstance();</span><br><span class="line">            method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            method.invoke(o, objects);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;调用结果为：<code>打印传入字符串</code>，可知已经成功的在读取配置文件后通过反射调用一个方法，当然，实际情况可能不会这么简单，会更加复杂，这只是一个基础的小 demo 。</p>
<h1 id="利用反射绕过泛型检查"><a href="#利用反射绕过泛型检查" class="headerlink" title="利用反射绕过泛型检查"></a>利用反射绕过泛型检查</h1><p>&emsp;利用反射，还可以绕过泛型检查，例子如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"aaa"</span>);</span><br><span class="line">    list.add(<span class="string">"bbb"</span>);</span><br><span class="line">    Class clazz = list.getClass();</span><br><span class="line">    Method method = clazz.getMethod(<span class="string">"add"</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    method.invoke(list, <span class="number">123</span>);</span><br><span class="line">    method.invoke(list, <span class="keyword">false</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;上述代码运行结果：<code>[aaa, bbb, 123, false]</code>，由此，通过反射便绕过了 List 的泛型检查。</p>
<h1 id="通过反射获得泛型实际参数"><a href="#通过反射获得泛型实际参数" class="headerlink" title="通过反射获得泛型实际参数"></a>通过反射获得泛型实际参数</h1><p>&emsp;通过反射可以获得泛型实际参数，需要先了解 reflect 包中几个接口：</p>
<ul>
<li><strong>Type 接口</strong>：Type是Java编程语言中所有类型的通用超接口。这些类型包括原始类型、<strong>参数化类型</strong>、数组类型、类型变量和基本类型。 这个接口中只有一个方法 getTypeName() ，调用该方法可以获得类型名。</li>
<li><strong>ParameterizedType 接口</strong>：ParameterizedType表示参数化类型 ，其中的方法 getActualTypeArguments() 可以返回表示此类型的实际类型参数的类型对象数组，即 Type 数组。 </li>
<li><strong>WildcardType 接口</strong>：表示一个通配符类型表达式 ，其中有 getLowerBounds() 与 getUpperBounds() 方法，分别返回表示此类型变量的下界与上界的类型对象数组。其中 getUpperBounds() 如果没有显式声明上限，则上限为Object。 </li>
</ul>
<h2 id="通过反射获得类的泛型实际类型"><a href="#通过反射获得类的泛型实际类型" class="headerlink" title="通过反射获得类的泛型实际类型"></a>通过反射获得类的泛型实际类型</h2><p>&emsp;通过反射获得类实际泛型实际类型，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个带参数化类型的超类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span>&lt;<span class="title">T</span>,<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承自该超类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> <span class="keyword">extends</span> <span class="title">Base</span>&lt;<span class="title">String</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GenericDemo genericDemo = <span class="keyword">new</span> GenericDemo();</span><br><span class="line">        Class clazz = genericDemo.getClass();</span><br><span class="line">        <span class="comment">// Class对象中的方法，可以返回表示该类所表示的实体的直接超类的类型</span></span><br><span class="line">        <span class="comment">// 还有getGenericInterfaces方法返回接口中的类型</span></span><br><span class="line">        Type genericClass = clazz.getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span>(genericClass <span class="keyword">instanceof</span> ParameterizedType)&#123; <span class="comment">// 判断是不是参数化类型</span></span><br><span class="line">            ParameterizedType parameterizedType = (ParameterizedType)genericClass;</span><br><span class="line">            <span class="comment">// 返回表示此类型的实际类型参数的类型对象数组</span></span><br><span class="line">            Type[] types = parameterizedType.getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span>(Type type: types)&#123;</span><br><span class="line">                System.out.println(type.getTypeName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;代码运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">java.lang.String</span><br><span class="line">java.lang.Integer</span><br></pre></td></tr></table></figure>
<h2 id="通过反射获得方法参数的泛型实际类型"><a href="#通过反射获得方法参数的泛型实际类型" class="headerlink" title="通过反射获得方法参数的泛型实际类型"></a>通过反射获得方法参数的泛型实际类型</h2><p>&emsp;通过反射获得方法参数的泛型实际类型，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> <span class="keyword">extends</span> <span class="title">Base</span>&lt;<span class="title">String</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个方法参数有泛型类型的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">genericMethodDemo</span><span class="params">(Map&lt;String, Integer&gt; map, List&lt;String&gt; list, String string)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        GenericDemo genericDemo = <span class="keyword">new</span> GenericDemo();</span><br><span class="line">        Class clazz = genericDemo.getClass();</span><br><span class="line">        <span class="comment">// 获得该方法</span></span><br><span class="line">        Method method = clazz.getMethod(<span class="string">"genericMethodDemo"</span>, Map<span class="class">.<span class="keyword">class</span>, <span class="title">List</span>.<span class="title">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 返回方法的所有带有泛型的参数，返回值是数组类型</span></span><br><span class="line">        Type[] types = method.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span>(Type type: types)&#123;</span><br><span class="line">            <span class="keyword">if</span>(type <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">                ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">                <span class="comment">// 获得真实类型</span></span><br><span class="line">                Type[] genericTypes = parameterizedType.getActualTypeArguments(); </span><br><span class="line">                <span class="keyword">for</span>(Type genericType : genericTypes)</span><br><span class="line">                    System.out.println(genericType.getTypeName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;代码运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">java.lang.String</span><br><span class="line">java.lang.Integer</span><br><span class="line">java.lang.String</span><br></pre></td></tr></table></figure>
<h2 id="通过反射获得方法返回值的泛型实际类型"><a href="#通过反射获得方法返回值的泛型实际类型" class="headerlink" title="通过反射获得方法返回值的泛型实际类型"></a>通过反射获得方法返回值的泛型实际类型</h2><p>&emsp;通过反射获得方法返回值的泛型实际类型，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> <span class="keyword">extends</span> <span class="title">Base</span>&lt;<span class="title">String</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个方法返回值有泛型类型的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title">genericMethodDemo2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        GenericDemo genericDemo = <span class="keyword">new</span> GenericDemo();</span><br><span class="line">        Class clazz = genericDemo.getClass();</span><br><span class="line">        <span class="comment">// 获得该方法</span></span><br><span class="line">        Method method = clazz.getMethod(<span class="string">"genericMethodDemo2"</span>);</span><br><span class="line">        <span class="comment">// 返回值只有一个，所以不是数据类型</span></span><br><span class="line">        Type type = method.getGenericReturnType();</span><br><span class="line">        <span class="keyword">if</span>(type <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">            ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">            Type[] genericTypes = parameterizedType.getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span>(Type genericType : genericTypes)</span><br><span class="line">                System.out.println(genericType.getTypeName());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;代码运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">java.lang.String</span><br><span class="line">java.lang.Integer</span><br></pre></td></tr></table></figure>
<h2 id="通过反射获得方法返回值的泛型实际类型-1"><a href="#通过反射获得方法返回值的泛型实际类型-1" class="headerlink" title="通过反射获得方法返回值的泛型实际类型"></a>通过反射获得方法返回值的泛型实际类型</h2><p>&emsp;通过反射获得方法返回值的泛型实际类型，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> <span class="keyword">extends</span> <span class="title">Base</span>&lt;<span class="title">String</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个参数类型泛型有上下界的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">genericMethodDemo3</span><span class="params">(List&lt;? extends Number&gt; l1, List&lt;? <span class="keyword">super</span> Integer&gt; l2)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        GenericDemo genericDemo = <span class="keyword">new</span> GenericDemo();</span><br><span class="line">        Class clazz = genericDemo.getClass();</span><br><span class="line">        Method method = clazz.getMethod(<span class="string">"genericMethodDemo3"</span>, List<span class="class">.<span class="keyword">class</span>, <span class="title">List</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        Type[] types = method.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span>(Type type: types)&#123;</span><br><span class="line">            <span class="keyword">if</span>(type <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">                ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">                Type[] genericTypes = parameterizedType.getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span>(Type genericType : genericTypes)&#123;</span><br><span class="line">                    System.out.println(genericType.getTypeName());</span><br><span class="line">                    <span class="keyword">if</span>(genericType <span class="keyword">instanceof</span> WildcardType)&#123; <span class="comment">// 如果是该类型则强转</span></span><br><span class="line">                        WildcardType wildcardType = (WildcardType) genericType;</span><br><span class="line">                        System.out.println(<span class="string">"下界"</span>);</span><br><span class="line">                        <span class="keyword">for</span>(Type t : wildcardType.getLowerBounds()) <span class="comment">// 获得下界</span></span><br><span class="line">                            System.out.println(t.getTypeName());</span><br><span class="line">                        System.out.println(<span class="string">"上界"</span>);</span><br><span class="line">                        <span class="keyword">for</span>(Type t : wildcardType.getUpperBounds()) <span class="comment">// 获得上界</span></span><br><span class="line">                            System.out.println(t.getTypeName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;代码运行结果如下：结果也说明了，没有显示声明下界，下界为null，没有显示声明上界，上界为 Object 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">? extends java.lang.Number</span><br><span class="line">下界</span><br><span class="line">上界</span><br><span class="line">java.lang.Number</span><br><span class="line">? super java.lang.Integer</span><br><span class="line">下界</span><br><span class="line">java.lang.Integer</span><br><span class="line">上界</span><br><span class="line">java.lang.Object</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Object类</title>
    <url>/2020/06/25/Java-Object%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="Object类源码"><a href="#Object类源码" class="headerlink" title="Object类源码"></a>Object类源码</h1><h2 id="getClass-方法"><a href="#getClass-方法" class="headerlink" title="getClass 方法"></a>getClass 方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure>
<p>&emsp;这个方法是 Native 方法，返回的是一个对象的实际类型，返回的type是Class&lt;? extends |X|&gt;，例如，如下代码输出的结果是 Integer。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Number n = <span class="number">0</span>;</span><br><span class="line">System.out.println(n.getClass());</span><br></pre></td></tr></table></figure>
<h2 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;在Object类的文档中，对 hashCode() 方法做了详细的要求：</p>
<ul>
<li>如果对象的信息没有被修改，对同一个对象的多次调用应该返回同一个结果。</li>
<li>如果两个对象 equals() 方法调用结果为 true，那么这两个对象应该返回相同的 hashCode ，故覆盖 equals 方法必须覆盖 hashCode 方法。</li>
<li>并不强制要求不相等的两个对象的 hashCode 必须不相同，但是不同的 hashCode 对 hash 表的使用更友好。</li>
</ul>
<h1 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals 方法"></a>equals 方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;在 Object 类的文档中，对 equals 方法做了详细的要求:</p>
<ul>
<li>该方法可以返回<strong>非空对象引用</strong>的等价关系。</li>
<li>该方法应该具备<strong>自反性</strong>，即 x.equals(x) 应该返回 true 。</li>
<li>该方法应该具备<strong>对称性</strong>，即 x.equals(y) 返回 true 时，y.equals(x) 也应该返回 true 。</li>
<li>该方法应该具备<strong>传递性</strong>，即 x.equals(y) 返回 true ，y.equals(z) 也返回 true 时， x.equals(z) 也应该返回 true 。</li>
<li>该方法应该具备<strong>一致性</strong>，即在对象未被修改的情况下，多次调用x.equals(y) 返回值也一样。</li>
<li>对于任意非空引用 x ，x.equals(null) 的结果应该是 false 。</li>
</ul>
<h1 id="clone-方法"><a href="#clone-方法" class="headerlink" title="clone 方法"></a>clone 方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp; clone方法返回一个对象的复制，一般要求满足 x.clone() != x 成立，并且 x.clone().getClass() == x.getClass() 成立。这个方法返回的对象应该与原对象独立，使用原对象的字段对返回的对象进行初始化。<br>&emsp;类在实现这个方法时，必须先实现 Cloneable 接口。如果没有实现接口 Cloneable ，则抛出 CloneNotSupportedException 。注意，所有数组都被认为实现了Cloneable接口，数组类型T[]的克隆方法的返回类型是T[]，其中T是任何引用或基本类型。</p>
<h1 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString 方法"></a>toString 方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp; 这个方法返回对象的字符串表示形式。</p>
<h1 id="线程相关方法"><a href="#线程相关方法" class="headerlink" title="线程相关方法"></a>线程相关方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会唤醒等待在当前对象监视器的线程，被唤起的线程重新加入监视器锁的竞争中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有获得当前对象监视器锁的线程才能调用，线程放弃当前监视器锁，转入等待队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    wait(<span class="number">0L</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeoutMillis, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure>
<p>&emsp;线程在执行 synchronized 标识的方法，代码块，静态方法时会获得当前对象监视器的锁。</p>
<h1 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize 方法"></a>finalize 方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span>(since=<span class="string">"9"</span>)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;这个方法并不被推荐使用，因为它的执行时间，执行顺序，是否执行完成都不能确定。在需要释放资源的场合，推荐使用 AutoCloseable 接口完成。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Object</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Jdk 动态代理</title>
    <url>/2020/06/29/Jdk-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>&emsp;所谓代理模式，就是为其它对象提供一个代理来控制对目标对象的访问，代理类不实现具体的服务，利用委托类来完成服务。</p>
<a id="more"></a>
<h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>&emsp;静态代理十分简单。创建一个接口，然后创建被代理的类实现该接口并且实现该接口中的抽象方法。之后再创建一个代理类，同时使其也实现这个接口。在代理类中持有一个被代理对象的引用，而后在代理类方法中调用该对象的方法 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设计一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String s)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被代理类实现该接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String s)</span> <span class="keyword">throws</span> IllegalArgumentException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数不合法"</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类也实现该接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloStaticProxy</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    Hello hello; <span class="comment">// 被代理的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloStaticProxy</span><span class="params">(Hello hello)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hello = hello; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String s)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before method invoke"</span>);</span><br><span class="line">        String re = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isException = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.hello.say(s);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IllegalArgumentException e)&#123;</span><br><span class="line">            isException = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"after method invoke"</span>);</span><br><span class="line">        <span class="keyword">if</span>(isException)</span><br><span class="line">            System.out.println(<span class="string">"after method throw Exception"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Hello hello = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">        Hello proxy = <span class="keyword">new</span> HelloStaticProxy(hello); <span class="comment">// 将被代理对象传入新建一个代理对象</span></span><br><span class="line">        proxy.say(<span class="keyword">null</span>);  <span class="comment">// 代理类在执行具体方法时通过所持用的被代理类完成调用</span></span><br><span class="line">        System.out.println(<span class="string">"------------------"</span>);</span><br><span class="line">        proxy.say(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;以上代码运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">before method invoke</span><br><span class="line">after method invoke</span><br><span class="line">after method throw Exception</span><br><span class="line">------------------</span><br><span class="line">before method invoke</span><br><span class="line">hello</span><br><span class="line">after method invoke</span><br></pre></td></tr></table></figure>
<p>&emsp;这样，当需要代理一个类的时候，只要编写一个该类的静态代理对象即可，但是，如果需要代理的对象很多，就需要编写大量的代理类，十分麻烦 。</p>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>&emsp;动态代理能够利用反射机制在程序运行期间生成代理类。在 java.lang.reflect 包下的 Proxy 类有一个静态方法 newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)，通过该方法可以获得动态代理类。它需要一个类加载器，类的接口数组，以及一个实现 InvocationHandler 接口的类。</p>
<p>&emsp; InvocationHandler 中只声明了一个方法：Object invoke(Object proxy, Method method, Object[] args) throws Throwable ，通过这个方法，可以调用被代理类的方法，需要注意，<strong>invoke 参数中的 proxy 表示的是代理对象，而不是被代理对象</strong>，因此 method.invoke() 传入的参数不能是它，否则会循环调用。</p>
<p>&emsp;上面的接口与接口实现类不变，创建一个实现了 InvocationHandler 的类完成动态代理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    Object target; <span class="comment">// 被代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyProxyHandler</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before method invoke"</span>);</span><br><span class="line">        Object re = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isException = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            re = method.invoke(target, args); <span class="comment">// 调用被代理对象的方法</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            isException = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"after method invoke"</span>);</span><br><span class="line">        <span class="keyword">if</span>(isException) &#123;</span><br><span class="line">            System.out.println(<span class="string">"after method throw Exception"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Hello hello = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">        Hello helloProxy = (Hello)Proxy.newProxyInstance(hello.getClass().getClassLoader(),</span><br><span class="line">                hello.getClass().getInterfaces(), <span class="keyword">new</span> MyProxyHandler(hello));</span><br><span class="line">        helloProxy.say(<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line">        helloProxy.say(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">before method invoke</span><br><span class="line">after method invoke</span><br><span class="line">after method throw Exception</span><br><span class="line">-----------------</span><br><span class="line">before method invoke</span><br><span class="line">hello</span><br><span class="line">after method invoke</span><br></pre></td></tr></table></figure>
<p>&emsp;jdk动态代理必须要依靠接口实现，因为生成的代理类是 Proxy 的子类，而 Java 不允许多继承，所以需要接口来连接代理类与被代理类。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java垃圾收集机制</title>
    <url>/2020/06/25/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="判断对象是否可回收"><a href="#判断对象是否可回收" class="headerlink" title="判断对象是否可回收"></a>判断对象是否可回收</h1><p>&emsp;判断一个对象是否可以被回收，即还有没有其它指针指向它，如果没有了，说明这个对象已经不可以再被使用到了，就可以回收掉它的内存空间。主要有两种方式可以判断：</p>
<a id="more"></a>
<p>&emsp;- 引用计数法：每当有一个引用引用到对象，就给对象的引用计数加一，这样当某个对象的引用计数为0时，就说明该对象已经可以被回收了，但是该方法有循环引用的问题。</p>
<p>&emsp;- 可达性分析算法：以GC Roots对象为起点开始搜索引用链，凡是能搜索到的对象都是存活的对象，未能搜索到的对象都是可回收的对象。</p>
<p>&emsp;Java虚拟机中多使用可达性分析算法，其中GC Roots对象有4类：</p>
<ul>
<li>方法区中的常量引用的对象。</li>
<li>方法区中静态变量引用的对象。</li>
<li>栈中局部变量引用的对象。</li>
<li>本地方法栈中引用的对象。</li>
</ul>
<p>&emsp;Java中对象有四种引用：强引用，一定不会被垃圾收集；软引用，空间不足时会被收集；弱引用，下一次垃圾收集就被收集；虚引用，不会对对象的生命周期产生任何影响。</p>
<h2 id="对类的回收"><a href="#对类的回收" class="headerlink" title="对类的回收"></a>对类的回收</h2><p>&emsp;虚拟机对类的回收十分严苛，需要满足三个条件，并且满足了也不一定会回收：</p>
<ol>
<li>类的所有实例已经被回收。</li>
<li>加载该类的ClassLoader已经被回收。</li>
<li>该类对应的Class对象没有被引用，不能通过反射获得该类。</li>
</ol>
<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><ol>
<li>标记-清除算法：虚拟机标记可达对象后，将不可达的对象统一清除。这种算法效率比较低，而且容易造成空间碎片。</li>
<li>标记-整理算法：虚拟机将可达的对象全部移动到内存的一侧，将边界以外的空间一起释放。好处是无内存碎片，缺点是效率低。</li>
<li>复制算法：将内存分两块，只使用一块，在垃圾收集时将存活对象移动到另一块即可。好处是效率高，但是内存只使用到一半。虚拟机内实现一般分为一块Eden与两块Survivor，比例8：1：1，每次使用Eden与一块Survivor，留一块Survivor做垃圾收集时的复制空间，这样可以提高空间利用率。</li>
</ol>
<h1 id="Stop-the-world"><a href="#Stop-the-world" class="headerlink" title="Stop the world"></a>Stop the world</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;由于不能出现可达性分析过程中对象引用关系还在不断变化的情况，因此<strong>GC时必须停顿所有的Java执行线程</strong>，会影响系统响应以及用户体验，在HotSpot实现中，使用一组称为OopMap的数据结构来存储哪些地方存放着对象引用，这样可以减少GC时扫描全局引用的时间。<br>&nbsp;&nbsp;&nbsp;&nbsp;HotSpot并没有为每条指令都生成OopMap，只在“特定的位置”记录，这些位置称为安全点，因此程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能。但还有一个问题需要考虑，如何在GC时让所有线程都跑到最近的安全点上停顿，有两种方式：</p>
<ul>
<li>抢先示中中断，不需要线程的执行代码配合，在GC时，中断所有线程，如果发现有线程中断的地方不在安全点上，就让它跑到安全点上，现在几乎没有虚拟机采用这种方法。</li>
<li><strong>主动式中断，当GC需要中断线程时，设置一个标志，各个线程主动轮询这个标志，发现为真时自己中断挂起。</strong>    </li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;当线程处于挂起状态时，无法响应中断请求，这种时候需要安全区域来解决。<strong>安全区域是指在一段代码片段中，引用关系不会发生变化。在这个区域中的任何地方开始GC都是安全的，安全区域可以看作是扩展的安全区域。</strong></p>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>&emsp;很多垃圾收集器采用分代收集的方式，将堆中的内存分为新生代和老年代，新生代的对象通常存活时间较短，回收比较频繁，采用效率高的复制算法，老年代的对象存活时间很长，回收不频繁，采用标记-清除或标记-整理算法。</p>
<ul>
<li>Serial 与 Serial Old 收集器：单线程收集器，垃圾收集时需要暂停其它工作线程，直到收集结束。主要用在Client模式下的虚拟机。</li>
<li>ParNew 收集器： Serial收集器的多线程版本，主要用在Server模式的虚拟机上，能与CMS收集器配合工作。</li>
<li>Parallel Scavenge 与 Parallel Old 收集器，多线程吞吐量优先收集器。</li>
</ul>
<h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>&emsp;目标是获得最短的回收停顿时间，基于标记清除算法实现，在Server端使用比较多。运作过程包括<strong>初始标记，并发标记，重新标记与并发清除</strong>。初始标记只标记GC Roots能直接关联到的对象，速度很快；并发标记就是进行可达性分析的过程；重新标记修正并发标记期间引用关系发生变化的部分；并发清除则是清除不可达对象，回收空间。</p>
<p>&emsp;整个过程中，并发标记与并发清楚可以和用户线程一起工作，因此停顿时间只有初始标记和重新标记的过程，但时间并不长。</p>
<p>&emsp;CMS收集器的缺点是有空间碎片产生，无法处理浮动垃圾以及对CPU资源十分敏感。</p>
<h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>&emsp;G1收集器主要应用在Server端。它将对划分为多个大小相等的独立区域，新生代和老年代不再物理隔离。它会跟踪每个区域垃圾堆积的大小，维护一个优先列表，回收时回收价值最大的区域。运作工程包括初始标记，并发标记，最终标记，筛选回收。由于可以控制回收多少块区域，因此可以得到一个<strong>可预测的停顿时间</strong>。</p>
<h1 id="对象内存分配"><a href="#对象内存分配" class="headerlink" title="对象内存分配"></a>对象内存分配</h1><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><ul>
<li>对象优先在新生代的Eden分配</li>
<li>大对象直接进入老年代</li>
<li>长期存活的对象进入老年代，可以设定年龄阈值或者动态年龄判断</li>
</ul>
<h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><p>&emsp;在堆上为对象分配内存是，如果内存是绝对规整的，可以使用<strong>指针碰撞</strong>，直接让指针偏移出对象内存大小即可。如果内存不规则，需要维护一个<strong>空闲列表</strong>，从列表中选择能满足对象内存需求的内存块分配给对象。</p>
<p>&emsp;对象在分配时，也需要保证线程的安全，通常本地线程会预先分到一块内存空间作为<strong>本地线程缓冲</strong>，该线程创建的对象都在这块空间内分配，当缓冲用完后，需要申请新的空间时才需要同步锁定。</p>
<h1 id="Minor-GC-与-Full-GC"><a href="#Minor-GC-与-Full-GC" class="headerlink" title="Minor GC 与 Full GC"></a>Minor GC 与 Full GC</h1><p>&emsp;Minor GC 主要回收新生代的空间，Major GC 主要回收老年代空间，Full GC 回收老年代与新生代与元空间。</p>
<p>&emsp;触发full gc 的条件：</p>
<ul>
<li>调用System.gc() 方法，但是不一定会执行</li>
<li>老年代空间不足</li>
<li>空间分配担保失败</li>
<li>永久代( jdk 1.7 之前) 或 元空间不足</li>
<li>CMS GC 发生错误</li>
</ul>
<h1 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h1><p>&emsp;对象被回收时，如果对象覆盖了Object类的finalize()方法，虚拟机会在回收前执行对象的finalize()方法，但是不保证什么时候开始执行，也并不保证一定会执行完这个方法。</p>
]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>虚拟机</tag>
        <tag>垃圾收集</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2020/06/24/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="部分背包问题"><a href="#部分背包问题" class="headerlink" title="部分背包问题"></a>部分背包问题</h1><p>&emsp;部分背包问题即装入背包的物品可分割，可以用简单的贪心算法解决，物品平均价值由高到低排序，依次放入背包，直到放不下。<br><a id="more"></a></p>
<p>&emsp;例如：有一堆金粉，银粉，铜粉和铁粉，用一个固定大小的袋子去装，只要从平均价值最大的金粉开始装，装完后装下一堆平均价值最大的物品，直到袋子装满为止即可。</p>
<h1 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>&emsp;有N件物品，第 i 件物品重Ci，价值Wi，你有一个能装重量V的背包，每件物品只有一个，你需要装入哪些物品才能使背包内的价值总和最大？</p>
<h2 id="动态规划公式"><a href="#动态规划公式" class="headerlink" title="动态规划公式"></a>动态规划公式</h2><p>&emsp;定义dp[i, v]表示将前 i 件物品放入容量为 v 的背包可以获得最大价值总和，那么在这个情况下，有两种可能，要么第 i 件物品放入了背包内， 要么第 i 件物品没有放入背包内。</p>
<p>&emsp;如果第 i 件物品没有放入背包内，相当于<strong>dp[i, v] = dp[i - 1, v]</strong>，即将前面 i - 1件物品放入容量为v的背包中的最大价值总和。</p>
<p>&emsp;如果第 i 件物品放入了背包内，相当于<strong>dp[i, v] = dp[i - 1, v - Ci] + Wi</strong>，因为第 i 件物品放入了背包，所以相当于前面 i - 1 件物品占用v - Ci的空间的最大价值总和再加上第 i 件物品的价值。</p>
<p>&emsp;但是两种可能只能选择一种，价值最大的那种，所以01背包的递推公式为：<strong>dp[i, v] = max{dp[i - 1, v], dp[i - 1, v - Ci] + Wi}</strong></p>
<h2 id="解法与优化"><a href="#解法与优化" class="headerlink" title="解法与优化"></a>解法与优化</h2><p>&emsp;既然已经得到了递推公式，根据递推公式不断计算，最终算到<code>dp[N, V]</code>就是问题的答案了，可以创建一个二维数组计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bagProblem</span><span class="params">(<span class="keyword">int</span>[] C, <span class="keyword">int</span>[] W, <span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> dp[C.length + <span class="number">1</span>][V + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C.length; i++)&#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> j = C[i]; j &lt;= V; j++)&#123;</span><br><span class="line">        	dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - C[i]] + W[i]);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;   </span><br><span class="line">    <span class="keyword">return</span> dp[C.length][[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;从代码中不难看出，二维数组在计算过程中是逐行计算的，并且第 i 行的数据只依赖于第 i - 1行的数据，因此前面已经计算过的行其实已经无用了，可以删掉它们优化空间。最佳的优化下，可以只使用一维数组来计算。<br>&emsp;只用一维数组来计算的关键点在于，每一行数据在计算的时候，都依赖前面已经计算的元素，依赖于前面的 j - C[i]位置上的元素，<strong>如果依旧从前到后依次计算，拿到的这个位置的元素的值就是错的。所以这个时候需要从后到前计算</strong>，这样就能保证每次取 j - C[i]位置上的元素，都是上一次计算的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bagProblem</span><span class="params">(<span class="keyword">int</span>[] C, <span class="keyword">int</span>[] W, <span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> dp[V + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = V; j &gt;= C[i]; j--)&#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - C[i] + W[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[V];                                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;另外，在这个代码中，可以抽象出处理一件01背包问题的代码作为一个函数调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zeroOneBag</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> c, <span class="keyword">int</span> V, <span class="keyword">int</span>[] dp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = V; j &gt;= c; j--)</span><br><span class="line">    	dp[j] = Math.max(dp[j], dp[j - c] + w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bagProblem</span><span class="params">(<span class="keyword">int</span>[] C, <span class="keyword">int</span>[] W, <span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> dp[V + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C.length; i++)</span><br><span class="line">    	zeroOneBag(W[i], C[i], V, dp);</span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>&emsp;完全背包问题与01背包问题唯一的区别在于，每一种物品都有无限多个，可以拿0个，1个，任意个。很显然，直觉上看，这种情况下问题的复杂性十分高，可能的情况实在太多。</p>
<h2 id="动态规划公式推导"><a href="#动态规划公式推导" class="headerlink" title="动态规划公式推导"></a>动态规划公式推导</h2><p>&emsp;完全背包问题的递推式如下所示：</p>
<p>&emsp;  dp[i, j] = max( dp[i - 1, j - k<em>C[i] ] + k </em> W[i] )  其中 0 &lt;= k &lt;= V/C[i]       (1)</p>
<p>&emsp;即利用穷举的方式从不拿第 i 件物品到拿第 i 件物品装满背包都试一遍，看哪一种方案价值更大就选择哪一种方案。对于这种思路，就是将完全背包问题转化为01背包问题来求解，也有一些优化手段，比如如果两件物品 i 与 j 满足 C[i]  &lt;= C[j] &amp;&amp; W[i] &gt;= W[j]， 那么可以直接不用考虑 j 物品，因为每个物品可以拿无限多个，所以用价值高费用小的 i 替换 j 是显然不亏的。再比如用二进制编码的思想降低复杂度。</p>
<p>&emsp;但是，通过完全背包问题的递推式推导，却可以得到一个简单易懂的解决方法：</p>
<p>&emsp;完全背包问题递推式可以写成：</p>
<p>&emsp; dp[i, j] = max( dp[i - 1, j], dp[i - 1, j - k<em>C[i]] + k </em> W[i] )  其中 1 &lt;= k &lt;= V/C[i]       (2)</p>
<p>&emsp;由(1)式可得：</p>
<p>&emsp; dp[i, j - C[i]] = max( dp[i - 1, j - C[i] - k<em>C[i]] + k </em> W[i] )  其中 1 &lt;= k + 1 &lt;= V/C[i]   </p>
<p>&emsp; dp[i, j - C[i]] = max( dp[i - 1, j - (k + 1)<em>C[i]] + (k + 1) </em> W[i] - W[i] )  其中 1 &lt;= k + 1 &lt;= V/C[i]</p>
<p>&emsp;令 m = k + 1 则可推导出：</p>
<p>&emsp; dp[i, j - C[i]] = max( dp[i - 1, j - m<em>C[i]] + m </em> W[i] - W[i] )  其中 1 &lt;= m&lt;= V/C[i] </p>
<p>&emsp;故可以得到：</p>
<p>&emsp; dp[i, j - C[i]] + W[i] = max( dp[i - 1, j - m<em>C[i]] + m </em> W[i] )   其中 1 &lt;= m &lt;= V/C[i]       (3)</p>
<p>&emsp;将(3)代入(2)中有：</p>
<p>&emsp; dp[i, j] = max( dp[i - 1, j], dp[i, j - C[i]] + W[i] ) </p>
<p>&emsp;最终的这个公式与01背包的递推式相比较只有一处不同，而且由01背包需要逆序求解容易推导出，完全背包问题只需正序求解就能在一维数组下解决问题：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeBag</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> c, <span class="keyword">int</span> V, <span class="keyword">int</span>[] dp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = c; j &lt;= V; j++)</span><br><span class="line">    	dp[j] = Math.max(dp[j], dp[j - c] + w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bagProblem</span><span class="params">(<span class="keyword">int</span>[] C, <span class="keyword">int</span>[] W, <span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> dp[V + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C.length; i++)</span><br><span class="line">    	completeBag(W[i], C[i], V, dp);</span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h1><p>&emsp;多重背包问题就是每个物品能拿的数量是有限数m，这种情况下，如果一个物品的费用与能拿的次数的积大于背包容量，那么可以转化为完全背包问题求解，否则，要转化为01背包问题求解，可以用二进制编码优化时间复杂度。二进制编码优化是指，可以不用从0遍历到m次，可以转为1，2，4，2^(k-1) 与m - 2^k  + 1，其中k表示使2^k - 1 &lt;  m的最大k值。例如，m = 19，可以转为1， 2， 4， 8， 12，这样从1到19都能用这几个数组合得到，可以优化时间复杂度。<br>&emsp;传入一个数组M表示第i件物品只能拿M[i]次：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiBag</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> c, <span class="keyword">int</span> V, <span class="keyword">int</span>[] dp, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m * c &gt;= V)</span><br><span class="line">        completeBag(w, c, V, dp);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">2</span> * k - <span class="number">1</span> &lt; m)&#123;</span><br><span class="line">            zeroOneBag(w * k, c * k, V, dp);</span><br><span class="line">            k = <span class="number">2</span> * k;</span><br><span class="line">        &#125;</span><br><span class="line">        m = m - k / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        zeroOneBag(w * m, c * m, V, dp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bagProblem</span><span class="params">(<span class="keyword">int</span>[] C, <span class="keyword">int</span>[] W, <span class="keyword">int</span> V, <span class="keyword">int</span>[] M)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> dp[V + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C.length; i++)</span><br><span class="line">    	multiBag(W[i], C[i], V, dp, M[i]);</span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;假设每件物品平均能拿K次，多重背包问题在这种情况下时间复杂度为 $O(NVlgK)$ 。多重背包问题其实存在更好的方法可以达到 $O(NV)$ 的时间复杂度。</p>
<h1 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h1><p>&emsp;混合背包问题即之前三种背包问题的混合，有的物品最多只能拿1次，有的能拿无限次，有的能拿有限次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bagProblem</span><span class="params">(<span class="keyword">int</span>[] C, <span class="keyword">int</span>[] W, <span class="keyword">int</span> V, <span class="keyword">int</span>[] M)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> dp[V + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(M[i] == <span class="number">1</span>)</span><br><span class="line">        	zeroOneBag(w, c, V, dp);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(M[i] == <span class="number">0</span>) <span class="comment">// 表示能拿无限次</span></span><br><span class="line">        	completeBag(w, c, V, dp);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	multiBag(w[i], c[i], V, dp, M[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>背包问题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类加载机制</title>
    <url>/2020/06/25/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="类生命周期"><a href="#类生命周期" class="headerlink" title="类生命周期"></a>类生命周期</h1><p>&emsp;在Java 虚拟机中，类的生命周期包括7个阶段：加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载。</p>
<a id="more"></a>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>&emsp;类的加载过程主要完成3件事：</p>
<ol>
<li>通过类的全限定名获取该类的二进制字节流，这个过程并没有规定从哪里获取，具有很大的操作空间。</li>
<li>将字节流的静态存储结构转为方法区或元空间的动态存储结构。</li>
<li>生成这个类的Class对象，作为该类各种数据的访问入口。</li>
</ol>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>&emsp;确保字节流中包含的信息符合虚拟机的要求，不会危害到虚拟机。主要包括文件格式验证，验证是否以魔数开头，版本号是否被虚拟机接收；元数据验证，验证类的方法，字段是否与父类矛盾；字节码验证，通过数据流与控制流分析，确定程序语义，不会危害虚拟机。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>&emsp;为类变量分配内存并设置默认零值，类变量是指 static 修饰的变量，如果类变量是常量，会初始化为定义的值。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>&emsp;将能替换的符号引用替换为直接引用，为了支持多态，有的符号引用在这个阶段不能被替换掉。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>&emsp;在这个阶段虚拟机会收集赋值语句与静态语句合并为一个clinit方法执行，为类的静态赋予正确的初始值。静态语句的顺序由源文件的顺序决定。</p>
<p>&emsp;执行一个类的clinit方法前，会先执行父类的clinit方法(故虚拟机中第一个执行的类是Object)，但是接口不需要，接口的实现类也不需要。只有接口中定义的变量使用时，才会执行接口的clinit方法。</p>
<p>&emsp;虚拟机会保证一个类的clinit方法在多线程环境下被正确的加锁和同步。</p>
<h1 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h1><h2 id="主动引用"><a href="#主动引用" class="headerlink" title="主动引用"></a>主动引用</h2><p>虚拟机规定在以下五种情况下，必须立即进行初始化：</p>
<ul>
<li>使用 new 关键字实例化对象时，访问类的静态字段，调用类的静态方法时。</li>
<li>使用java.lang.reflect 包的方法对类进行反射调用时。</li>
<li>初始化一个类时，它的父类还没有被初始化。</li>
<li>虚拟机启动时，包含 main() 方法的主类会先被初始化。</li>
<li>java.lang.invoke.MethodHandle 解析结果涉及静态字段与静态方法时，对应的类应该先被初始化。</li>
</ul>
<h2 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h2><p>处理主动引用外的所有引用方式都不会立即触发初始化，称为被动以用，比如：</p>
<ul>
<li>用过字类引用父类的静态字段，子类不会立即初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sytem.out.println(SubClass.value); <span class="comment">// value是父类的静态字段</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过数组定义引用类，不会触发类的初始化，会触发数组类的初始化，数组类是虚拟机自动生成的，包含了数组的属性和方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OneClass[] os = <span class="keyword">new</span> OneClass[<span class="number">100</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>引用一个类的常量也不会导致类的初始化，常量在编译阶段就存入常量池中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(OneClass.MAX_VALUE);</span><br></pre></td></tr></table></figure>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>&emsp;类加载器可以加载类，每一个类加载器都有独立的命名空间，对于任意一个类，它的<strong>类加载器和它本身确定唯一性</strong>。</p>
<h2 id="默认类加载器"><a href="#默认类加载器" class="headerlink" title="默认类加载器"></a>默认类加载器</h2><p>&emsp;启动类加载器 (Bootstrap ClassLoader)负责将存放在 JRE_HOME 下的lib目录中的指定类库加载，用户无法直接引用这个加载器，如果用户需要把加载请求委派给启动类加载器，用null代替即可。</p>
<p>&emsp;扩展类加载器负责加载指定扩展目录下的类库。</p>
<p>&emsp;应用程序类加载器，也叫系统类加载器，根据程序的类路径加载Java类，是程序默认的类加载器。用户自定义的加载器默认父加载器是应用程序类加载器。</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>&emsp;双亲委派模型要求除了顶层的启动类加载器外，所有加载器都有父类加载器，在收到类加载请求时，优先将请求委派给父加载器，父加载器无法处理时，子加载器才会自己加载类。这样做的好处是Java类随着它的类加载器具备一种天然的优先级层次。</p>
<h2 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h2><p>&emsp;线程上下文类加载器能打破双亲委派模型的桎梏，在一些场景十分有用，比如web服务器。通过Thread.currentThread.setContextClassLoader() 与 Thread.currentThread.getContextClassLoader() 使用线程上下文类加载器。</p>
]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>虚拟机</tag>
        <tag>类加载</tag>
      </tags>
  </entry>
  <entry>
    <title>Java序列化</title>
    <url>/2020/06/26/Java%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a>Serializable 接口</h1><p>&emsp;序列化是指将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象 。</p>
<a id="more"></a>
<p>&emsp;在 Java 中，想要将对象序列化，需要实现 Serializable 接口启用类的可序列化性，未实现此接口的类不支持序列化与反序列化操作，如果对象某个字段不需要序列化，可以用 transient 修饰该字段。 </p>
<h2 id="transient-关键字"><a href="#transient-关键字" class="headerlink" title="transient 关键字"></a>transient 关键字</h2><p>&emsp;在未实现 Serializable 接口的情况下对类进行序列化，会 java.io.NotSerializableException 异常，类在实现了 Serializable 接口后，就能启用默认的序列化机制，如果有不想被序列化的字段，可以用 transient 关键字修饰它。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">369L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// ...... 省略了其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">    ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"C:\\Users\\adam\\Desktop\\user"</span>));</span><br><span class="line">    User u = <span class="keyword">new</span> User(<span class="string">"a"</span>, <span class="number">1</span>);</span><br><span class="line">    out.writeObject(u);</span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"C:\\Users\\adam\\Desktop\\user"</span>));</span><br><span class="line">    User u2 = (User) in.readObject();</span><br><span class="line">    System.out.println(u2);</span><br><span class="line">    out.close();</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;代码运行结果：<code>User{name=&#39;null&#39;, age=1}</code>，可以看到，name 属性因为被标识为 transient 所以没有被序列化。</p>
<h2 id="writeObject-与-readObject"><a href="#writeObject-与-readObject" class="headerlink" title="writeObject 与 readObject"></a>writeObject 与 readObject</h2><p>&emsp;对于被 transient 标识的属性，在某些情况下如果需要序列化(例如 ArrayList )，则可以通过定义 writeObject(ObjectOutputStream s) 与 readObject(ObjectInputStream s) 自定义类的序列化，这两个方法被定义为 private 方法，但是通过单步调试可以发现，在序列化或者反序列化时，会直接运行到这两个方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">369L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        s.defaultReadObject() <span class="comment">// 自动反序列化对象中没有被transient修饰的字段</span></span><br><span class="line">        <span class="keyword">this</span>.name = (String) s.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        s.defaultWriteObject() <span class="comment">// 自动序列化对象中没有被transient修饰的字段</span></span><br><span class="line">        s.writeObject(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...... 省略了其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;将User类修改如上，再度运行 main 方法结果：<code>User{name=&#39;a&#39;, age=1}</code>，可以发现，被 transient 修饰的name字段也被序列化与反序列化了。在重写writeObject和readObject这两个方法时，一定要注意这两个方法的<strong>方法签名</strong>，另外<strong>写入顺序和读取顺序必须保持一致</strong>，否则会导致反序列化失败。</p>
<h2 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h2><p>&emsp;序列化运行时与每个可序列化类关联一个版本号，称为serialVersionUID，该版本号在反序列化期间用于验证序列化对象的发送方和接收方是否为该对象加载了与序列化兼容的类。如果接收方为具有不同于相应发送方的类的serialVersionUID的对象加载了一个类，那么反序列化将导致InvalidClassException。一个可序列化的类可以通过声明一个名为“serialVersionUID”的字段显式地声明它自己的serialVersionUID，<strong>该字段必须是静态的、final的和long类型的</strong>。</p>
<p>&emsp;如果对上面的 User 类先执行序列化代码，修改它的 serialVersionUID 后再执行反序列化代码，反序列化会失败，并抛出异常：<code>Exception in thread &quot;main&quot; java.io.InvalidClassException: serializedemo.User; local class incompatible: stream classdesc serialVersionUID = 369, local class serialVersionUID = 370</code>。</p>
<p>&emsp;另外，如果类中有包含有非基础数据类型的字段，该字段的类也应该实现 Serializable 接口，否则不能序列化。</p>
<h2 id="writeReplace-与-readResolve"><a href="#writeReplace-与-readResolve" class="headerlink" title="writeReplace() 与 readResolve()"></a>writeReplace() 与 readResolve()</h2><p>&emsp;定义 writeReplace() 方法后，当将对象序列化时，会将该方法返回的 Object 替代序列化对象。</p>
<p>&emsp;定义 readResolve() 方法后，当将对象反序列化时，会将该方法返回的 Object 替代反序列化对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">369L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"resolve"</span>, <span class="number">666</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...... 省略了其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;比如将User类修改如上，再度运行 main 方法结果：<code>User{name=&#39;resolve&#39;, age=666}</code>，可以发现，结果已经被替换掉了，这个方法可以用在一些单例模式里保证对象单例。</p>
<h2 id="readObjectNoData"><a href="#readObjectNoData" class="headerlink" title="readObjectNoData"></a>readObjectNoData</h2><p>&emsp;如果序列化流没有将给定的类列为被反序列化的对象的超类，readObjectNoData方法负责初始化其特定类的对象的状态。当接收方使用反序列化实例的类的版本与发送方不同，并且接收方的版本扩展了未被发送方版本扩展的类时，可能会发生这种情况。</p>
<p>&emsp;对上面的User类先执行序列化，然后让User类继承一个父类A，并且在 A 中实现 readObjectNoData 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObjectNoData</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">370L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// ......省略其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;之后再执行反序列化，结果：<code>User{name=&#39;a&#39;, age=1, id=100}</code>，可以看到，对于序列化时没有继承的父类，在反序列化时自动调用了它的 readObjectNoData 方法，可以设置父类属性的值。</p>
<h1 id="Externalizable-接口"><a href="#Externalizable-接口" class="headerlink" title="Externalizable 接口"></a>Externalizable 接口</h1><p>&emsp;该接口是 Serializable 接口的子接口，声明了两个方法 <code>void writeExternal(ObjectOutput out) throws IOException;</code> 与 <code>void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;</code>，通过实现这两个方法可以自定义类的序列化与反序列化。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
</search>
