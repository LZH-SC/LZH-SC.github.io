<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java Object类</title>
    <url>/2020/06/25/Java-Object%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><h1 id="getClass-方法"><a href="#getClass-方法" class="headerlink" title="getClass 方法"></a>getClass 方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure>
<p>&emsp;这个方法是 Native 方法，返回的是一个对象的实际类型，返回的type是Class&lt;? extends |X|&gt;，例如，如下代码输出的结果是 Integer。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Number n = <span class="number">0</span>;</span><br><span class="line">System.out.println(n.getClass());</span><br></pre></td></tr></table></figure>
<h1 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;在Object类的文档中，对 hashCode() 方法做了详细的要求：</p>
<ul>
<li>如果对象的信息没有被修改，对同一个对象的多次调用应该返回同一个结果。</li>
<li>如果两个对象 equals() 方法调用结果为 true，那么这两个对象应该返回相同的 hashCode ，故覆盖 equals 方法必须覆盖 hashCode 方法。</li>
<li>并不强制要求不相等的两个对象的 hashCode 必须不相同，但是不同的 hashCode 对 hash 表的使用更友好。</li>
</ul>
<h1 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals 方法"></a>equals 方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;在 Object 类的文档中，对 equals 方法做了详细的要求:</p>
<ul>
<li>该方法可以返回<strong>非空对象引用</strong>的等价关系。</li>
<li>该方法应该具备<strong>自反性</strong>，即 x.equals(x) 应该返回 true 。</li>
<li>该方法应该具备<strong>对称性</strong>，即 x.equals(y) 返回 true 时，y.equals(x) 也应该返回 true 。</li>
<li>该方法应该具备<strong>传递性</strong>，即 x.equals(y) 返回 true ，y.equals(z) 也返回 true 时， x.equals(z) 也应该返回 true 。</li>
<li>该方法应该具备<strong>一致性</strong>，即在对象未被修改的情况下，多次调用x.equals(y) 返回值也一样。</li>
<li>对于任意非空引用 x ，x.equals(null) 的结果应该是 false 。</li>
</ul>
<h1 id="clone-方法"><a href="#clone-方法" class="headerlink" title="clone 方法"></a>clone 方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp; clone方法返回一个对象的复制，一般要求满足 x.clone() != x 成立，并且 x.clone().getClass() == x.getClass() 成立。这个方法返回的对象应该与原对象独立，使用原对象的字段对返回的对象进行初始化。<br>&emsp;类在实现这个方法时，必须先实现 Cloneable 接口。如果没有实现接口 Cloneable ，则抛出 CloneNotSupportedException 。注意，所有数组都被认为实现了Cloneable接口，数组类型T[]的克隆方法的返回类型是T[]，其中T是任何引用或基本类型。</p>
<h1 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString 方法"></a>toString 方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp; 这个方法返回对象的字符串表示形式。</p>
<h1 id="线程相关方法"><a href="#线程相关方法" class="headerlink" title="线程相关方法"></a>线程相关方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会唤醒等待在当前对象监视器的线程，被唤起的线程重新加入监视器锁的竞争中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有获得当前对象监视器锁的线程才能调用，线程放弃当前监视器锁，转入等待队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    wait(<span class="number">0L</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeoutMillis, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure>
<p>&emsp;线程在执行 synchronized 标识的方法，代码块，静态方法时会获得当前对象监视器的锁。</p>
<h1 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize 方法"></a>finalize 方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span>(since=<span class="string">"9"</span>)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;这个方法并不被推荐使用，因为它的执行时间，执行顺序，是否执行完成都不能确定。在需要释放资源的场合，推荐使用 AutoCloseable 接口完成。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Object</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类加载机制</title>
    <url>/2020/06/25/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="类生命周期"><a href="#类生命周期" class="headerlink" title="类生命周期"></a>类生命周期</h1><p>&emsp;在Java 虚拟机中，类的生命周期包括7个阶段：加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载。</p>
<a id="more"></a>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>&emsp;类的加载过程主要完成3件事：</p>
<ol>
<li>通过类的全限定名获取该类的二进制字节流，这个过程并没有规定从哪里获取，具有很大的操作空间。</li>
<li>将字节流的静态存储结构转为方法区或元空间的动态存储结构。</li>
<li>生成这个类的Class对象，作为该类各种数据的访问入口。</li>
</ol>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>&emsp;确保字节流中包含的信息符合虚拟机的要求，不会危害到虚拟机。主要包括文件格式验证，验证是否以魔数开头，版本号是否被虚拟机接收；元数据验证，验证类的方法，字段是否与父类矛盾；字节码验证，通过数据流与控制流分析，确定程序语义，不会危害虚拟机。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>&emsp;为类变量分配内存并设置默认零值，类变量是指 static 修饰的变量，如果类变量是常量，会初始化为定义的值。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>&emsp;将能替换的符号引用替换为直接引用，为了支持多态，有的符号引用在这个阶段不能被替换掉。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>&emsp;在这个阶段虚拟机会收集赋值语句与静态语句合并为一个clinit方法执行，为类的静态赋予正确的初始值。静态语句的顺序由源文件的顺序决定。</p>
<p>&emsp;执行一个类的clinit方法前，会先执行父类的clinit方法(故虚拟机中第一个执行的类是Object)，但是接口不需要，接口的实现类也不需要。只有接口中定义的变量使用时，才会执行接口的clinit方法。</p>
<p>&emsp;虚拟机会保证一个类的clinit方法在多线程环境下被正确的加锁和同步。</p>
<h1 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h1><h2 id="主动引用"><a href="#主动引用" class="headerlink" title="主动引用"></a>主动引用</h2><p>虚拟机规定在以下五种情况下，必须立即进行初始化：</p>
<ul>
<li>使用 new 关键字实例化对象时，访问类的静态字段，调用类的静态方法时。</li>
<li>使用java.lang.reflect 包的方法对类进行反射调用时。</li>
<li>初始化一个类时，它的父类还没有被初始化。</li>
<li>虚拟机启动时，包含 main() 方法的主类会先被初始化。</li>
<li>java.lang.invoke.MethodHandle 解析结果涉及静态字段与静态方法时，对应的类应该先被初始化。</li>
</ul>
<h2 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h2><p>处理主动引用外的所有引用方式都不会立即触发初始化，称为被动以用，比如：</p>
<ul>
<li>用过字类引用父类的静态字段，子类不会立即初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sytem.out.println(SubClass.value); <span class="comment">// value是父类的静态字段</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过数组定义引用类，不会触发类的初始化，会触发数组类的初始化，数组类是虚拟机自动生成的，包含了数组的属性和方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OneClass[] os = <span class="keyword">new</span> OneClass[<span class="number">100</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>引用一个类的常量也不会导致类的初始化，常量在编译阶段就存入常量池中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(OneClass.MAX_VALUE);</span><br></pre></td></tr></table></figure>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>&emsp;类加载器可以加载类，每一个类加载器都有独立的命名空间，对于任意一个类，它的<strong>类加载器和它本身确定唯一性</strong>。</p>
<h2 id="默认类加载器"><a href="#默认类加载器" class="headerlink" title="默认类加载器"></a>默认类加载器</h2><p>&emsp;启动类加载器 (Bootstrap ClassLoader)负责将存放在 JRE_HOME 下的lib目录中的指定类库加载，用户无法直接引用这个加载器，如果用户需要把加载请求委派给启动类加载器，用null代替即可。</p>
<p>&emsp;扩展类加载器负责加载指定扩展目录下的类库。</p>
<p>&emsp;应用程序类加载器，也叫系统类加载器，根据程序的类路径加载Java类，是程序默认的类加载器。用户自定义的加载器默认父加载器是应用程序类加载器。</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>&emsp;双亲委派模型要求除了顶层的启动类加载器外，所有加载器都有父类加载器，在收到类加载请求时，优先将请求委派给父加载器，父加载器无法处理时，子加载器才会自己加载类。这样做的好处是Java类随着它的类加载器具备一种天然的优先级层次。</p>
<h2 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h2><p>&emsp;线程上下文类加载器能打破双亲委派模型的桎梏，在一些场景十分有用，比如web服务器。通过Thread.currentThread.setContextClassLoader() 与 Thread.currentThread.getContextClassLoader() 使用线程上下文类加载器。</p>
]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>虚拟机</tag>
        <tag>类加载</tag>
      </tags>
  </entry>
  <entry>
    <title>Java序列化</title>
    <url>/2020/06/26/Java%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a>Serializable 接口</h1><p>&emsp;序列化是指将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象 。</p>
<a id="more"></a>
<p>&emsp;在 Java 中，想要将对象序列化，需要实现 Serializable 接口启用类的可序列化性，未实现此接口的类不支持序列化与反序列化操作，如果对象某个字段不需要序列化，可以用 transient 修饰该字段。 </p>
<h2 id="transient-关键字"><a href="#transient-关键字" class="headerlink" title="transient 关键字"></a>transient 关键字</h2><p>&emsp;在未实现 Serializable 接口的情况下对类进行序列化，会 java.io.NotSerializableException 异常，类在实现了 Serializable 接口后，就能启用默认的序列化机制，如果有不想被序列化的字段，可以用 transient 关键字修饰它。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">369L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// ...... 省略了其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">    ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"C:\\Users\\adam\\Desktop\\user"</span>));</span><br><span class="line">    User u = <span class="keyword">new</span> User(<span class="string">"a"</span>, <span class="number">1</span>);</span><br><span class="line">    out.writeObject(u);</span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"C:\\Users\\adam\\Desktop\\user"</span>));</span><br><span class="line">    User u2 = (User) in.readObject();</span><br><span class="line">    System.out.println(u2);</span><br><span class="line">    out.close();</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;代码运行结果：<code>User{name=&#39;null&#39;, age=1}</code>，可以看到，name 属性因为被标识为 transient 所以没有被序列化。</p>
<h2 id="writeObject-与-readObject"><a href="#writeObject-与-readObject" class="headerlink" title="writeObject 与 readObject"></a>writeObject 与 readObject</h2><p>&emsp;对于被 transient 标识的属性，在某些情况下如果需要序列化(例如 ArrayList )，则可以通过定义 writeObject(ObjectOutputStream s) 与 readObject(ObjectInputStream s) 自定义类的序列化，这两个方法被定义为 private 方法，但是通过单步调试可以发现，在序列化或者反序列化时，会直接运行到这两个方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">369L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        s.defaultReadObject() <span class="comment">// 自动反序列化对象中没有被transient修饰的字段</span></span><br><span class="line">        <span class="keyword">this</span>.name = (String) s.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        s.defaultWriteObject() <span class="comment">// 自动序列化对象中没有被transient修饰的字段</span></span><br><span class="line">        s.writeObject(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...... 省略了其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;将User类修改如上，再度运行 main 方法结果：<code>User{name=&#39;a&#39;, age=1}</code>，可以发现，被 transient 修饰的name字段也被序列化与反序列化了。在重写writeObject和readObject这两个方法时，一定要注意这两个方法的<strong>方法签名</strong>，另外<strong>写入顺序和读取顺序必须保持一致</strong>，否则会导致反序列化失败。</p>
<h2 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h2><p>&emsp;序列化运行时与每个可序列化类关联一个版本号，称为serialVersionUID，该版本号在反序列化期间用于验证序列化对象的发送方和接收方是否为该对象加载了与序列化兼容的类。如果接收方为具有不同于相应发送方的类的serialVersionUID的对象加载了一个类，那么反序列化将导致InvalidClassException。一个可序列化的类可以通过声明一个名为“serialVersionUID”的字段显式地声明它自己的serialVersionUID，<strong>该字段必须是静态的、final的和long类型的</strong>。</p>
<p>&emsp;如果对上面的 User 类先执行序列化代码，修改它的 serialVersionUID 后再执行反序列化代码，反序列化会失败，并抛出异常：<code>Exception in thread &quot;main&quot; java.io.InvalidClassException: serializedemo.User; local class incompatible: stream classdesc serialVersionUID = 369, local class serialVersionUID = 370</code>。</p>
<p>&emsp;另外，如果类中有包含有非基础数据类型的字段，该字段的类也应该实现 Serializable 接口，否则不能序列化。</p>
<h2 id="writeReplace-与-readResolve"><a href="#writeReplace-与-readResolve" class="headerlink" title="writeReplace() 与 readResolve()"></a>writeReplace() 与 readResolve()</h2><p>&emsp;定义 writeReplace() 方法后，当将对象序列化时，会将该方法返回的 Object 替代序列化对象。</p>
<p>&emsp;定义 readResolve() 方法后，当将对象反序列化时，会将该方法返回的 Object 替代反序列化对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">369L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"resolve"</span>, <span class="number">666</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...... 省略了其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;比如将User类修改如上，再度运行 main 方法结果：<code>User{name=&#39;resolve&#39;, age=666}</code>，可以发现，结果已经被替换掉了，这个方法可以用在一些单例模式里保证对象单例。</p>
<h2 id="readObjectNoData"><a href="#readObjectNoData" class="headerlink" title="readObjectNoData"></a>readObjectNoData</h2><p>&emsp;如果序列化流没有将给定的类列为被反序列化的对象的超类，readObjectNoData方法负责初始化其特定类的对象的状态。当接收方使用反序列化实例的类的版本与发送方不同，并且接收方的版本扩展了未被发送方版本扩展的类时，可能会发生这种情况。</p>
<p>&emsp;对上面的User类先执行序列化，然后让User类继承一个父类A，并且在 A 中实现 readObjectNoData 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObjectNoData</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">370L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// ......省略其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;之后再执行反序列化，结果：<code>User{name=&#39;a&#39;, age=1, id=100}</code>，可以看到，对于序列化时没有继承的父类，在反序列化时自动调用了它的 readObjectNoData 方法，可以设置父类属性的值。</p>
<h1 id="Externalizable-接口"><a href="#Externalizable-接口" class="headerlink" title="Externalizable 接口"></a>Externalizable 接口</h1><p>&emsp;该接口是 Serializable 接口的子接口，声明了两个方法 <code>void writeExternal(ObjectOutput out) throws IOException;</code> 与 <code>void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;</code>，通过实现这两个方法可以自定义类的序列化与反序列化。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis基础使用</title>
    <url>/2020/07/04/mybatis%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Mybatis-简介"><a href="#Mybatis-简介" class="headerlink" title="Mybatis 简介"></a>Mybatis 简介</h1><p>MyBatis 官网：<a href="https://mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh/index.html</a></p>
<p>MyBatis 是一个持久层框架，它对 jdbc 的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建 connection、创建 statement、手动设置参数、结果集检索等 jdbc 繁杂的过程代码。<br><a id="more"></a></p>
<p>Mybatis 通过 xml 或注解的方式将要执行的各种 statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过 java 对象和 statement 中的 sql 进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射成 java 对象并返回。</p>
<h1 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h1><p>首先在数据库中建立一个 user 表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table user(</span><br><span class="line">    id int auto_increment primary key,</span><br><span class="line">    username varchar(255) null,</span><br><span class="line">    address  varchar(255) null</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>新建 maven 项目，引入相关依赖：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.4.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;8.0.17&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>在 resources 目录下新建 mybatis-config.xml 文件，文件内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span> <span class="comment">&lt;!-- 指定环境 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span>  <span class="comment">&lt;!-- 配置环境 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///mybatis?serverTimezone=Asia/Shanghai"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"your_username"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"your_password"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span> <span class="comment">&lt;!-- 指定mapper路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"mapper/UserMapper.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>之后，建立一个与数据库表对应的 Java 实体类 User ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">// ...... 省略了其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 resources 目录下新建 mapper 文件夹，在 mapper 文件夹下新建一个 UserMapper.xml如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace必须是唯一标识，避免不同 mapper 的方法冲突 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"top.liuzhenhui.mapper.UserMapper"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- resultType写全限定名，id表示语句名字在同一个namesapce下唯一，#&#123;id&#125; 接收传入参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserById"</span> <span class="attr">resultType</span>=<span class="string">"top.liuzhenhui.model.User"</span>&gt;</span></span><br><span class="line">        select * from user where id = #&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后，编写主方法运行 UserMapper.xml 下定义的 sql 语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 建立一个SqlSessionFactory用户获取SqlSession</span></span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder()</span><br><span class="line">                .build(Resources.getResourceAsStream(<span class="string">"mybatis-config.xml"</span>));</span><br><span class="line">        <span class="keyword">try</span>(SqlSession sqlSession = sqlSessionFactory.openSession())&#123;</span><br><span class="line">            <span class="keyword">if</span>(sqlSession.getConnection() != <span class="keyword">null</span>)&#123; <span class="comment">// 不为空说明能获取到与数据库的连接</span></span><br><span class="line">                System.out.println(<span class="string">"连接成功"</span>);</span><br><span class="line">                <span class="comment">// 通过 namespace 与其中语句定义的 id 找到编写的 sql 语句</span></span><br><span class="line">                User u = sqlSession.selectOne(<span class="string">"top.liuzhenhui.mapper.UserMapper.getUserById"</span>, <span class="number">1</span>);</span><br><span class="line">                System.out.println(u);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                System.out.println(<span class="string">"连接失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目录结构如下图</p>
<p><img src="https://raw.githubusercontent.com/LZH-SC/blogImages/master/img/20200704193232.png" alt=""></p>
<p>以上便是最基础的 mybatis 使用，需要通过配置文件创建一个 SqlSessionFactory 用于获取 SqlSession，SqlSession 中对数据库操作的进行了封装。</p>
<h1 id="使用-mapper-代理"><a href="#使用-mapper-代理" class="headerlink" title="使用 mapper 代理"></a>使用 mapper 代理</h1><p>在 mybatis 中，还可以通过定义接口进一步简化 dao 层的开发，也是常用的方法，新建一个 mapper 包，在其中新建一个 UserMapper 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法名必须与 UserMapper.xml 中的语句 id 一致</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口的全限定名必须与 UserMapper.xml 中的 namespace 一致。然后，修改 mybatis-config.xml 中的配置，将新建的 Mapper 接口配置上：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span> <span class="comment">&lt;!-- 指定mapper路径 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;mapper resource="mapper/UserMapper.xml"/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定mappe接口的包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"top.liuzhenhui.mapper"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于 mybatis 要求 mapper.xml 与 mapper 接口必须放在同一个包下，所以需要在 resources 目录下新建与 mapper 接口包名一致的文件夹，将 UserMapper.xml 放在该文件夹下。</p>
<p><img src="https://raw.githubusercontent.com/LZH-SC/blogImages/master/img/20200704223131.png" alt=""></p>
<p>之后，修改主方法如下即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 建立一个SqlSessionFactory用户获取SqlSession</span></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder()</span><br><span class="line">            .build(Resources.getResourceAsStream(<span class="string">"mybatis-config.xml"</span>));</span><br><span class="line">    <span class="keyword">try</span>(SqlSession sqlSession = sqlSessionFactory.openSession())&#123;</span><br><span class="line">        <span class="keyword">if</span>(sqlSession.getConnection() != <span class="keyword">null</span>)&#123; <span class="comment">// 不为空说明能获取到与数据库的连接</span></span><br><span class="line">            System.out.println(<span class="string">"连接成功"</span>);</span><br><span class="line">            <span class="comment">// 通过动态代理返回一个对象</span></span><br><span class="line">            UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="comment">// 直接调用方法即可</span></span><br><span class="line">            User u = mapper.getUserById(<span class="number">8</span>);</span><br><span class="line">            System.out.println(u);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"连接失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 SqlSession 的 getMapper 方法，传入自定义 Mapper 接口的类，mybatis 会通过动态代理自动创建一个对象，对象中的方法代理了 sql 语句的执行。</p>
<h1 id="配置-typeAliase"><a href="#配置-typeAliase" class="headerlink" title="配置 typeAliase"></a>配置 typeAliase</h1><p>之前的代码在写返回类型的时候，必须写类的全限定名 <code>top.liuzhenhui.model.User</code>，这种做法显然十分麻烦，mybatis 支持自定义别名，在 mybatis-config.xml 文件中添加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"top.liuzhenhui.model"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 后面配置省略.... --&gt;</span></span><br></pre></td></tr></table></figure>
<p>它会自动利用包扫描批量给对象定义别名，批量定义默认的类的别名，是类名首字母小写。之后就可以在 UserMapper.xml 中使用别名： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"top.liuzhenhui.mapper.UserMapper"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- resultType写别名即可 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserById"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        select * from user where id = #&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>mybatis 已经对基本数据类型以及他们的包装类和 String 类定义了别名，直接使用即可。</p>
<h1 id="定义-TypeHandler"><a href="#定义-TypeHandler" class="headerlink" title="定义 TypeHandler"></a>定义 TypeHandler</h1><p>在 mybatis 中，内置了一些 TypeHandler，能够将 jdbc 数据映射为 Java 类型，例如 StringTypeHandler，EnumTypeHandler等，但是在某些情况下，还是需要自定义 TypeHandler 处理特殊类型。</p>
<p>例如，给之前的 user 表添加一个字段 interests 表示爱好，一个 user 可能不止一个爱好，因此用列表表示，修改 User 类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; interests;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其它代码......</span></span><br></pre></td></tr></table></figure>
<p>然后，自定义一个 TypeHandler，自定义的 TypeHandler 需要实现 TypeHandler 接口，可以使用注解 @MappedJdbcType 标注 Jdbc 类型，@MappedTypes 标注 Java 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MappedJdbcTypes</span>(JdbcType.VARCHAR)</span><br><span class="line"><span class="meta">@MappedTypes</span>(List<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">List2VarcharTypeHandler</span> <span class="keyword">implements</span> <span class="title">TypeHandler</span>&lt;<span class="title">List</span>&lt;<span class="title">String</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, List&lt;String&gt; parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String s : parameter)&#123;</span><br><span class="line">            sb.append(s);</span><br><span class="line">            sb.append(<span class="string">','</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ps.setString(i, sb.toString());  <span class="comment">// 设置到对应的参数上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        String[] strings = rs.getString(columnName).split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(strings);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        String[] strings = rs.getString(columnIndex).split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(strings);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        String[] strings = cs.getString(columnIndex).split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(strings);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义 TypeHandler 后还需要在 mybatis-config.xml 中做全局配置，或者在 mapper.xml 里做局部配置亦可，这里配置全局配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"top.liuzhenhui.model"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"top.liuzhenhui.typehandler"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 后面配置省略.... --&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置完成后，就可以正常使用了。</p>
]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Java垃圾收集机制</title>
    <url>/2020/06/25/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="判断对象是否可回收"><a href="#判断对象是否可回收" class="headerlink" title="判断对象是否可回收"></a>判断对象是否可回收</h1><p>&emsp;判断一个对象是否可以被回收，即还有没有其它指针指向它，如果没有了，说明这个对象已经不可以再被使用到了，就可以回收掉它的内存空间。主要有两种方式可以判断：</p>
<a id="more"></a>
<p>&emsp;- 引用计数法：每当有一个引用引用到对象，就给对象的引用计数加一，这样当某个对象的引用计数为0时，就说明该对象已经可以被回收了，但是该方法有循环引用的问题。</p>
<p>&emsp;- 可达性分析算法：以GC Roots对象为起点开始搜索引用链，凡是能搜索到的对象都是存活的对象，未能搜索到的对象都是可回收的对象。</p>
<p>&emsp;Java虚拟机中多使用可达性分析算法，其中GC Roots对象有4类：</p>
<ul>
<li>方法区中的常量引用的对象。</li>
<li>方法区中静态变量引用的对象。</li>
<li>栈中局部变量引用的对象。</li>
<li>本地方法栈中引用的对象。</li>
</ul>
<p>&emsp;Java中对象有四种引用：强引用，一定不会被垃圾收集；软引用，空间不足时会被收集；弱引用，下一次垃圾收集就被收集；虚引用，不会对对象的生命周期产生任何影响。</p>
<h2 id="对类的回收"><a href="#对类的回收" class="headerlink" title="对类的回收"></a>对类的回收</h2><p>&emsp;虚拟机对类的回收十分严苛，需要满足三个条件，并且满足了也不一定会回收：</p>
<ol>
<li>类的所有实例已经被回收。</li>
<li>加载该类的ClassLoader已经被回收。</li>
<li>该类对应的Class对象没有被引用，不能通过反射获得该类。</li>
</ol>
<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><ol>
<li>标记-清除算法：虚拟机标记可达对象后，将不可达的对象统一清除。这种算法效率比较低，而且容易造成空间碎片。</li>
<li>标记-整理算法：虚拟机将可达的对象全部移动到内存的一侧，将边界以外的空间一起释放。好处是无内存碎片，缺点是效率低。</li>
<li>复制算法：将内存分两块，只使用一块，在垃圾收集时将存活对象移动到另一块即可。好处是效率高，但是内存只使用到一半。虚拟机内实现一般分为一块Eden与两块Survivor，比例8：1：1，每次使用Eden与一块Survivor，留一块Survivor做垃圾收集时的复制空间，这样可以提高空间利用率。</li>
</ol>
<h1 id="Stop-the-world"><a href="#Stop-the-world" class="headerlink" title="Stop the world"></a>Stop the world</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;由于不能出现可达性分析过程中对象引用关系还在不断变化的情况，因此<strong>GC时必须停顿所有的Java执行线程</strong>，会影响系统响应以及用户体验，在HotSpot实现中，使用一组称为OopMap的数据结构来存储哪些地方存放着对象引用，这样可以减少GC时扫描全局引用的时间。<br>&nbsp;&nbsp;&nbsp;&nbsp;HotSpot并没有为每条指令都生成OopMap，只在“特定的位置”记录，这些位置称为安全点，因此程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能。但还有一个问题需要考虑，如何在GC时让所有线程都跑到最近的安全点上停顿，有两种方式：</p>
<ul>
<li>抢先示中中断，不需要线程的执行代码配合，在GC时，中断所有线程，如果发现有线程中断的地方不在安全点上，就让它跑到安全点上，现在几乎没有虚拟机采用这种方法。</li>
<li><strong>主动式中断，当GC需要中断线程时，设置一个标志，各个线程主动轮询这个标志，发现为真时自己中断挂起。</strong>    </li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;当线程处于挂起状态时，无法响应中断请求，这种时候需要安全区域来解决。<strong>安全区域是指在一段代码片段中，引用关系不会发生变化。在这个区域中的任何地方开始GC都是安全的，安全区域可以看作是扩展的安全区域。</strong></p>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>&emsp;很多垃圾收集器采用分代收集的方式，将堆中的内存分为新生代和老年代，新生代的对象通常存活时间较短，回收比较频繁，采用效率高的复制算法，老年代的对象存活时间很长，回收不频繁，采用标记-清除或标记-整理算法。</p>
<ul>
<li>Serial 与 Serial Old 收集器：单线程收集器，垃圾收集时需要暂停其它工作线程，直到收集结束。主要用在Client模式下的虚拟机。</li>
<li>ParNew 收集器： Serial收集器的多线程版本，主要用在Server模式的虚拟机上，能与CMS收集器配合工作。</li>
<li>Parallel Scavenge 与 Parallel Old 收集器，多线程吞吐量优先收集器。</li>
</ul>
<h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>&emsp;目标是获得最短的回收停顿时间，基于标记清除算法实现，在Server端使用比较多。运作过程包括<strong>初始标记，并发标记，重新标记与并发清除</strong>。初始标记只标记GC Roots能直接关联到的对象，速度很快；并发标记就是进行可达性分析的过程；重新标记修正并发标记期间引用关系发生变化的部分；并发清除则是清除不可达对象，回收空间。</p>
<p>&emsp;整个过程中，并发标记与并发清楚可以和用户线程一起工作，因此停顿时间只有初始标记和重新标记的过程，但时间并不长。</p>
<p>&emsp;CMS收集器的缺点是有空间碎片产生，无法处理浮动垃圾以及对CPU资源十分敏感。</p>
<h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>&emsp;G1收集器主要应用在Server端。它将对划分为多个大小相等的独立区域，新生代和老年代不再物理隔离。它会跟踪每个区域垃圾堆积的大小，维护一个优先列表，回收时回收价值最大的区域。运作工程包括初始标记，并发标记，最终标记，筛选回收。由于可以控制回收多少块区域，因此可以得到一个<strong>可预测的停顿时间</strong>。</p>
<h1 id="对象内存分配"><a href="#对象内存分配" class="headerlink" title="对象内存分配"></a>对象内存分配</h1><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><ul>
<li>对象优先在新生代的Eden分配</li>
<li>大对象直接进入老年代</li>
<li>长期存活的对象进入老年代，可以设定年龄阈值或者动态年龄判断</li>
</ul>
<h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><p>&emsp;在堆上为对象分配内存是，如果内存是绝对规整的，可以使用<strong>指针碰撞</strong>，直接让指针偏移出对象内存大小即可。如果内存不规则，需要维护一个<strong>空闲列表</strong>，从列表中选择能满足对象内存需求的内存块分配给对象。</p>
<p>&emsp;对象在分配时，也需要保证线程的安全，通常本地线程会预先分到一块内存空间作为<strong>本地线程缓冲</strong>，该线程创建的对象都在这块空间内分配，当缓冲用完后，需要申请新的空间时才需要同步锁定。</p>
<h1 id="Minor-GC-与-Full-GC"><a href="#Minor-GC-与-Full-GC" class="headerlink" title="Minor GC 与 Full GC"></a>Minor GC 与 Full GC</h1><p>&emsp;Minor GC 主要回收新生代的空间，Major GC 主要回收老年代空间，Full GC 回收老年代与新生代与元空间。</p>
<p>&emsp;触发full gc 的条件：</p>
<ul>
<li>调用System.gc() 方法，但是不一定会执行</li>
<li>老年代空间不足</li>
<li>空间分配担保失败</li>
<li>永久代( jdk 1.7 之前) 或 元空间不足</li>
<li>CMS GC 发生错误</li>
</ul>
<h1 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h1><p>&emsp;对象被回收时，如果对象覆盖了Object类的finalize()方法，虚拟机会在回收前执行对象的finalize()方法，但是不保证什么时候开始执行，也并不保证一定会执行完这个方法。</p>
]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>虚拟机</tag>
        <tag>垃圾收集</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis使用</title>
    <url>/2020/07/01/Redis%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>&emsp;Redis 是广泛应用的一个 NoSQL 数据库，基于 C 开发的键值对存储数据库，Redis一般用作缓存。但实际上 Redis 除了缓存之外，还有许多更加丰富的使用场景。比如 分布式锁，限流等。 </p>
<a id="more"></a>
<p>&emsp;Redis默认不支持远程连接，要开启远程连接，需要修改配置文件的两个地方：注释掉 bind 127.0.0.1 以及 开启密码校验，去掉 requirepass 的注释，修改自己的密码。</p>
<h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>&emsp;Jedis是 Redis 的 Java 客户端开发包之一，它的优点是 API 与 Redis 的原生 API 基本一致，不必花费时间再记忆 Jedis 的 API 使用。</p>
<h2 id="Jedis-连接-Redis"><a href="#Jedis-连接-Redis" class="headerlink" title="Jedis 连接 Redis"></a>Jedis 连接 Redis</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"192.168.43.196"</span>); <span class="comment">// redis地址，默认端口6379</span></span><br><span class="line">jedis.auth(<span class="string">"123456"</span>); <span class="comment">// 密码认证</span></span><br><span class="line">System.out.println(jedis.ping()); <span class="comment">// 返回PONG连接成功</span></span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure>
<p>&emsp;以上代码就是 Jedis 连接 Redis 的代码，连接上 Redis 之后，对 Redis 的各种操作例如 set，get 的 API 与 Redis 原生 API 一致。</p>
<h2 id="Jedis-连接池"><a href="#Jedis-连接池" class="headerlink" title="Jedis 连接池"></a>Jedis 连接池</h2><p>&emsp;Jedis 提供了连接池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JedisPool pool = <span class="keyword">new</span> JedisPool(<span class="string">"192.168.43.196"</span>); <span class="comment">// 创建一个连接池</span></span><br><span class="line"><span class="comment">// Jedis 实现了 Closable 接口</span></span><br><span class="line"><span class="keyword">try</span>(Jedis jedis = pool.getResource()) &#123; <span class="comment">// 获得一个连接并操作</span></span><br><span class="line">	jedis.auth(<span class="string">"123456"</span>);</span><br><span class="line">	System.out.println(jedis.ping());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;还可以使用 GenericObjectPoolConfig 类来配置连接池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JedisPool <span class="title">getJedisPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	GenericObjectPoolConfig config = <span class="keyword">new</span> GenericObjectPoolConfig();</span><br><span class="line">	config.setMaxIdle(<span class="number">300</span>); <span class="comment">// 最大空闲数</span></span><br><span class="line">	config.setMaxTotal(<span class="number">100</span>); <span class="comment">// 最大连接数</span></span><br><span class="line">	config.setMaxWaitMillis(<span class="number">20000</span>); <span class="comment">// 连接最大等待时间，-1表示无限制</span></span><br><span class="line">	config.setTestOnBorrow(<span class="keyword">true</span>); <span class="comment">// 空闲时检查有效性</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> JedisPool(config, <span class="string">"192.168.43.196"</span>, <span class="number">6379</span>, <span class="number">20</span>, <span class="string">"123456"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	JedisPool pool = getJedisPool();</span><br><span class="line">	<span class="keyword">try</span>(Jedis jedis = pool.getResource()) &#123;</span><br><span class="line">		System.out.println(jedis.ping());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="做分布式锁"><a href="#做分布式锁" class="headerlink" title="做分布式锁"></a>做分布式锁</h1><p>&emsp; Redis 除了用作缓存外，还可以用作分布式锁。当有多个线程竞争 key 时，利用分布式锁可以保证对 key 的操作的同步。</p>
<p>&emsp; 在 Redis 中，setnx 指令可以用来实现分布式锁，如果 key 不存在， 它会将 key 的 value 设置并返回1，如果 key 存在，则设置失败返回0。因此多线程竞争时，<strong>setnx 返回1则表示获得了锁，在操作完成后再将设置的 key 删除表示释放了锁</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JedisPool pool = getJedisPool();</span><br><span class="line"><span class="keyword">try</span>(Jedis jedis = pool.getResource())&#123;</span><br><span class="line">	Long setnx = jedis.setnx(<span class="string">"lock"</span>, <span class="string">"v"</span>);</span><br><span class="line">	<span class="keyword">if</span>(setnx == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">// 获得了锁，执行操作</span></span><br><span class="line">				</span><br><span class="line">		jedis.del(<span class="string">"lock"</span>); <span class="comment">// 操作完成后释放资源</span></span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 未获得锁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;但是以上的代码存在问题，如果线程在执行 del 指令之前挂掉了，这个锁就无法释放，后面的所有线程都无法再获得锁。要解决这个问题，最简单的想法是给锁添加过期时间。</p>
<p>&emsp;Redis 支持 setnx 和 expire 通过一个命令来执行：<code>SET key value [EX seconds][PX milliseconds] [NX|XX]</code>，其中，EX seconds 设置键过期时间为秒，PX milliseconds 设置键过期时间为毫秒，NX 表示只有在键不存在时才操作，XX 表示只有键存在时才操作，这个命令操作成功后返回 OK ，失败返回 NIL。例如 <code>SET lock 1 ex 10 nx</code>，表示只有 lock 键不存在时才操作，设置  lock 这个键的值为1，过期时间十秒。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JedisPool pool = getJedisPool();</span><br><span class="line"><span class="keyword">try</span>(Jedis jedis = pool.getResource())&#123;</span><br><span class="line">    <span class="comment">// SetParams类可以定义set指令参数</span></span><br><span class="line">	String result = jedis.set(<span class="string">"lock"</span>,<span class="string">"1"</span>, <span class="keyword">new</span> SetParams().ex(<span class="number">10</span>).nx());</span><br><span class="line">	<span class="keyword">if</span>(result.equals(<span class="string">"OK"</span>)) &#123;</span><br><span class="line">		<span class="comment">// 获得了锁，执行操作</span></span><br><span class="line">				</span><br><span class="line">		jedis.del(<span class="string">"lock"</span>); <span class="comment">// 操作完成后释放资源</span></span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 未获得锁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;但是以上代码依旧有问题，如果某个线程A的正常运行时间大于超时时间，那么该线程还没有执行完锁就被自动释放了，其它线程B就可以获得这个锁，线程B还未执行完，线程A就释放了线程B的锁，线程C又会获得这个锁。</p>
<p>&emsp;解决这个问题就是如果能判断加锁的线程是哪个线程，解锁的时候必须也是加锁线程才行，例如可以将 key 的 value 设置为随机字符串，每次释放锁都比较随机字符串是否是当前线程生成的，如果是，就可以释放，不是就不能释放。但是这样以来每次释放都需要获得 value，然后比较，然后再删除，三个步骤，不具有原子性。为了让其具有原子性，可以使用 Lua 脚本。</p>
<p>&emsp;如果不想编写 Lua 脚本，可以使用 Redission 库，这个库提供了额外的分布式锁的功能。</p>
<h1 id="做消息队列"><a href="#做消息队列" class="headerlink" title="做消息队列"></a>做消息队列</h1><p>&emsp;假如系统比较简单，可以直接使用 Redis 做消息队列，Redis 并不专业做消息队列，仅仅适合用在简单场景中。通过使用 Redis 的 List 数据结构，就可以实现消息队列。可以使用 List 的 blpop 或者 brpop 来实现阻塞式的读取消息。</p>
<p>&emsp;Redis中的 zset 数据结构则可以用来做延迟消息队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMQ</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool = MyJedis.getJedisPool();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span>(Jedis jedis = jedisPool.getResource())&#123;</span><br><span class="line">				<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">while</span>(!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">					<span class="comment">// 向 queue 这个zset中加入消息，延迟3秒</span></span><br><span class="line">					jedis.zadd(<span class="string">"queue"</span>, System.currentTimeMillis() + <span class="number">3000</span>, <span class="string">"msg----"</span> + i);</span><br><span class="line">					System.out.println(<span class="keyword">new</span> Date() + <span class="string">"放入消息-----"</span> + i++);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">500</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      					<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span>(Jedis jedis = jedisPool.getResource())&#123;</span><br><span class="line">				<span class="keyword">while</span>(!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">					Set&lt;String&gt; set = jedis.zrangeByScore(<span class="string">"queue"</span>, <span class="number">0</span>, System.currentTimeMillis());</span><br><span class="line">					<span class="keyword">if</span>(set.isEmpty()) &#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							Thread.sleep(<span class="number">500</span>);</span><br><span class="line">						&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">                      <span class="comment">// 获得集合中第一个元素</span></span><br><span class="line">					String message = set.iterator().next();</span><br><span class="line">                      <span class="comment">// 如果能删掉该元素，说明抢到了该消息</span></span><br><span class="line">					<span class="keyword">if</span>(jedis.zrem(<span class="string">"queue"</span>, message) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">						System.out.println(<span class="keyword">new</span> Date() + <span class="string">"收到了消息--------"</span> + message);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		Thread p = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer());</span><br><span class="line">		Thread c = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer());</span><br><span class="line">		p.start();</span><br><span class="line">		c.start();</span><br><span class="line">		Thread.sleep(<span class="number">8000</span>);</span><br><span class="line">		p.interrupt();</span><br><span class="line">		c.interrupt();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h1><p>&emsp;Redis 中对字符串的操作可以使用位操作，例如保存一个用户一年的签到记录，如果利用位操作来做，只需要365个比特就能完全记录下来，在用户量较大的情况下节省了大量空间。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常用操作</span></span><br><span class="line">setbit key offset value  # 设置key的值中的某一位</span><br><span class="line">getbit key offset   # 获取key的值中的某一位</span><br><span class="line">bitcount key [start end]   # 统计key的值的二进制表示的1的数量，start与end是字符的位置，不是比特位的位置</span><br><span class="line">bitpos key bit [start] [end] # 统计起始位置的0或者1的数量，起始位置也是字符的位置  </span><br><span class="line">bitfield  # 批量位操作</span><br></pre></td></tr></table></figure>
<h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><p>&emsp;HyperLogLog 是用来做<strong>基数统计</strong>的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。但是，因为 HyperLogLog 只会根据输入元素来计算基数，而<strong>不会储存输入元素本身</strong>，所以 HyperLogLog 不能像集合那样，返回输入的各个元素 。 </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常用操作</span></span><br><span class="line">PFADD key element [element ...] # 添加指定元素到 HyperLogLog 中。</span><br><span class="line">PFCOUNT key [key ...] # 返回给定 HyperLogLog 的基数估算值。</span><br><span class="line">PFMERGE destkey sourcekey [sourcekey ...] # 将多个 HyperLogLog 合并为一个 HyperLogLog</span><br></pre></td></tr></table></figure>
<p>&emsp;HyperLogLog 提供了一套不怎么精确但是够用的去重方案，<strong>会有误差</strong>。例如下列代码输出结果5037，并不完全准确。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	JedisPool pool = MyJedis.getJedisPool();</span><br><span class="line">	<span class="keyword">try</span>(Jedis jedis = pool.getResource())&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)</span><br><span class="line">			jedis.pfadd(<span class="string">"count"</span>, <span class="string">"test"</span> + i);</span><br><span class="line">		System.out.println(jedis.pfcount(<span class="string">"count"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p>&emsp;布隆过滤器相当于是一个不太精确的 set 集合，我们可以利用它里边的 contains 方法去判断某一个对象是否存在，但是这个判断不是特别精确。一般来说，通过 contains 判断某个值不存在， 那就一定不存在，但是判断某个值存在的话，则他可能不存在 。   </p>
<p>&emsp;布隆过滤器需要一个巨大的位数组和几个 hash 函数，它的 add 操作相当于对元素分别求出几个 hash 值，将位数组上 hash 值对应的位置设置为1即可。判断一个元素是否存在时，求出这个元素的几个 hash 值，如果它们对应的位都是1，表示这个元素存在，否则，这个元素不存在。因此布隆过滤器可能存在误判，一般位数组越大，误判率越小，占用空间越大。</p>
<h1 id="Redis限流"><a href="#Redis限流" class="headerlink" title="Redis限流"></a>Redis限流</h1><p>&emsp;Redis也可以利用 zset 数据结构作限流，key 与请求有关，分数保存为请求的时间戳，这样，利用 zrangeByScore 可以求出某一段时间内的请求数量，当某个时间段内的请求数量达到一定数量，就拒绝其它访问。能够保证每 N 秒至多有 M 个访问能通过。</p>
<h1 id="GeoHash"><a href="#GeoHash" class="headerlink" title="GeoHash"></a>GeoHash</h1><p>&emsp;GeoHash是一种地址编码方式，将二维空间的经纬度编码为一个字符串。它表示的是<strong>一块区域</strong>而不是一个特定的点。例如某地经纬度为(40，116)</p>
<ol>
<li><p>纬度的范围在 (-90,90) 之间，中间值为 0，对于 39.9053908600 值落在 (0,90),因此得到的值为 1 </p>
</li>
<li><p>(0,90) 的中间值为 45，39.9053908600 落在 (0,45) 之间，因此得到一个 0 </p>
</li>
<li><p>(0,45) 的中间值为 22.5，39.9053908600 落在 (22.5,45)之间，因此得到一个 1</p>
</li>
<li><p>……</p>
</li>
</ol>
<p>&emsp;最后计算出的纬度二进制是 101，经度二进制是110，之后按照经度占偶数位，纬度占奇数位合并，结果为111001，然后按照 Base32 （0-9,b-z,去掉 a i l 0）对合并后的二进制数据进行编码，编码的时候，先将二进制转换为十进制，然后进行编码。</p>
<p>&emsp;这种编码格式有特定的规律，例如一个地址编码之后的格式是 123，另一个地址编码之后的格式是 123456， 从字符串上就可以看出来，123456 表示的区域处于 123 表示的区域之中。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>&emsp;Redis 中的事务并不是严格的事务，它只保证了隔离性，即事务不会被其它事务打断，并不保证原子性。Redis 事务对应的指令有 watch，multi，exec，discard。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">multi</span><br><span class="line">set k1 v1</span><br><span class="line">set k2 v2</span><br><span class="line">get k2</span><br><span class="line">incr k2</span><br><span class="line">get k2</span><br><span class="line">exec</span><br><span class="line"><span class="comment">// 以上命令执行后结果</span></span><br><span class="line"><span class="number">1</span>) OK</span><br><span class="line"><span class="number">2</span>) OK</span><br><span class="line"><span class="number">3</span>) <span class="string">"v2"</span></span><br><span class="line"><span class="number">4</span>) (error) ERR value is not an integer or out of range</span><br><span class="line"><span class="number">5</span>) <span class="string">"v2"</span></span><br></pre></td></tr></table></figure>
<p>&emsp;可以看到，虽然事务中有一条指令出现了错误，但是并没有像 MySQL 一样整个事务都被回滚了。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Jedis</tag>
      </tags>
  </entry>
  <entry>
    <title>Jdk 动态代理</title>
    <url>/2020/06/29/Jdk-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>&emsp;所谓代理模式，就是为其它对象提供一个代理来控制对目标对象的访问，代理类不实现具体的服务，利用委托类来完成服务。</p>
<a id="more"></a>
<h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>&emsp;静态代理十分简单。创建一个接口，然后创建被代理的类实现该接口并且实现该接口中的抽象方法。之后再创建一个代理类，同时使其也实现这个接口。在代理类中持有一个被代理对象的引用，而后在代理类方法中调用该对象的方法 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设计一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String s)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被代理类实现该接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String s)</span> <span class="keyword">throws</span> IllegalArgumentException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数不合法"</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类也实现该接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloStaticProxy</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    Hello hello; <span class="comment">// 被代理的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloStaticProxy</span><span class="params">(Hello hello)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hello = hello; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String s)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before method invoke"</span>);</span><br><span class="line">        String re = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isException = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.hello.say(s);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IllegalArgumentException e)&#123;</span><br><span class="line">            isException = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"after method invoke"</span>);</span><br><span class="line">        <span class="keyword">if</span>(isException)</span><br><span class="line">            System.out.println(<span class="string">"after method throw Exception"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Hello hello = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">        Hello proxy = <span class="keyword">new</span> HelloStaticProxy(hello); <span class="comment">// 将被代理对象传入新建一个代理对象</span></span><br><span class="line">        proxy.say(<span class="keyword">null</span>);  <span class="comment">// 代理类在执行具体方法时通过所持用的被代理类完成调用</span></span><br><span class="line">        System.out.println(<span class="string">"------------------"</span>);</span><br><span class="line">        proxy.say(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;以上代码运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">before method invoke</span><br><span class="line">after method invoke</span><br><span class="line">after method throw Exception</span><br><span class="line">------------------</span><br><span class="line">before method invoke</span><br><span class="line">hello</span><br><span class="line">after method invoke</span><br></pre></td></tr></table></figure>
<p>&emsp;这样，当需要代理一个类的时候，只要编写一个该类的静态代理对象即可，但是，如果需要代理的对象很多，就需要编写大量的代理类，十分麻烦 。</p>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>&emsp;动态代理能够利用反射机制在程序运行期间生成代理类。在 java.lang.reflect 包下的 Proxy 类有一个静态方法 newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)，通过该方法可以获得动态代理类。它需要一个类加载器，类的接口数组，以及一个实现 InvocationHandler 接口的类。</p>
<p>&emsp; InvocationHandler 中只声明了一个方法：Object invoke(Object proxy, Method method, Object[] args) throws Throwable ，通过这个方法，可以调用被代理类的方法，需要注意，<strong>invoke 参数中的 proxy 表示的是代理对象，而不是被代理对象</strong>，因此 method.invoke() 传入的参数不能是它，否则会循环调用。</p>
<p>&emsp;上面的接口与接口实现类不变，创建一个实现了 InvocationHandler 的类完成动态代理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    Object target; <span class="comment">// 被代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyProxyHandler</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before method invoke"</span>);</span><br><span class="line">        Object re = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isException = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            re = method.invoke(target, args); <span class="comment">// 调用被代理对象的方法</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            isException = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"after method invoke"</span>);</span><br><span class="line">        <span class="keyword">if</span>(isException) &#123;</span><br><span class="line">            System.out.println(<span class="string">"after method throw Exception"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Hello hello = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">        Hello helloProxy = (Hello)Proxy.newProxyInstance(hello.getClass().getClassLoader(),</span><br><span class="line">                hello.getClass().getInterfaces(), <span class="keyword">new</span> MyProxyHandler(hello));</span><br><span class="line">        helloProxy.say(<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line">        helloProxy.say(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">before method invoke</span><br><span class="line">after method invoke</span><br><span class="line">after method throw Exception</span><br><span class="line">-----------------</span><br><span class="line">before method invoke</span><br><span class="line">hello</span><br><span class="line">after method invoke</span><br></pre></td></tr></table></figure>
<p>&emsp;jdk动态代理必须要依靠接口实现，因为<strong>生成的代理类是 Proxy 的子类</strong>，而 Java 不允许多继承，所以需要接口来连接代理类与被代理类。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2020/06/24/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="部分背包问题"><a href="#部分背包问题" class="headerlink" title="部分背包问题"></a>部分背包问题</h1><p>&emsp;部分背包问题即装入背包的物品可分割，可以用简单的贪心算法解决，物品平均价值由高到低排序，依次放入背包，直到放不下。<br><a id="more"></a></p>
<p>&emsp;例如：有一堆金粉，银粉，铜粉和铁粉，用一个固定大小的袋子去装，只要从平均价值最大的金粉开始装，装完后装下一堆平均价值最大的物品，直到袋子装满为止即可。</p>
<h1 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>&emsp;有N件物品，第 i 件物品重Ci，价值Wi，你有一个能装重量V的背包，每件物品只有一个，你需要装入哪些物品才能使背包内的价值总和最大？</p>
<h2 id="动态规划公式"><a href="#动态规划公式" class="headerlink" title="动态规划公式"></a>动态规划公式</h2><p>&emsp;定义dp[i, v]表示将前 i 件物品放入容量为 v 的背包可以获得最大价值总和，那么在这个情况下，有两种可能，要么第 i 件物品放入了背包内， 要么第 i 件物品没有放入背包内。</p>
<p>&emsp;如果第 i 件物品没有放入背包内，相当于<strong>dp[i, v] = dp[i - 1, v]</strong>，即将前面 i - 1件物品放入容量为v的背包中的最大价值总和。</p>
<p>&emsp;如果第 i 件物品放入了背包内，相当于<strong>dp[i, v] = dp[i - 1, v - Ci] + Wi</strong>，因为第 i 件物品放入了背包，所以相当于前面 i - 1 件物品占用v - Ci的空间的最大价值总和再加上第 i 件物品的价值。</p>
<p>&emsp;但是两种可能只能选择一种，价值最大的那种，所以01背包的递推公式为：<strong>dp[i, v] = max{dp[i - 1, v], dp[i - 1, v - Ci] + Wi}</strong></p>
<h2 id="解法与优化"><a href="#解法与优化" class="headerlink" title="解法与优化"></a>解法与优化</h2><p>&emsp;既然已经得到了递推公式，根据递推公式不断计算，最终算到<code>dp[N, V]</code>就是问题的答案了，可以创建一个二维数组计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bagProblem</span><span class="params">(<span class="keyword">int</span>[] C, <span class="keyword">int</span>[] W, <span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> dp[C.length + <span class="number">1</span>][V + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C.length; i++)&#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> j = C[i]; j &lt;= V; j++)&#123;</span><br><span class="line">        	dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - C[i]] + W[i]);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;   </span><br><span class="line">    <span class="keyword">return</span> dp[C.length][[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;从代码中不难看出，二维数组在计算过程中是逐行计算的，并且第 i 行的数据只依赖于第 i - 1行的数据，因此前面已经计算过的行其实已经无用了，可以删掉它们优化空间。最佳的优化下，可以只使用一维数组来计算。<br>&emsp;只用一维数组来计算的关键点在于，每一行数据在计算的时候，都依赖前面已经计算的元素，依赖于前面的 j - C[i]位置上的元素，<strong>如果依旧从前到后依次计算，拿到的这个位置的元素的值就是错的。所以这个时候需要从后到前计算</strong>，这样就能保证每次取 j - C[i]位置上的元素，都是上一次计算的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bagProblem</span><span class="params">(<span class="keyword">int</span>[] C, <span class="keyword">int</span>[] W, <span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> dp[V + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = V; j &gt;= C[i]; j--)&#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - C[i] + W[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[V];                                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;另外，在这个代码中，可以抽象出处理一件01背包问题的代码作为一个函数调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zeroOneBag</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> c, <span class="keyword">int</span> V, <span class="keyword">int</span>[] dp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = V; j &gt;= c; j--)</span><br><span class="line">    	dp[j] = Math.max(dp[j], dp[j - c] + w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bagProblem</span><span class="params">(<span class="keyword">int</span>[] C, <span class="keyword">int</span>[] W, <span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> dp[V + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C.length; i++)</span><br><span class="line">    	zeroOneBag(W[i], C[i], V, dp);</span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>&emsp;完全背包问题与01背包问题唯一的区别在于，每一种物品都有无限多个，可以拿0个，1个，任意个。很显然，直觉上看，这种情况下问题的复杂性十分高，可能的情况实在太多。</p>
<h2 id="动态规划公式推导"><a href="#动态规划公式推导" class="headerlink" title="动态规划公式推导"></a>动态规划公式推导</h2><p>&emsp;完全背包问题的递推式如下所示：</p>
<p>&emsp;  dp[i, j] = max( dp[i - 1, j - k<em>C[i] ] + k </em> W[i] )  其中 0 &lt;= k &lt;= V/C[i]       (1)</p>
<p>&emsp;即利用穷举的方式从不拿第 i 件物品到拿第 i 件物品装满背包都试一遍，看哪一种方案价值更大就选择哪一种方案。对于这种思路，就是将完全背包问题转化为01背包问题来求解，也有一些优化手段，比如如果两件物品 i 与 j 满足 C[i]  &lt;= C[j] &amp;&amp; W[i] &gt;= W[j]， 那么可以直接不用考虑 j 物品，因为每个物品可以拿无限多个，所以用价值高费用小的 i 替换 j 是显然不亏的。再比如用二进制编码的思想降低复杂度。</p>
<p>&emsp;但是，通过完全背包问题的递推式推导，却可以得到一个简单易懂的解决方法：</p>
<p>&emsp;完全背包问题递推式可以写成：</p>
<p>&emsp; dp[i, j] = max( dp[i - 1, j], dp[i - 1, j - k<em>C[i]] + k </em> W[i] )  其中 1 &lt;= k &lt;= V/C[i]       (2)</p>
<p>&emsp;由(1)式可得：</p>
<p>&emsp; dp[i, j - C[i]] = max( dp[i - 1, j - C[i] - k<em>C[i]] + k </em> W[i] )  其中 1 &lt;= k + 1 &lt;= V/C[i]   </p>
<p>&emsp; dp[i, j - C[i]] = max( dp[i - 1, j - (k + 1)<em>C[i]] + (k + 1) </em> W[i] - W[i] )  其中 1 &lt;= k + 1 &lt;= V/C[i]</p>
<p>&emsp;令 m = k + 1 则可推导出：</p>
<p>&emsp; dp[i, j - C[i]] = max( dp[i - 1, j - m<em>C[i]] + m </em> W[i] - W[i] )  其中 1 &lt;= m&lt;= V/C[i] </p>
<p>&emsp;故可以得到：</p>
<p>&emsp; dp[i, j - C[i]] + W[i] = max( dp[i - 1, j - m<em>C[i]] + m </em> W[i] )   其中 1 &lt;= m &lt;= V/C[i]       (3)</p>
<p>&emsp;将(3)代入(2)中有：</p>
<p>&emsp; dp[i, j] = max( dp[i - 1, j], dp[i, j - C[i]] + W[i] ) </p>
<p>&emsp;最终的这个公式与01背包的递推式相比较只有一处不同，而且由01背包需要逆序求解容易推导出，完全背包问题只需正序求解就能在一维数组下解决问题：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeBag</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> c, <span class="keyword">int</span> V, <span class="keyword">int</span>[] dp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = c; j &lt;= V; j++)</span><br><span class="line">    	dp[j] = Math.max(dp[j], dp[j - c] + w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bagProblem</span><span class="params">(<span class="keyword">int</span>[] C, <span class="keyword">int</span>[] W, <span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> dp[V + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C.length; i++)</span><br><span class="line">    	completeBag(W[i], C[i], V, dp);</span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h1><p>&emsp;多重背包问题就是每个物品能拿的数量是有限数m，这种情况下，如果一个物品的费用与能拿的次数的积大于背包容量，那么可以转化为完全背包问题求解，否则，要转化为01背包问题求解，可以用二进制编码优化时间复杂度。二进制编码优化是指，可以不用从0遍历到m次，可以转为1，2，4，2^(k-1) 与m - 2^k  + 1，其中k表示使2^k - 1 &lt;  m的最大k值。例如，m = 19，可以转为1， 2， 4， 8， 12，这样从1到19都能用这几个数组合得到，可以优化时间复杂度。<br>&emsp;传入一个数组M表示第i件物品只能拿M[i]次：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiBag</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> c, <span class="keyword">int</span> V, <span class="keyword">int</span>[] dp, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m * c &gt;= V)</span><br><span class="line">        completeBag(w, c, V, dp);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">2</span> * k - <span class="number">1</span> &lt; m)&#123;</span><br><span class="line">            zeroOneBag(w * k, c * k, V, dp);</span><br><span class="line">            k = <span class="number">2</span> * k;</span><br><span class="line">        &#125;</span><br><span class="line">        m = m - k / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        zeroOneBag(w * m, c * m, V, dp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bagProblem</span><span class="params">(<span class="keyword">int</span>[] C, <span class="keyword">int</span>[] W, <span class="keyword">int</span> V, <span class="keyword">int</span>[] M)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> dp[V + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C.length; i++)</span><br><span class="line">    	multiBag(W[i], C[i], V, dp, M[i]);</span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;假设每件物品平均能拿K次，多重背包问题在这种情况下时间复杂度为 $O(NVlgK)$ 。多重背包问题其实存在更好的方法可以达到 $O(NV)$ 的时间复杂度。</p>
<h1 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h1><p>&emsp;混合背包问题即之前三种背包问题的混合，有的物品最多只能拿1次，有的能拿无限次，有的能拿有限次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bagProblem</span><span class="params">(<span class="keyword">int</span>[] C, <span class="keyword">int</span>[] W, <span class="keyword">int</span> V, <span class="keyword">int</span>[] M)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> dp[V + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(M[i] == <span class="number">1</span>)</span><br><span class="line">        	zeroOneBag(w, c, V, dp);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(M[i] == <span class="number">0</span>) <span class="comment">// 表示能拿无限次</span></span><br><span class="line">        	completeBag(w, c, V, dp);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	multiBag(w[i], c[i], V, dp, M[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>背包问题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射机制</title>
    <url>/2020/06/27/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="java-lang-reflect"><a href="#java-lang-reflect" class="headerlink" title="java.lang.reflect"></a>java.lang.reflect</h1><p>&emsp;java.lang.reflect 包提供用于获取类和对象反射信息的类和接口。反射是指允许通过编程访问有关类的字段、方法和构造函数的信息，并允许使用反射的字段、方法和构造函数在封装和安全限制范围内对其基础对应项进行操作。</p>
<a id="more"></a>
<p>&emsp;该包下的类有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">AccessibleObject</th>
<th>是Filed，Method，Constructor类的父类，提供与权限相关的一些方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Array</td>
<td>提供了动态创建和访问Java数据的静态方法</td>
</tr>
<tr>
<td style="text-align:center">Constructor</td>
<td>提供类的单个构造函数的信息和访问</td>
</tr>
<tr>
<td style="text-align:center">Executable</td>
<td>Method和Constructor的父类</td>
</tr>
<tr>
<td style="text-align:center">Field</td>
<td>提供类的单个字段的信息和访问</td>
</tr>
<tr>
<td style="text-align:center">Method</td>
<td>提供类的单个方法的信息和访问</td>
</tr>
<tr>
<td style="text-align:center">Modifier</td>
<td>提供静态方法和常量来解码类和成员的访问修饰符</td>
</tr>
<tr>
<td style="text-align:center">Parameter</td>
<td>提供方法参数的信息</td>
</tr>
<tr>
<td style="text-align:center">Proxy</td>
<td>提供静态方法创建充当接口实例但允许自定义方法调用的对象( Jdk 动态代理)</td>
</tr>
<tr>
<td style="text-align:center">ReflectPermission</td>
<td>反射操作的权限类</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;通常使用到的类是 Constructor，Field，Method 与 Proxy 类。通常使用到的接口是 InvocationHandler 接口。其中 Proxy 类与 InvocationHandler 用在 jdk 动态代理上。</p>
<h1 id="反射获得类信息"><a href="#反射获得类信息" class="headerlink" title="反射获得类信息"></a>反射获得类信息</h1><p>&emsp;通过反射可以获得类的信息，定义 User 类如下，包含了一个私有构造函数，一个私有方法与三个私有字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"公共无参数构造函数"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> id, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.password = <span class="string">"protected Constructor"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">User</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = <span class="number">9999</span>;</span><br><span class="line">        <span class="keyword">this</span>.password = <span class="string">"private Constructor"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">testPrivateMethod</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打印传入字符串"</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......省略了getter，setter方法与toString()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反射获得与调用构造函数"><a href="#反射获得与调用构造函数" class="headerlink" title="反射获得与调用构造函数"></a>反射获得与调用构造函数</h2><p>&emsp;接下来，可以通过反射调用这些私有字段与方法，<strong>反射需要先获得类对象，获得类对象有三种方法</strong>，会体现在接下来的代码中，首先是调用构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] s)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="comment">// 第一种获得类Class对象的方法，调用对象的getClass()方法，该方法继承自Object</span></span><br><span class="line">    Class clazz = user.getClass();</span><br><span class="line"></span><br><span class="line">    Constructor[] constructors = clazz.getConstructors(); <span class="comment">// 获得public修饰的构造函数</span></span><br><span class="line">    <span class="keyword">for</span>(Constructor c : constructors)</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line"></span><br><span class="line">    constructors = clazz.getDeclaredConstructors();<span class="comment">// 获得所有构造函数</span></span><br><span class="line">    <span class="keyword">for</span>(Constructor c : constructors)</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line"></span><br><span class="line">    Constructor constructor = clazz.getConstructor(); <span class="comment">// 获得公共无参数构造函数</span></span><br><span class="line">    System.out.println(constructor.newInstance()); <span class="comment">// 调用Constructor的newInstance创建对象</span></span><br><span class="line"></span><br><span class="line">    constructor = clazz.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>; <span class="comment">// 获得被保护的构造函数，传入参数类型</span></span><br><span class="line">    System.out.println(constructor.newInstance(<span class="string">"protected Constructor"</span>, <span class="number">111</span>));</span><br><span class="line"></span><br><span class="line">    constructor = clazz.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">// 获得私有构造函数</span></span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);                                    <span class="comment">// 必须先解除私有限定！！！！</span></span><br><span class="line">    System.out.println(constructor.newInstance(<span class="string">"private constructor"</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">public fanshedemo.User(java.lang.String,int,java.lang.String)</span><br><span class="line">public fanshedemo.User()</span><br><span class="line">--------------------</span><br><span class="line">private fanshedemo.User(java.lang.String)</span><br><span class="line">protected fanshedemo.User(java.lang.String,int)</span><br><span class="line">public fanshedemo.User(java.lang.String,int,java.lang.String)</span><br><span class="line">public fanshedemo.User()</span><br><span class="line">--------------------</span><br><span class="line">User&#123;name=<span class="string">'公共无参数构造函数'</span>, id=<span class="number">0</span>, password=<span class="string">'null'</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">'protected Constructor'</span>, id=<span class="number">111</span>, password=<span class="string">'protected Constructor'</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">'private constructor'</span>, id=<span class="number">9999</span>, password=<span class="string">'private Constructor'</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反射获得与调用类方法"><a href="#反射获得与调用类方法" class="headerlink" title="反射获得与调用类方法"></a>反射获得与调用类方法</h2><p>&emsp;接下来，是反射获得类的方法，运行如下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] s)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Class clazz = User<span class="class">.<span class="keyword">class</span></span>; <span class="comment">// 第二种获得类Class对象的方法，访问它的静态字段class即可</span></span><br><span class="line"></span><br><span class="line">    Method[] methods = clazz.getMethods(); <span class="comment">// 获得非私有方法，包含父类方法</span></span><br><span class="line">    <span class="keyword">for</span>(Method m : methods)</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    System.out.println(<span class="string">"---------以上方法包含非私有方法与父类Object方法-----------"</span>);</span><br><span class="line"></span><br><span class="line">    methods = clazz.getDeclaredMethods(); <span class="comment">// 获得所有方法，不包含父类方法</span></span><br><span class="line">    <span class="keyword">for</span>(Method m : methods)</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line"></span><br><span class="line">    User u = <span class="keyword">new</span> User(<span class="string">"name"</span>, <span class="number">88</span>, <span class="string">"password"</span>);</span><br><span class="line">    System.out.println(u);</span><br><span class="line">    Method method = clazz.getMethod(<span class="string">"setName"</span>, String<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">// 传入方法名与参数获得方法</span></span><br><span class="line">    method.invoke(u,<span class="string">"new Name"</span>);      <span class="comment">// 调用时需要传入调用该方法的对象u</span></span><br><span class="line">    System.out.println(u);</span><br><span class="line"></span><br><span class="line">    method = clazz.getDeclaredMethod(<span class="string">"testPrivateMethod"</span>, String<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">// getDeclaredMethod方法可以获得private方法</span></span><br><span class="line">    method.setAccessible(<span class="keyword">true</span>);                               <span class="comment">// 解除私有限定</span></span><br><span class="line">    Object o = method.invoke(u,<span class="string">"invoke private method"</span>);      <span class="comment">// 获得返回值</span></span><br><span class="line">    System.out.println(<span class="string">"返回值是"</span> + o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp; 以上代码运行后结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">public java.lang.String fanshedemo.User.toString()</span><br><span class="line">public java.lang.String fanshedemo.User.getName()</span><br><span class="line">public void fanshedemo.User.setName(java.lang.String)</span><br><span class="line">public int fanshedemo.User.getId()</span><br><span class="line">public void fanshedemo.User.setPassword(java.lang.String)</span><br><span class="line">public java.lang.String fanshedemo.User.getPassword()</span><br><span class="line">public void fanshedemo.User.setId(int)</span><br><span class="line">public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span><br><span class="line">public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span><br><span class="line">public final void java.lang.Object.wait() throws java.lang.InterruptedException</span><br><span class="line">public boolean java.lang.Object.equals(java.lang.Object)</span><br><span class="line">public native int java.lang.Object.hashCode()</span><br><span class="line">public final native java.lang.Class java.lang.Object.getClass()</span><br><span class="line">public final native void java.lang.Object.notify()</span><br><span class="line">public final native void java.lang.Object.notifyAll()</span><br><span class="line">---------以上方法包含非私有方法与父类Object方法-----------</span><br><span class="line">public java.lang.String fanshedemo.User.toString()</span><br><span class="line">public java.lang.String fanshedemo.User.getName()</span><br><span class="line">public void fanshedemo.User.setName(java.lang.String)</span><br><span class="line">public int fanshedemo.User.getId()</span><br><span class="line">private java.lang.String fanshedemo.User.testPrivateMethod(java.lang.String)</span><br><span class="line">public void fanshedemo.User.setPassword(java.lang.String)</span><br><span class="line">public java.lang.String fanshedemo.User.getPassword()</span><br><span class="line">public void fanshedemo.User.setId(int)</span><br><span class="line">--------------------</span><br><span class="line">User&#123;name=<span class="string">'name'</span>, id=<span class="number">88</span>, password=<span class="string">'password'</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">'new Name'</span>, id=<span class="number">88</span>, password=<span class="string">'password'</span>&#125;</span><br><span class="line">打印传入字符串invoke private method</span><br><span class="line">返回值是invoke private method</span><br></pre></td></tr></table></figure>
<h2 id="反射获得与访问类的字段"><a href="#反射获得与访问类的字段" class="headerlink" title="反射获得与访问类的字段"></a>反射获得与访问类的字段</h2><p>&emsp;接下来，是反射获得类的字段，运行如下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] s)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 第三种获得Class对象的方法，通过Class的静态方法forName，需传入类的全限定名</span></span><br><span class="line">    Class clazz = Class.forName(<span class="string">"fanshedemo.User"</span>);</span><br><span class="line"></span><br><span class="line">    Field[] fields = clazz.getFields(); <span class="comment">// 获得非私有字段，包含父类</span></span><br><span class="line">    <span class="keyword">for</span>(Field field : fields)</span><br><span class="line">        System.out.println(field);</span><br><span class="line">    System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line">    fields = clazz.getDeclaredFields(); <span class="comment">// 获得所有字段，不包含父类</span></span><br><span class="line">    <span class="keyword">for</span>(Field field : fields)</span><br><span class="line">        System.out.println(field);</span><br><span class="line">    System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line"></span><br><span class="line">    User u = <span class="keyword">new</span> User(<span class="string">"name"</span>, <span class="number">111</span>, <span class="string">"password"</span>);</span><br><span class="line">    System.out.println(u);</span><br><span class="line">    Field field = clazz.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);       <span class="comment">// 解除私有限定</span></span><br><span class="line">    field.set(u, <span class="string">"new name"</span>);        <span class="comment">// 调用Field的set方法设置新值</span></span><br><span class="line">    System.out.println(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;以上代码运行后结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">--------------------</span><br><span class="line">private java.lang.String fanshedemo.User.name</span><br><span class="line">private int fanshedemo.User.id</span><br><span class="line">private java.lang.String fanshedemo.User.password</span><br><span class="line">--------------------</span><br><span class="line">User&#123;name=<span class="string">'name'</span>, id=<span class="number">111</span>, password=<span class="string">'password'</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">'new name'</span>, id=<span class="number">111</span>, password=<span class="string">'password'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;通过反射，可以在运行时获取对象的构造函数，方法，字段信息并访问它们，除此之外，Class 类还有 getInterfaces() 方法可以获得类所有实现的接口，getSuperClass() 可以获得类的父类等方法。</p>
<h1 id="利用反射运行指定方法"><a href="#利用反射运行指定方法" class="headerlink" title="利用反射运行指定方法"></a>利用反射运行指定方法</h1><p>&emsp;利用反射读取配置文件信息，根据配置文件信息运行指定方法。之前的 User 类不必改动，创建配置文件，填上如下内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">className=fanshedemo.User</span><br><span class="line">methodName=testPrivateMethod</span><br></pre></td></tr></table></figure>
<p>&emsp;之后修改 main 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] s)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"src/main/java/fanshedemo/config.properties"</span>);</span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    properties.load(in);</span><br><span class="line">    in.close();</span><br><span class="line">    String className = properties.getProperty(<span class="string">"className"</span>);</span><br><span class="line">    String methodName = properties.getProperty(<span class="string">"methodName"</span>);</span><br><span class="line">    Class clazz = Class.forName(className);</span><br><span class="line">    Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">    Object o = clazz.getConstructor().newInstance(); <span class="comment">// 获得对象</span></span><br><span class="line">    <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">        <span class="keyword">if</span>(method.getName().equals(methodName))&#123; <span class="comment">//找到对应方法名的方法</span></span><br><span class="line">            Parameter[] parameters = method.getParameters(); <span class="comment">// 获得方法定义的所有参数对象</span></span><br><span class="line">            Object[] objects = <span class="keyword">new</span> Object[parameters.length]; <span class="comment">// 传入方法的参数数组</span></span><br><span class="line">            <span class="comment">// 根据参数的类型新建参数默认参数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameters.length; i++)</span><br><span class="line">                objects[i] = Class.forName(parameters[i].getType().getName()).getConstructor().newInstance();</span><br><span class="line">            method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            method.invoke(o, objects);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;调用结果为：<code>打印传入字符串</code>，可知已经成功的在读取配置文件后通过反射调用一个方法，当然，实际情况可能不会这么简单，会更加复杂，这只是一个基础的小 demo 。</p>
<h1 id="利用反射绕过泛型检查"><a href="#利用反射绕过泛型检查" class="headerlink" title="利用反射绕过泛型检查"></a>利用反射绕过泛型检查</h1><p>&emsp;利用反射，还可以绕过泛型检查，例子如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"aaa"</span>);</span><br><span class="line">    list.add(<span class="string">"bbb"</span>);</span><br><span class="line">    Class clazz = list.getClass();</span><br><span class="line">    Method method = clazz.getMethod(<span class="string">"add"</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    method.invoke(list, <span class="number">123</span>);</span><br><span class="line">    method.invoke(list, <span class="keyword">false</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;上述代码运行结果：<code>[aaa, bbb, 123, false]</code>，由此，通过反射便绕过了 List 的泛型检查。</p>
<h1 id="通过反射获得泛型实际参数"><a href="#通过反射获得泛型实际参数" class="headerlink" title="通过反射获得泛型实际参数"></a>通过反射获得泛型实际参数</h1><p>&emsp;通过反射可以获得泛型实际参数，需要先了解 reflect 包中几个接口：</p>
<ul>
<li><strong>Type 接口</strong>：Type是Java编程语言中所有类型的通用超接口。这些类型包括原始类型、<strong>参数化类型</strong>、数组类型、类型变量和基本类型。 这个接口中只有一个方法 getTypeName() ，调用该方法可以获得类型名。</li>
<li><strong>ParameterizedType 接口</strong>：ParameterizedType表示参数化类型 ，其中的方法 getActualTypeArguments() 可以返回表示此类型的实际类型参数的类型对象数组，即 Type 数组。 </li>
<li><strong>WildcardType 接口</strong>：表示一个通配符类型表达式 ，其中有 getLowerBounds() 与 getUpperBounds() 方法，分别返回表示此类型变量的下界与上界的类型对象数组。其中 getUpperBounds() 如果没有显式声明上限，则上限为Object。 </li>
</ul>
<h2 id="通过反射获得类的泛型实际类型"><a href="#通过反射获得类的泛型实际类型" class="headerlink" title="通过反射获得类的泛型实际类型"></a>通过反射获得类的泛型实际类型</h2><p>&emsp;通过反射获得类实际泛型实际类型，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个带参数化类型的超类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span>&lt;<span class="title">T</span>,<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承自该超类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> <span class="keyword">extends</span> <span class="title">Base</span>&lt;<span class="title">String</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GenericDemo genericDemo = <span class="keyword">new</span> GenericDemo();</span><br><span class="line">        Class clazz = genericDemo.getClass();</span><br><span class="line">        <span class="comment">// Class对象中的方法，可以返回表示该类所表示的实体的直接超类的类型</span></span><br><span class="line">        <span class="comment">// 还有getGenericInterfaces方法返回接口中的类型</span></span><br><span class="line">        Type genericClass = clazz.getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span>(genericClass <span class="keyword">instanceof</span> ParameterizedType)&#123; <span class="comment">// 判断是不是参数化类型</span></span><br><span class="line">            ParameterizedType parameterizedType = (ParameterizedType)genericClass;</span><br><span class="line">            <span class="comment">// 返回表示此类型的实际类型参数的类型对象数组</span></span><br><span class="line">            Type[] types = parameterizedType.getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span>(Type type: types)&#123;</span><br><span class="line">                System.out.println(type.getTypeName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;代码运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">java.lang.String</span><br><span class="line">java.lang.Integer</span><br></pre></td></tr></table></figure>
<h2 id="通过反射获得方法参数的泛型实际类型"><a href="#通过反射获得方法参数的泛型实际类型" class="headerlink" title="通过反射获得方法参数的泛型实际类型"></a>通过反射获得方法参数的泛型实际类型</h2><p>&emsp;通过反射获得方法参数的泛型实际类型，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> <span class="keyword">extends</span> <span class="title">Base</span>&lt;<span class="title">String</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个方法参数有泛型类型的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">genericMethodDemo</span><span class="params">(Map&lt;String, Integer&gt; map, List&lt;String&gt; list, String string)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        GenericDemo genericDemo = <span class="keyword">new</span> GenericDemo();</span><br><span class="line">        Class clazz = genericDemo.getClass();</span><br><span class="line">        <span class="comment">// 获得该方法</span></span><br><span class="line">        Method method = clazz.getMethod(<span class="string">"genericMethodDemo"</span>, Map<span class="class">.<span class="keyword">class</span>, <span class="title">List</span>.<span class="title">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 返回方法的所有带有泛型的参数，返回值是数组类型</span></span><br><span class="line">        Type[] types = method.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span>(Type type: types)&#123;</span><br><span class="line">            <span class="keyword">if</span>(type <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">                ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">                <span class="comment">// 获得真实类型</span></span><br><span class="line">                Type[] genericTypes = parameterizedType.getActualTypeArguments(); </span><br><span class="line">                <span class="keyword">for</span>(Type genericType : genericTypes)</span><br><span class="line">                    System.out.println(genericType.getTypeName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;代码运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">java.lang.String</span><br><span class="line">java.lang.Integer</span><br><span class="line">java.lang.String</span><br></pre></td></tr></table></figure>
<h2 id="通过反射获得方法返回值的泛型实际类型"><a href="#通过反射获得方法返回值的泛型实际类型" class="headerlink" title="通过反射获得方法返回值的泛型实际类型"></a>通过反射获得方法返回值的泛型实际类型</h2><p>&emsp;通过反射获得方法返回值的泛型实际类型，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> <span class="keyword">extends</span> <span class="title">Base</span>&lt;<span class="title">String</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个方法返回值有泛型类型的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title">genericMethodDemo2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        GenericDemo genericDemo = <span class="keyword">new</span> GenericDemo();</span><br><span class="line">        Class clazz = genericDemo.getClass();</span><br><span class="line">        <span class="comment">// 获得该方法</span></span><br><span class="line">        Method method = clazz.getMethod(<span class="string">"genericMethodDemo2"</span>);</span><br><span class="line">        <span class="comment">// 返回值只有一个，所以不是数据类型</span></span><br><span class="line">        Type type = method.getGenericReturnType();</span><br><span class="line">        <span class="keyword">if</span>(type <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">            ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">            Type[] genericTypes = parameterizedType.getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span>(Type genericType : genericTypes)</span><br><span class="line">                System.out.println(genericType.getTypeName());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;代码运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">java.lang.String</span><br><span class="line">java.lang.Integer</span><br></pre></td></tr></table></figure>
<h2 id="通过反射获得泛型上下界"><a href="#通过反射获得泛型上下界" class="headerlink" title="通过反射获得泛型上下界"></a>通过反射获得泛型上下界</h2><p>&emsp;通过反射获得泛型的上下界，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> <span class="keyword">extends</span> <span class="title">Base</span>&lt;<span class="title">String</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个参数类型泛型有上下界的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">genericMethodDemo3</span><span class="params">(List&lt;? extends Number&gt; l1, List&lt;? <span class="keyword">super</span> Integer&gt; l2)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        GenericDemo genericDemo = <span class="keyword">new</span> GenericDemo();</span><br><span class="line">        Class clazz = genericDemo.getClass();</span><br><span class="line">        Method method = clazz.getMethod(<span class="string">"genericMethodDemo3"</span>, List<span class="class">.<span class="keyword">class</span>, <span class="title">List</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        Type[] types = method.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span>(Type type: types)&#123;</span><br><span class="line">            <span class="keyword">if</span>(type <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">                ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">                Type[] genericTypes = parameterizedType.getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span>(Type genericType : genericTypes)&#123;</span><br><span class="line">                    System.out.println(genericType.getTypeName());</span><br><span class="line">                    <span class="keyword">if</span>(genericType <span class="keyword">instanceof</span> WildcardType)&#123; <span class="comment">// 如果是该类型则强转</span></span><br><span class="line">                        WildcardType wildcardType = (WildcardType) genericType;</span><br><span class="line">                        System.out.println(<span class="string">"下界"</span>);</span><br><span class="line">                        <span class="keyword">for</span>(Type t : wildcardType.getLowerBounds()) <span class="comment">// 获得下界</span></span><br><span class="line">                            System.out.println(t.getTypeName());</span><br><span class="line">                        System.out.println(<span class="string">"上界"</span>);</span><br><span class="line">                        <span class="keyword">for</span>(Type t : wildcardType.getUpperBounds()) <span class="comment">// 获得上界</span></span><br><span class="line">                            System.out.println(t.getTypeName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;代码运行结果如下：结果也说明了，没有显示声明下界，下界为null，没有显示声明上界，上界为 Object 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">? extends java.lang.Number</span><br><span class="line">下界</span><br><span class="line">上界</span><br><span class="line">java.lang.Number</span><br><span class="line">? super java.lang.Integer</span><br><span class="line">下界</span><br><span class="line">java.lang.Integer</span><br><span class="line">上界</span><br><span class="line">java.lang.Object</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
</search>
