<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java Object类</title>
    <url>/2020/06/25/Java-Object%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><h1 id="getClass-方法"><a href="#getClass-方法" class="headerlink" title="getClass 方法"></a>getClass 方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure>
<p>&emsp;这个方法是 Native 方法，返回的是一个对象的实际类型，返回的type是Class&lt;? extends |X|&gt;，例如，如下代码输出的结果是 Integer。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Number n = <span class="number">0</span>;</span><br><span class="line">System.out.println(n.getClass());</span><br></pre></td></tr></table></figure>
<h1 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;在Object类的文档中，对 hashCode() 方法做了详细的要求：</p>
<ul>
<li>如果对象的信息没有被修改，对同一个对象的多次调用应该返回同一个结果。</li>
<li>如果两个对象 equals() 方法调用结果为 true，那么这两个对象应该返回相同的 hashCode ，故覆盖 equals 方法必须覆盖 hashCode 方法。</li>
<li>并不强制要求不相等的两个对象的 hashCode 必须不相同，但是不同的 hashCode 对 hash 表的使用更友好。</li>
</ul>
<h1 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals 方法"></a>equals 方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;在 Object 类的文档中，对 equals 方法做了详细的要求:</p>
<ul>
<li>该方法可以返回<strong>非空对象引用</strong>的等价关系。</li>
<li>该方法应该具备<strong>自反性</strong>，即 x.equals(x) 应该返回 true 。</li>
<li>该方法应该具备<strong>对称性</strong>，即 x.equals(y) 返回 true 时，y.equals(x) 也应该返回 true 。</li>
<li>该方法应该具备<strong>传递性</strong>，即 x.equals(y) 返回 true ，y.equals(z) 也返回 true 时， x.equals(z) 也应该返回 true 。</li>
<li>该方法应该具备<strong>一致性</strong>，即在对象未被修改的情况下，多次调用x.equals(y) 返回值也一样。</li>
<li>对于任意非空引用 x ，x.equals(null) 的结果应该是 false 。</li>
</ul>
<h1 id="clone-方法"><a href="#clone-方法" class="headerlink" title="clone 方法"></a>clone 方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp; clone方法返回一个对象的复制，一般要求满足 x.clone() != x 成立，并且 x.clone().getClass() == x.getClass() 成立。这个方法返回的对象应该与原对象独立，使用原对象的字段对返回的对象进行初始化。<br>&emsp;类在实现这个方法时，必须先实现 Cloneable 接口。如果没有实现接口 Cloneable ，则抛出 CloneNotSupportedException 。注意，所有数组都被认为实现了Cloneable接口，数组类型T[]的克隆方法的返回类型是T[]，其中T是任何引用或基本类型。</p>
<h1 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString 方法"></a>toString 方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp; 这个方法返回对象的字符串表示形式。</p>
<h1 id="线程相关方法"><a href="#线程相关方法" class="headerlink" title="线程相关方法"></a>线程相关方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会唤醒等待在当前对象监视器的线程，被唤起的线程重新加入监视器锁的竞争中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有获得当前对象监视器锁的线程才能调用，线程放弃当前监视器锁，转入等待队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    wait(<span class="number">0L</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeoutMillis, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure>
<p>&emsp;线程在执行 synchronized 标识的方法，代码块，静态方法时会获得当前对象监视器的锁。</p>
<h1 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize 方法"></a>finalize 方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span>(since=<span class="string">"9"</span>)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;这个方法并不被推荐使用，因为它的执行时间，执行顺序，是否执行完成都不能确定。在需要释放资源的场合，推荐使用 AutoCloseable 接口完成。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Object</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射机制</title>
    <url>/2020/06/27/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="java-lang-reflect"><a href="#java-lang-reflect" class="headerlink" title="java.lang.reflect"></a>java.lang.reflect</h1><p>&emsp;java.lang.reflect 包提供用于获取类和对象反射信息的类和接口。反射是指允许通过编程访问有关类的字段、方法和构造函数的信息，并允许使用反射的字段、方法和构造函数在封装和安全限制范围内对其基础对应项进行操作。</p>
<a id="more"></a>
<p>&emsp;该包下的类有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">AccessibleObject</th>
<th>是Filed，Method，Constructor类的父类，提供与权限相关的一些方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Array</td>
<td>提供了动态创建和访问Java数据的静态方法</td>
</tr>
<tr>
<td style="text-align:center">Constructor</td>
<td>提供类的单个构造函数的信息和访问</td>
</tr>
<tr>
<td style="text-align:center">Executable</td>
<td>Method和Constructor的父类</td>
</tr>
<tr>
<td style="text-align:center">Field</td>
<td>提供类的单个字段的信息和访问</td>
</tr>
<tr>
<td style="text-align:center">Method</td>
<td>提供类的单个方法的信息和访问</td>
</tr>
<tr>
<td style="text-align:center">Modifier</td>
<td>提供静态方法和常量来解码类和成员的访问修饰符</td>
</tr>
<tr>
<td style="text-align:center">Parameter</td>
<td>提供方法参数的信息</td>
</tr>
<tr>
<td style="text-align:center">Proxy</td>
<td>提供静态方法创建充当接口实例但允许自定义方法调用的对象( Jdk 动态代理)</td>
</tr>
<tr>
<td style="text-align:center">ReflectPermission</td>
<td>反射操作的权限类</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;通常使用到的类是 Constructor，Field，Method 与 Proxy 类。通常使用到的接口是 InvocationHandler 接口。其中 Proxy 类与 InvocationHandler 用在 jdk 动态代理上。</p>
<h1 id="反射获得类信息"><a href="#反射获得类信息" class="headerlink" title="反射获得类信息"></a>反射获得类信息</h1><p>&emsp;通过反射可以获得类的信息，定义 User 类如下，包含了一个私有构造函数，一个私有方法与三个私有字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"公共无参数构造函数"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> id, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.password = <span class="string">"protected Constructor"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">User</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = <span class="number">9999</span>;</span><br><span class="line">        <span class="keyword">this</span>.password = <span class="string">"private Constructor"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">testPrivateMethod</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打印传入字符串"</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......省略了getter，setter方法与toString()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反射获得与调用构造函数"><a href="#反射获得与调用构造函数" class="headerlink" title="反射获得与调用构造函数"></a>反射获得与调用构造函数</h2><p>&emsp;接下来，可以通过反射调用这些私有字段与方法，<strong>反射需要先获得类对象，获得类对象有三种方法</strong>，会体现在接下来的代码中，首先是调用构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] s)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="comment">// 第一种获得类Class对象的方法，调用对象的getClass()方法，该方法继承自Object</span></span><br><span class="line">    Class clazz = user.getClass();</span><br><span class="line"></span><br><span class="line">    Constructor[] constructors = clazz.getConstructors(); <span class="comment">// 获得public修饰的构造函数</span></span><br><span class="line">    <span class="keyword">for</span>(Constructor c : constructors)</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line"></span><br><span class="line">    constructors = clazz.getDeclaredConstructors();<span class="comment">// 获得所有构造函数</span></span><br><span class="line">    <span class="keyword">for</span>(Constructor c : constructors)</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line"></span><br><span class="line">    Constructor constructor = clazz.getConstructor(); <span class="comment">// 获得公共无参数构造函数</span></span><br><span class="line">    System.out.println(constructor.newInstance()); <span class="comment">// 调用Constructor的newInstance创建对象</span></span><br><span class="line"></span><br><span class="line">    constructor = clazz.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>; <span class="comment">// 获得被保护的构造函数，传入参数类型</span></span><br><span class="line">    System.out.println(constructor.newInstance(<span class="string">"protected Constructor"</span>, <span class="number">111</span>));</span><br><span class="line"></span><br><span class="line">    constructor = clazz.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">// 获得私有构造函数</span></span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);                                    <span class="comment">// 必须先解除私有限定！！！！</span></span><br><span class="line">    System.out.println(constructor.newInstance(<span class="string">"private constructor"</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">public fanshedemo.User(java.lang.String,int,java.lang.String)</span><br><span class="line">public fanshedemo.User()</span><br><span class="line">--------------------</span><br><span class="line">private fanshedemo.User(java.lang.String)</span><br><span class="line">protected fanshedemo.User(java.lang.String,int)</span><br><span class="line">public fanshedemo.User(java.lang.String,int,java.lang.String)</span><br><span class="line">public fanshedemo.User()</span><br><span class="line">--------------------</span><br><span class="line">User&#123;name=<span class="string">'公共无参数构造函数'</span>, id=<span class="number">0</span>, password=<span class="string">'null'</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">'protected Constructor'</span>, id=<span class="number">111</span>, password=<span class="string">'protected Constructor'</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">'private constructor'</span>, id=<span class="number">9999</span>, password=<span class="string">'private Constructor'</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反射获得与调用类方法"><a href="#反射获得与调用类方法" class="headerlink" title="反射获得与调用类方法"></a>反射获得与调用类方法</h2><p>&emsp;接下来，是反射获得类的方法，运行如下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] s)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Class clazz = User<span class="class">.<span class="keyword">class</span></span>; <span class="comment">// 第二种获得类Class对象的方法，访问它的静态字段class即可</span></span><br><span class="line"></span><br><span class="line">    Method[] methods = clazz.getMethods(); <span class="comment">// 获得非私有方法，包含父类方法</span></span><br><span class="line">    <span class="keyword">for</span>(Method m : methods)</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    System.out.println(<span class="string">"---------以上方法包含非私有方法与父类Object方法-----------"</span>);</span><br><span class="line"></span><br><span class="line">    methods = clazz.getDeclaredMethods(); <span class="comment">// 获得所有方法，不包含父类方法</span></span><br><span class="line">    <span class="keyword">for</span>(Method m : methods)</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line"></span><br><span class="line">    User u = <span class="keyword">new</span> User(<span class="string">"name"</span>, <span class="number">88</span>, <span class="string">"password"</span>);</span><br><span class="line">    System.out.println(u);</span><br><span class="line">    Method method = clazz.getMethod(<span class="string">"setName"</span>, String<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">// 传入方法名与参数获得方法</span></span><br><span class="line">    method.invoke(u,<span class="string">"new Name"</span>);      <span class="comment">// 调用时需要传入调用该方法的对象u</span></span><br><span class="line">    System.out.println(u);</span><br><span class="line"></span><br><span class="line">    method = clazz.getDeclaredMethod(<span class="string">"testPrivateMethod"</span>, String<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">// getDeclaredMethod方法可以获得private方法</span></span><br><span class="line">    method.setAccessible(<span class="keyword">true</span>);                               <span class="comment">// 解除私有限定</span></span><br><span class="line">    Object o = method.invoke(u,<span class="string">"invoke private method"</span>);      <span class="comment">// 获得返回值</span></span><br><span class="line">    System.out.println(<span class="string">"返回值是"</span> + o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp; 以上代码运行后结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">public java.lang.String fanshedemo.User.toString()</span><br><span class="line">public java.lang.String fanshedemo.User.getName()</span><br><span class="line">public void fanshedemo.User.setName(java.lang.String)</span><br><span class="line">public int fanshedemo.User.getId()</span><br><span class="line">public void fanshedemo.User.setPassword(java.lang.String)</span><br><span class="line">public java.lang.String fanshedemo.User.getPassword()</span><br><span class="line">public void fanshedemo.User.setId(int)</span><br><span class="line">public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span><br><span class="line">public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span><br><span class="line">public final void java.lang.Object.wait() throws java.lang.InterruptedException</span><br><span class="line">public boolean java.lang.Object.equals(java.lang.Object)</span><br><span class="line">public native int java.lang.Object.hashCode()</span><br><span class="line">public final native java.lang.Class java.lang.Object.getClass()</span><br><span class="line">public final native void java.lang.Object.notify()</span><br><span class="line">public final native void java.lang.Object.notifyAll()</span><br><span class="line">---------以上方法包含非私有方法与父类Object方法-----------</span><br><span class="line">public java.lang.String fanshedemo.User.toString()</span><br><span class="line">public java.lang.String fanshedemo.User.getName()</span><br><span class="line">public void fanshedemo.User.setName(java.lang.String)</span><br><span class="line">public int fanshedemo.User.getId()</span><br><span class="line">private java.lang.String fanshedemo.User.testPrivateMethod(java.lang.String)</span><br><span class="line">public void fanshedemo.User.setPassword(java.lang.String)</span><br><span class="line">public java.lang.String fanshedemo.User.getPassword()</span><br><span class="line">public void fanshedemo.User.setId(int)</span><br><span class="line">--------------------</span><br><span class="line">User&#123;name=<span class="string">'name'</span>, id=<span class="number">88</span>, password=<span class="string">'password'</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">'new Name'</span>, id=<span class="number">88</span>, password=<span class="string">'password'</span>&#125;</span><br><span class="line">打印传入字符串invoke private method</span><br><span class="line">返回值是invoke private method</span><br></pre></td></tr></table></figure>
<h2 id="反射获得与访问类的字段"><a href="#反射获得与访问类的字段" class="headerlink" title="反射获得与访问类的字段"></a>反射获得与访问类的字段</h2><p>&emsp;接下来，是反射获得类的字段，运行如下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] s)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 第三种获得Class对象的方法，通过Class的静态方法forName，需传入类的全限定名</span></span><br><span class="line">    Class clazz = Class.forName(<span class="string">"fanshedemo.User"</span>);</span><br><span class="line"></span><br><span class="line">    Field[] fields = clazz.getFields(); <span class="comment">// 获得非私有字段，包含父类</span></span><br><span class="line">    <span class="keyword">for</span>(Field field : fields)</span><br><span class="line">        System.out.println(field);</span><br><span class="line">    System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line">    fields = clazz.getDeclaredFields(); <span class="comment">// 获得所有字段，不包含父类</span></span><br><span class="line">    <span class="keyword">for</span>(Field field : fields)</span><br><span class="line">        System.out.println(field);</span><br><span class="line">    System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line"></span><br><span class="line">    User u = <span class="keyword">new</span> User(<span class="string">"name"</span>, <span class="number">111</span>, <span class="string">"password"</span>);</span><br><span class="line">    System.out.println(u);</span><br><span class="line">    Field field = clazz.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);       <span class="comment">// 解除私有限定</span></span><br><span class="line">    field.set(u, <span class="string">"new name"</span>);        <span class="comment">// 调用Field的set方法设置新值</span></span><br><span class="line">    System.out.println(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;以上代码运行后结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">--------------------</span><br><span class="line">private java.lang.String fanshedemo.User.name</span><br><span class="line">private int fanshedemo.User.id</span><br><span class="line">private java.lang.String fanshedemo.User.password</span><br><span class="line">--------------------</span><br><span class="line">User&#123;name=<span class="string">'name'</span>, id=<span class="number">111</span>, password=<span class="string">'password'</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">'new name'</span>, id=<span class="number">111</span>, password=<span class="string">'password'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;通过反射，可以在运行时获取对象的构造函数，方法，字段信息并访问它们，除此之外，Class 类还有 getInterfaces() 方法可以获得类所有实现的接口，getSuperClass() 可以获得类的父类等方法。</p>
<h1 id="利用反射运行指定方法"><a href="#利用反射运行指定方法" class="headerlink" title="利用反射运行指定方法"></a>利用反射运行指定方法</h1><p>&emsp;利用反射读取配置文件信息，根据配置文件信息运行指定方法。之前的 User 类不必改动，创建配置文件，填上如下内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">className=fanshedemo.User</span><br><span class="line">methodName=testPrivateMethod</span><br></pre></td></tr></table></figure>
<p>&emsp;之后修改 main 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] s)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"src/main/java/fanshedemo/config.properties"</span>);</span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    properties.load(in);</span><br><span class="line">    in.close();</span><br><span class="line">    String className = properties.getProperty(<span class="string">"className"</span>);</span><br><span class="line">    String methodName = properties.getProperty(<span class="string">"methodName"</span>);</span><br><span class="line">    Class clazz = Class.forName(className);</span><br><span class="line">    Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">    Object o = clazz.getConstructor().newInstance(); <span class="comment">// 获得对象</span></span><br><span class="line">    <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">        <span class="keyword">if</span>(method.getName().equals(methodName))&#123; <span class="comment">//找到对应方法名的方法</span></span><br><span class="line">            Parameter[] parameters = method.getParameters(); <span class="comment">// 获得方法定义的所有参数对象</span></span><br><span class="line">            Object[] objects = <span class="keyword">new</span> Object[parameters.length]; <span class="comment">// 传入方法的参数数组</span></span><br><span class="line">            <span class="comment">// 根据参数的类型新建参数默认参数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameters.length; i++)</span><br><span class="line">                objects[i] = Class.forName(parameters[i].getType().getName()).getConstructor().newInstance();</span><br><span class="line">            method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            method.invoke(o, objects);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;调用结果为：<code>打印传入字符串</code>，可知已经成功的在读取配置文件后通过反射调用一个方法，当然，实际情况可能不会这么简单，会更加复杂，这只是一个基础的小 demo 。</p>
<h1 id="利用反射绕过泛型检查"><a href="#利用反射绕过泛型检查" class="headerlink" title="利用反射绕过泛型检查"></a>利用反射绕过泛型检查</h1><p>&emsp;利用反射，还可以绕过泛型检查，例子如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"aaa"</span>);</span><br><span class="line">    list.add(<span class="string">"bbb"</span>);</span><br><span class="line">    Class clazz = list.getClass();</span><br><span class="line">    Method method = clazz.getMethod(<span class="string">"add"</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    method.invoke(list, <span class="number">123</span>);</span><br><span class="line">    method.invoke(list, <span class="keyword">false</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;上述代码运行结果：<code>[aaa, bbb, 123, false]</code>，由此，通过反射便绕过了 List 的泛型检查。</p>
<h1 id="通过反射获得泛型实际参数"><a href="#通过反射获得泛型实际参数" class="headerlink" title="通过反射获得泛型实际参数"></a>通过反射获得泛型实际参数</h1><p>&emsp;通过反射可以获得泛型实际参数，需要先了解 reflect 包中几个接口：</p>
<ul>
<li><strong>Type 接口</strong>：Type是Java编程语言中所有类型的通用超接口。这些类型包括原始类型、<strong>参数化类型</strong>、数组类型、类型变量和基本类型。 这个接口中只有一个方法 getTypeName() ，调用该方法可以获得类型名。</li>
<li><strong>ParameterizedType 接口</strong>：ParameterizedType表示参数化类型 ，其中的方法 getActualTypeArguments() 可以返回表示此类型的实际类型参数的类型对象数组，即 Type 数组。 </li>
<li><strong>WildcardType 接口</strong>：表示一个通配符类型表达式 ，其中有 getLowerBounds() 与 getUpperBounds() 方法，分别返回表示此类型变量的下界与上界的类型对象数组。其中 getUpperBounds() 如果没有显式声明上限，则上限为Object。 </li>
</ul>
<h2 id="通过反射获得类的泛型实际类型"><a href="#通过反射获得类的泛型实际类型" class="headerlink" title="通过反射获得类的泛型实际类型"></a>通过反射获得类的泛型实际类型</h2><p>&emsp;通过反射获得类实际泛型实际类型，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个带参数化类型的超类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span>&lt;<span class="title">T</span>,<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承自该超类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> <span class="keyword">extends</span> <span class="title">Base</span>&lt;<span class="title">String</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GenericDemo genericDemo = <span class="keyword">new</span> GenericDemo();</span><br><span class="line">        Class clazz = genericDemo.getClass();</span><br><span class="line">        <span class="comment">// Class对象中的方法，可以返回表示该类所表示的实体的直接超类的类型</span></span><br><span class="line">        <span class="comment">// 还有getGenericInterfaces方法返回接口中的类型</span></span><br><span class="line">        Type genericClass = clazz.getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span>(genericClass <span class="keyword">instanceof</span> ParameterizedType)&#123; <span class="comment">// 判断是不是参数化类型</span></span><br><span class="line">            ParameterizedType parameterizedType = (ParameterizedType)genericClass;</span><br><span class="line">            <span class="comment">// 返回表示此类型的实际类型参数的类型对象数组</span></span><br><span class="line">            Type[] types = parameterizedType.getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span>(Type type: types)&#123;</span><br><span class="line">                System.out.println(type.getTypeName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;代码运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">java.lang.String</span><br><span class="line">java.lang.Integer</span><br></pre></td></tr></table></figure>
<h2 id="通过反射获得方法参数的泛型实际类型"><a href="#通过反射获得方法参数的泛型实际类型" class="headerlink" title="通过反射获得方法参数的泛型实际类型"></a>通过反射获得方法参数的泛型实际类型</h2><p>&emsp;通过反射获得方法参数的泛型实际类型，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> <span class="keyword">extends</span> <span class="title">Base</span>&lt;<span class="title">String</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个方法参数有泛型类型的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">genericMethodDemo</span><span class="params">(Map&lt;String, Integer&gt; map, List&lt;String&gt; list, String string)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        GenericDemo genericDemo = <span class="keyword">new</span> GenericDemo();</span><br><span class="line">        Class clazz = genericDemo.getClass();</span><br><span class="line">        <span class="comment">// 获得该方法</span></span><br><span class="line">        Method method = clazz.getMethod(<span class="string">"genericMethodDemo"</span>, Map<span class="class">.<span class="keyword">class</span>, <span class="title">List</span>.<span class="title">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 返回方法的所有带有泛型的参数，返回值是数组类型</span></span><br><span class="line">        Type[] types = method.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span>(Type type: types)&#123;</span><br><span class="line">            <span class="keyword">if</span>(type <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">                ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">                <span class="comment">// 获得真实类型</span></span><br><span class="line">                Type[] genericTypes = parameterizedType.getActualTypeArguments(); </span><br><span class="line">                <span class="keyword">for</span>(Type genericType : genericTypes)</span><br><span class="line">                    System.out.println(genericType.getTypeName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;代码运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">java.lang.String</span><br><span class="line">java.lang.Integer</span><br><span class="line">java.lang.String</span><br></pre></td></tr></table></figure>
<h2 id="通过反射获得方法返回值的泛型实际类型"><a href="#通过反射获得方法返回值的泛型实际类型" class="headerlink" title="通过反射获得方法返回值的泛型实际类型"></a>通过反射获得方法返回值的泛型实际类型</h2><p>&emsp;通过反射获得方法返回值的泛型实际类型，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> <span class="keyword">extends</span> <span class="title">Base</span>&lt;<span class="title">String</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个方法返回值有泛型类型的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title">genericMethodDemo2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        GenericDemo genericDemo = <span class="keyword">new</span> GenericDemo();</span><br><span class="line">        Class clazz = genericDemo.getClass();</span><br><span class="line">        <span class="comment">// 获得该方法</span></span><br><span class="line">        Method method = clazz.getMethod(<span class="string">"genericMethodDemo2"</span>);</span><br><span class="line">        <span class="comment">// 返回值只有一个，所以不是数据类型</span></span><br><span class="line">        Type type = method.getGenericReturnType();</span><br><span class="line">        <span class="keyword">if</span>(type <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">            ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">            Type[] genericTypes = parameterizedType.getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span>(Type genericType : genericTypes)</span><br><span class="line">                System.out.println(genericType.getTypeName());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;代码运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">java.lang.String</span><br><span class="line">java.lang.Integer</span><br></pre></td></tr></table></figure>
<h2 id="通过反射获得泛型上下界"><a href="#通过反射获得泛型上下界" class="headerlink" title="通过反射获得泛型上下界"></a>通过反射获得泛型上下界</h2><p>&emsp;通过反射获得泛型的上下界，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> <span class="keyword">extends</span> <span class="title">Base</span>&lt;<span class="title">String</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个参数类型泛型有上下界的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">genericMethodDemo3</span><span class="params">(List&lt;? extends Number&gt; l1, List&lt;? <span class="keyword">super</span> Integer&gt; l2)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        GenericDemo genericDemo = <span class="keyword">new</span> GenericDemo();</span><br><span class="line">        Class clazz = genericDemo.getClass();</span><br><span class="line">        Method method = clazz.getMethod(<span class="string">"genericMethodDemo3"</span>, List<span class="class">.<span class="keyword">class</span>, <span class="title">List</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        Type[] types = method.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span>(Type type: types)&#123;</span><br><span class="line">            <span class="keyword">if</span>(type <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">                ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">                Type[] genericTypes = parameterizedType.getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span>(Type genericType : genericTypes)&#123;</span><br><span class="line">                    System.out.println(genericType.getTypeName());</span><br><span class="line">                    <span class="keyword">if</span>(genericType <span class="keyword">instanceof</span> WildcardType)&#123; <span class="comment">// 如果是该类型则强转</span></span><br><span class="line">                        WildcardType wildcardType = (WildcardType) genericType;</span><br><span class="line">                        System.out.println(<span class="string">"下界"</span>);</span><br><span class="line">                        <span class="keyword">for</span>(Type t : wildcardType.getLowerBounds()) <span class="comment">// 获得下界</span></span><br><span class="line">                            System.out.println(t.getTypeName());</span><br><span class="line">                        System.out.println(<span class="string">"上界"</span>);</span><br><span class="line">                        <span class="keyword">for</span>(Type t : wildcardType.getUpperBounds()) <span class="comment">// 获得上界</span></span><br><span class="line">                            System.out.println(t.getTypeName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;代码运行结果如下：结果也说明了，没有显示声明下界，下界为null，没有显示声明上界，上界为 Object 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">? extends java.lang.Number</span><br><span class="line">下界</span><br><span class="line">上界</span><br><span class="line">java.lang.Number</span><br><span class="line">? super java.lang.Integer</span><br><span class="line">下界</span><br><span class="line">java.lang.Integer</span><br><span class="line">上界</span><br><span class="line">java.lang.Object</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Java垃圾收集机制</title>
    <url>/2020/06/25/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="判断对象是否可回收"><a href="#判断对象是否可回收" class="headerlink" title="判断对象是否可回收"></a>判断对象是否可回收</h1><p>&emsp;判断一个对象是否可以被回收，即还有没有其它指针指向它，如果没有了，说明这个对象已经不可以再被使用到了，就可以回收掉它的内存空间。主要有两种方式可以判断：</p>
<a id="more"></a>
<p>&emsp;- 引用计数法：每当有一个引用引用到对象，就给对象的引用计数加一，这样当某个对象的引用计数为0时，就说明该对象已经可以被回收了，但是该方法有循环引用的问题。</p>
<p>&emsp;- 可达性分析算法：以GC Roots对象为起点开始搜索引用链，凡是能搜索到的对象都是存活的对象，未能搜索到的对象都是可回收的对象。</p>
<p>&emsp;Java虚拟机中多使用可达性分析算法，其中GC Roots对象有4类：</p>
<ul>
<li>方法区中的常量引用的对象。</li>
<li>方法区中静态变量引用的对象。</li>
<li>栈中局部变量引用的对象。</li>
<li>本地方法栈中引用的对象。</li>
</ul>
<p>&emsp;Java中对象有四种引用：强引用，一定不会被垃圾收集；软引用，空间不足时会被收集；弱引用，下一次垃圾收集就被收集；虚引用，不会对对象的生命周期产生任何影响。</p>
<h2 id="对类的回收"><a href="#对类的回收" class="headerlink" title="对类的回收"></a>对类的回收</h2><p>&emsp;虚拟机对类的回收十分严苛，需要满足三个条件，并且满足了也不一定会回收：</p>
<ol>
<li>类的所有实例已经被回收。</li>
<li>加载该类的ClassLoader已经被回收。</li>
<li>该类对应的Class对象没有被引用，不能通过反射获得该类。</li>
</ol>
<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><ol>
<li>标记-清除算法：虚拟机标记可达对象后，将不可达的对象统一清除。这种算法效率比较低，而且容易造成空间碎片。</li>
<li>标记-整理算法：虚拟机将可达的对象全部移动到内存的一侧，将边界以外的空间一起释放。好处是无内存碎片，缺点是效率低。</li>
<li>复制算法：将内存分两块，只使用一块，在垃圾收集时将存活对象移动到另一块即可。好处是效率高，但是内存只使用到一半。虚拟机内实现一般分为一块Eden与两块Survivor，比例8：1：1，每次使用Eden与一块Survivor，留一块Survivor做垃圾收集时的复制空间，这样可以提高空间利用率。</li>
</ol>
<h1 id="Stop-the-world"><a href="#Stop-the-world" class="headerlink" title="Stop the world"></a>Stop the world</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;由于不能出现可达性分析过程中对象引用关系还在不断变化的情况，因此<strong>GC时必须停顿所有的Java执行线程</strong>，会影响系统响应以及用户体验，在HotSpot实现中，使用一组称为OopMap的数据结构来存储哪些地方存放着对象引用，这样可以减少GC时扫描全局引用的时间。<br>&nbsp;&nbsp;&nbsp;&nbsp;HotSpot并没有为每条指令都生成OopMap，只在“特定的位置”记录，这些位置称为安全点，因此程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能。但还有一个问题需要考虑，如何在GC时让所有线程都跑到最近的安全点上停顿，有两种方式：</p>
<ul>
<li>抢先示中中断，不需要线程的执行代码配合，在GC时，中断所有线程，如果发现有线程中断的地方不在安全点上，就让它跑到安全点上，现在几乎没有虚拟机采用这种方法。</li>
<li><strong>主动式中断，当GC需要中断线程时，设置一个标志，各个线程主动轮询这个标志，发现为真时自己中断挂起。</strong>    </li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;当线程处于挂起状态时，无法响应中断请求，这种时候需要安全区域来解决。<strong>安全区域是指在一段代码片段中，引用关系不会发生变化。在这个区域中的任何地方开始GC都是安全的，安全区域可以看作是扩展的安全区域。</strong></p>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>&emsp;很多垃圾收集器采用分代收集的方式，将堆中的内存分为新生代和老年代，新生代的对象通常存活时间较短，回收比较频繁，采用效率高的复制算法，老年代的对象存活时间很长，回收不频繁，采用标记-清除或标记-整理算法。</p>
<ul>
<li>Serial 与 Serial Old 收集器：单线程收集器，垃圾收集时需要暂停其它工作线程，直到收集结束。主要用在Client模式下的虚拟机。</li>
<li>ParNew 收集器： Serial收集器的多线程版本，主要用在Server模式的虚拟机上，能与CMS收集器配合工作。</li>
<li>Parallel Scavenge 与 Parallel Old 收集器，多线程吞吐量优先收集器。</li>
</ul>
<h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>&emsp;目标是获得最短的回收停顿时间，基于标记清除算法实现，在Server端使用比较多。运作过程包括<strong>初始标记，并发标记，重新标记与并发清除</strong>。初始标记只标记GC Roots能直接关联到的对象，速度很快；并发标记就是进行可达性分析的过程；重新标记修正并发标记期间引用关系发生变化的部分；并发清除则是清除不可达对象，回收空间。</p>
<p>&emsp;整个过程中，并发标记与并发清楚可以和用户线程一起工作，因此停顿时间只有初始标记和重新标记的过程，但时间并不长。</p>
<p>&emsp;CMS收集器的缺点是有空间碎片产生，无法处理浮动垃圾以及对CPU资源十分敏感。</p>
<h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>&emsp;G1收集器主要应用在Server端。它将对划分为多个大小相等的独立区域，新生代和老年代不再物理隔离。它会跟踪每个区域垃圾堆积的大小，维护一个优先列表，回收时回收价值最大的区域。运作工程包括初始标记，并发标记，最终标记，筛选回收。由于可以控制回收多少块区域，因此可以得到一个<strong>可预测的停顿时间</strong>。</p>
<h1 id="对象内存分配"><a href="#对象内存分配" class="headerlink" title="对象内存分配"></a>对象内存分配</h1><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><ul>
<li>对象优先在新生代的Eden分配</li>
<li>大对象直接进入老年代</li>
<li>长期存活的对象进入老年代，可以设定年龄阈值或者动态年龄判断</li>
</ul>
<h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><p>&emsp;在堆上为对象分配内存是，如果内存是绝对规整的，可以使用<strong>指针碰撞</strong>，直接让指针偏移出对象内存大小即可。如果内存不规则，需要维护一个<strong>空闲列表</strong>，从列表中选择能满足对象内存需求的内存块分配给对象。</p>
<p>&emsp;对象在分配时，也需要保证线程的安全，通常本地线程会预先分到一块内存空间作为<strong>本地线程缓冲</strong>，该线程创建的对象都在这块空间内分配，当缓冲用完后，需要申请新的空间时才需要同步锁定。</p>
<h1 id="Minor-GC-与-Full-GC"><a href="#Minor-GC-与-Full-GC" class="headerlink" title="Minor GC 与 Full GC"></a>Minor GC 与 Full GC</h1><p>&emsp;Minor GC 主要回收新生代的空间，Major GC 主要回收老年代空间，Full GC 回收老年代与新生代与元空间。</p>
<p>&emsp;触发full gc 的条件：</p>
<ul>
<li>调用System.gc() 方法，但是不一定会执行</li>
<li>老年代空间不足</li>
<li>空间分配担保失败</li>
<li>永久代( jdk 1.7 之前) 或 元空间不足</li>
<li>CMS GC 发生错误</li>
</ul>
<h1 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h1><p>&emsp;对象被回收时，如果对象覆盖了Object类的finalize()方法，虚拟机会在回收前执行对象的finalize()方法，但是不保证什么时候开始执行，也并不保证一定会执行完这个方法。</p>
]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>虚拟机</tag>
        <tag>垃圾收集</tag>
      </tags>
  </entry>
  <entry>
    <title>IoC容器</title>
    <url>/2020/07/18/IoC%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Spring-Boot-IoC"><a href="#Spring-Boot-IoC" class="headerlink" title="Spring Boot IoC"></a>Spring Boot IoC</h1><p>IoC 是一种通过描述生成或者获取对象的技术，IoC 容器需要具备两个功能：</p>
<ul>
<li>通过描述管理 Bean，包括发布和获取 Bean</li>
<li>通过描述完成 Bean 之间的依赖关系<a id="more"></a>
</li>
</ul>
<h2 id="IoC-容器简介"><a href="#IoC-容器简介" class="headerlink" title="IoC 容器简介"></a>IoC 容器简介</h2><p>Spring IoC 容器是一个管理 Bean 的容器，<strong>容器的顶级接口是 BeanFactory</strong>。在 BeanFactory 中主要定义了多个 getBean 方法，可以通过名称或类型从 IoC 容器中获取 Bean，这对于依赖注入是十分重要的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前缀</span></span><br><span class="line">    String FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>;</span><br><span class="line">    <span class="comment">// 多个获得bean的方法</span></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    <span class="comment">// 获得 bean 的对象工厂</span></span><br><span class="line">    &lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(Class&lt;T&gt; requiredType)</span></span>;</span><br><span class="line">    &lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(ResolvableType requiredType)</span></span>;</span><br><span class="line">    <span class="comment">// 判断是否包含 bean</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="comment">// 判断 bean 是否是单例</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">    <span class="comment">// 判断 bean 是否为原型</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">    <span class="comment">// 判断指定名称的bean是否和指定类型匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">    <span class="comment">// 获得 bean 的类型</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Class&lt;?&gt; getType(String name, <span class="keyword">boolean</span> allowFactoryBeanInit) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    <span class="comment">// 获得 bean 的别名</span></span><br><span class="line">    String[] getAliases(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BeanFactory 只是定义了 IoC 容器最基础的功能，Spring 中提供了功能更丰富的容器接口 ApplicationContext。它的继承图如下：</p>
<p><img src="https://raw.githubusercontent.com/LZH-SC/blogImages/master/img/20200718161022.png" alt=""></p>
<p>在继承图中 <code>ResourcePatternResolver</code> 是资源模式解析接口；<code>MessageSource</code> 是消息国际化接口；<code>EnvironmentCapable</code> 是环境可配置接口；<code>ApplicationEventPublisher</code> 是应用事件发布接口；<code>HierarchicalBeanFactory</code>定义了 BeanFactory 之间的分层功能，能过得父级 BeanFactory；<code>ListableBeanFactory</code>能列出当前容器中的所有 Bean。</p>
<p>在 Spring Boot 中，主要是通过注解装配 Bean 到 IoC 容器中，因此主要使用的是基于注解的 IoC 容器：<code>AnnotationConfigApplicationContext</code>,这个容器也是继承自 <code>ApplicationContext</code> 的</p>
<h2 id="装配自定义-Bean"><a href="#装配自定义-Bean" class="headerlink" title="装配自定义 Bean"></a>装配自定义 Bean</h2><p>在 Spring 中装配自定义的 Bean，有三种方式：自动扫描装配；JavaConfig 方式；xml方式，在 Spring Boot 中，很少使用 xml 方式。</p>
<h3 id="JavaConfig-方式"><a href="#JavaConfig-方式" class="headerlink" title="JavaConfig 方式"></a>JavaConfig 方式</h3><p><strong>通过 JavaConfig 的方式装配 Bean，主要依赖两个注解：<code>@Configuration</code> 以及 <code>@Bean</code></strong>，<code>@Configuration</code> 表示这是一个 Java 配置文件，Spring IoC 容器会根据它生成需要装配的 Bean，<code>@Bean</code> 表示将方法返回的对象装配到 IoC 容器中，其中的属性 name 可以定义 Bean 的名称，initMethod 定义初始化方法，destroyMethod 定义销毁方法。</p>
<p>新建一个 Spring Boot 项目，在其中新建一个类 People 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 省略其它代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建一个配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"people"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> People <span class="title">getPeople</span><span class="params">()</span></span>&#123;</span><br><span class="line">        People people = <span class="keyword">new</span> People();</span><br><span class="line">        people.setAge(<span class="number">100</span>);</span><br><span class="line">        people.setId(<span class="number">1</span>);</span><br><span class="line">        people.setName(<span class="string">"configPeople"</span>);</span><br><span class="line">        <span class="keyword">return</span> people;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后在单元测试中测试 Bean 是否已经被装配：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IocdemoApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    People people;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(people);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自动扫描装配"><a href="#自动扫描装配" class="headerlink" title="自动扫描装配"></a>自动扫描装配</h3><p><strong>自动扫描装配主要需要的注解是 <code>@Component</code> 以及 <code>@ComponentScan</code></strong>。<code>@Component</code> 注解标明哪个类被扫描进 Spring IoC 容器，<code>@ComponentScan</code> 注解标明采用什么策略去扫描装配 Bean。</p>
<p>修改 People 类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"2"</span>)</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"componentPeople"</span>)</span><br><span class="line">    String name;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"66"</span>)</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 省略其它代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 PeopleConfig 中的 <code>@Bean</code> 注解去掉，之后重新运行单元测试查看 Bean 是否已经被装配，因为项目启动文件的注解 <code>@SpringBootApplication</code> 中已经包含了 <code>@ComponentScan</code>，所以不需要再加上这个注解。</p>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>在之前单元测试代码中的注解 <code>@Autowired</code> 注解是一个依赖注入的注解，Spring Boot 还支持另一个注解 <code>@Resource</code>，两个注解的区别如下：</p>
<ul>
<li><code>@Resource</code> 是属于 J2EE 的，而 <code>@Autowired</code> 是 Spring 提供的。</li>
<li><code>@Autowired</code> 首先按照类型注入，如果对应类型的 Bean 不唯一，再根据属性名称与 Bean 的名称匹配，且默认不允许 Bean 不存在，可以使用 <code>@Autowired(required = false)</code> 允许 Bean 不存在。</li>
<li><code>@Resource</code> 默认按照名称注入，也支持按照类型注入。</li>
</ul>
<p>当某一个类型的 Bean 有多个时，有<strong>两个注解可以消除 <code>@Autowired</code> 的歧义，它们分别是 <code>@Primary</code> 和 <code>@Qualifier</code></strong>。</p>
<p>在定义 Bean 时加入 <code>@Primary</code> 注解，IoC 容器发现有多个同类型 Bean 时，会优先使用该注解的 Bean 注入。<code>@Qualifier</code> 注解与 <code>@Autowired</code> 注解结合使用，可以通过类型与名称寻找 Bean 注入。</p>
<p>另外，<strong>如果一个类的属性使用了 <code>@Autowired</code> 依赖注入，这个类也要使用 <code>@Component</code> 交给 IoC 容器管理依赖注入才会生效</strong>。</p>
<h2 id="Bean-生命周期"><a href="#Bean-生命周期" class="headerlink" title="Bean 生命周期"></a>Bean 生命周期</h2><h3 id="Spring-初始化-Bean"><a href="#Spring-初始化-Bean" class="headerlink" title="Spring 初始化 Bean"></a>Spring 初始化 Bean</h3><p>Spring 初始化 Bean 的流程如下所示：</p>
<p><img src="https://raw.githubusercontent.com/LZH-SC/blogImages/master/img/20200718174653.png" alt=""></p>
<p><strong>Spring 默认在发布 Bean 定义后立刻完成实例化和依赖注入，如果需要延迟初始化，可以在注入时添加注解 <code>@Lazy</code> 或者在 <code>@ComponentScan</code> 注解中全局配置 lazyInit 为 true</strong>。</p>
<h3 id="Bean作用域"><a href="#Bean作用域" class="headerlink" title="Bean作用域"></a>Bean作用域</h3><p>Bean 的作用域可以在配置 Bean 时使用注解 <code>@Scope</code> 定义作用域。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>作用域类型</th>
<th>使用范围</th>
<th>作用域描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>singleton</td>
<td>所有 Spring 应用</td>
<td>默认值</td>
</tr>
<tr>
<td>prototype</td>
<td>所有 Spring 应用</td>
<td>每当从 IoC 容器中取出 Bean，创建一个新的 Bean</td>
</tr>
<tr>
<td>session</td>
<td>所有 Spring Web 应用</td>
<td>HTTP 会话</td>
</tr>
<tr>
<td>application</td>
<td>所有 Spring Web 应用</td>
<td>Web 工程生命周期</td>
</tr>
<tr>
<td>request</td>
<td>所有 Spring Web 应用</td>
<td>Web 工程单次请求</td>
</tr>
<tr>
<td>globalSession</td>
<td>所有 Spring Web 应用</td>
<td>全局 HTTP Session 中，不常用</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Bean-生命周期-1"><a href="#Bean-生命周期-1" class="headerlink" title="Bean 生命周期"></a>Bean 生命周期</h3><p>Spring 完成依赖注入后，还会按照如下流程完成 Bean 的生命周期：</p>
<p><img src="https://raw.githubusercontent.com/LZH-SC/blogImages/master/img/20200718202244.png" alt=""></p>
<p>也就是说，在依赖注入之后，Bean的生命周期还包含以下流程</p>
<p>1.如果当前 Bean 实现了 BeanNameAware 接口，就调用它的 setBeanName方法。<br>2.如果当前 Bean 实现了 BeanFactoryAware 接口，就调用它的 setBeanFactory方法。<br>3.如果当前 Bean 实现了 ApplicationContextAware 接口，并且当前 IoC 容器是 ApplicationContext 的子类，就调用它的 setApplicationContext方法。<br>4.如果当前 IoC 容器中有实现了 BeanPostProcessor 接口的 Bean (不一定是当前 Bean)，就调用它的 postProcessBeforeInitialization 方法，对全体 Bean 生效。<br>5.如果当前 Bean 有自定义的初始化方法，就调用它。(@PostConstruct 标注的方法或者 @Bean 注解中 initMethod 指定的方法)<br>6.如果当前 Bean 实现了 InitializingBean 接口，就调用它的 afterPropertiesSet方法。<br>7.如果当前 IoC 容器中有实现了 BeanPostProcessor 接口的 Bean (不一定是当前 Bean)，就调用它的 postProcessAfterInitialization 方法，对全体 Bean 生效。<br>8.Bean 的正常使用。<br>9.当 Bean 需要销毁时，如果有自定义的销毁方法，就调用它。(@PreDestroy 标注的方法或者 @Bean 注解中 destroyMethod 指定的方法)<br>10.当 Bean 需要销毁时，如果实现了 DisposableBean 接口，就调用它的 destroy 方法。</p>
<p>下面通过一个例子来测试 Bean 的生命周期，对之前的 People 类加入生命周期的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"2"</span>)</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"componentPeople"</span>)</span><br><span class="line">    String name;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"66"</span>)</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;调用setBeanName"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;调用setBeanFactory"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;调用setApplicationContext"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myInit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;调用自定义初始化方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;调用afterPropertiesSet"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;调用自定义销毁方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;调用destroy方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其它代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建一个 MyBeanPostProcessor 类实现 BeanPostProcessor 接口测试它的全局性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用BeanPostProcessor的预初始化方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用BeanPostProcessor的后初始化方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行单元测试后，从控制台输出就可以观察 Bean 的生命周期。</p>
<h2 id="条件装配"><a href="#条件装配" class="headerlink" title="条件装配"></a>条件装配</h2><p>有时候一些客观因素会造成一些 Bean 无法初始化，为了处理这样的行为，Spring 提供了 <code>@Conditional</code> 实现条件装配，这个注解需要配合 <code>Condition</code> 接口来实现条件装配的功能。</p>
<p>新建一个 Book 类，配置为只有配置文件中有它的信息时才装配它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Conditional</span>(BookConditional<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConfigurationProperties</span>(<span class="title">prefix</span> </span>= <span class="string">"book"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="comment">// 省略其它代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建对应的实现了 Condition 接口的 BookConditional 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookConditional</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法返回 true 则装配 Bean，否则不装配</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得环境配置</span></span><br><span class="line">        Environment environment = conditionContext.getEnvironment();</span><br><span class="line">        <span class="comment">// 判断环境配置中是否有相应的配置</span></span><br><span class="line">        <span class="keyword">return</span> environment.containsProperty(<span class="string">"book.name"</span>) &amp;&amp; environment.containsProperty(<span class="string">"book.id"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后可以通过单元测试分别观察在 application.properties 中不配置与配置相关信息的结果。</p>
<h2 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h2><p><code>@Profile</code> 注解能够指定 Bean 在哪一个开发环境下装配，它的本质也是通过条件装配实现的。源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional</span>(&#123;ProfileCondition<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">Profile</span> </span>&#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ProfileCondition</code> 源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProfileCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    ProfileCondition() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得所有指定的 profile </span></span><br><span class="line">        MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        <span class="keyword">if</span> (attrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Iterator var4 = ((List)attrs.get(<span class="string">"value"</span>)).iterator();</span><br><span class="line"></span><br><span class="line">            Object value;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 没有匹配的 profile，返回 false</span></span><br><span class="line">                <span class="keyword">if</span> (!var4.hasNext()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                value = var4.next();</span><br><span class="line">                <span class="comment">// 如果当前环境是指定的某一个 profile 则退出循环返回 true</span></span><br><span class="line">            &#125; <span class="keyword">while</span>(!context.getEnvironment().acceptsProfiles(Profiles.of((String[])((String[])value))));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 指定的profile为空则在任何情况下都能装配</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring 还提供了几个方便使用的的条件装配注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnBean</span>         <span class="comment">// 当给定的在bean存在时,则实例化当前Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>  <span class="comment">// 当给定的在bean不存在时,则实例化当前Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>        <span class="comment">// 当给定的类名在类路径上存在，则实例化当前Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass</span> <span class="comment">// 当给定的类名在类路径上不存在，则实例化当前Bean</span></span><br></pre></td></tr></table></figure>
<h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><p>循环依赖就是指多个 bean 之间循环注入，例如：A 依赖 B， B 依赖 A。发生循环依赖时代码设计问题较大，最好能重构代码。</p>
<p>如果是构造器参数导致的循环依赖，有两种解决方法：1.可以通过延迟加载解决，在其中一个构造器参数上使用 <code>@Lazy</code> 注解即可。2.将构造器依赖注入改为 setter 注入。</p>
<p><strong>以上解决方法是针对单例模式的 Bean</strong>，因为单例模式下，所有正在创建还未设置属性的 Bean 都放入了缓存中，通过这个缓存解决了循环依赖的问题，而在原型模式下，Spring 不进行缓存，所以循环依赖问题依旧无法解决。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
        <tag>IoC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java序列化</title>
    <url>/2020/06/26/Java%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a>Serializable 接口</h1><p>&emsp;序列化是指将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象 。</p>
<a id="more"></a>
<p>&emsp;在 Java 中，想要将对象序列化，需要实现 Serializable 接口启用类的可序列化性，未实现此接口的类不支持序列化与反序列化操作，如果对象某个字段不需要序列化，可以用 transient 修饰该字段。 </p>
<h2 id="transient-关键字"><a href="#transient-关键字" class="headerlink" title="transient 关键字"></a>transient 关键字</h2><p>&emsp;在未实现 Serializable 接口的情况下对类进行序列化，会 java.io.NotSerializableException 异常，类在实现了 Serializable 接口后，就能启用默认的序列化机制，如果有不想被序列化的字段，可以用 transient 关键字修饰它。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">369L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// ...... 省略了其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">    ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"C:\\Users\\adam\\Desktop\\user"</span>));</span><br><span class="line">    User u = <span class="keyword">new</span> User(<span class="string">"a"</span>, <span class="number">1</span>);</span><br><span class="line">    out.writeObject(u);</span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"C:\\Users\\adam\\Desktop\\user"</span>));</span><br><span class="line">    User u2 = (User) in.readObject();</span><br><span class="line">    System.out.println(u2);</span><br><span class="line">    out.close();</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;代码运行结果：<code>User{name=&#39;null&#39;, age=1}</code>，可以看到，name 属性因为被标识为 transient 所以没有被序列化。</p>
<h2 id="writeObject-与-readObject"><a href="#writeObject-与-readObject" class="headerlink" title="writeObject 与 readObject"></a>writeObject 与 readObject</h2><p>&emsp;对于被 transient 标识的属性，在某些情况下如果需要序列化(例如 ArrayList )，则可以通过定义 writeObject(ObjectOutputStream s) 与 readObject(ObjectInputStream s) 自定义类的序列化，这两个方法被定义为 private 方法，但是通过单步调试可以发现，在序列化或者反序列化时，会直接运行到这两个方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">369L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        s.defaultReadObject() <span class="comment">// 自动反序列化对象中没有被transient修饰的字段</span></span><br><span class="line">        <span class="keyword">this</span>.name = (String) s.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        s.defaultWriteObject() <span class="comment">// 自动序列化对象中没有被transient修饰的字段</span></span><br><span class="line">        s.writeObject(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...... 省略了其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;将User类修改如上，再度运行 main 方法结果：<code>User{name=&#39;a&#39;, age=1}</code>，可以发现，被 transient 修饰的name字段也被序列化与反序列化了。在重写writeObject和readObject这两个方法时，一定要注意这两个方法的<strong>方法签名</strong>，另外<strong>写入顺序和读取顺序必须保持一致</strong>，否则会导致反序列化失败。</p>
<h2 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h2><p>&emsp;序列化运行时与每个可序列化类关联一个版本号，称为serialVersionUID，该版本号在反序列化期间用于验证序列化对象的发送方和接收方是否为该对象加载了与序列化兼容的类。如果接收方为具有不同于相应发送方的类的serialVersionUID的对象加载了一个类，那么反序列化将导致InvalidClassException。一个可序列化的类可以通过声明一个名为“serialVersionUID”的字段显式地声明它自己的serialVersionUID，<strong>该字段必须是静态的、final的和long类型的</strong>。</p>
<p>&emsp;如果对上面的 User 类先执行序列化代码，修改它的 serialVersionUID 后再执行反序列化代码，反序列化会失败，并抛出异常：<code>Exception in thread &quot;main&quot; java.io.InvalidClassException: serializedemo.User; local class incompatible: stream classdesc serialVersionUID = 369, local class serialVersionUID = 370</code>。</p>
<p>&emsp;另外，如果类中有包含有非基础数据类型的字段，该字段的类也应该实现 Serializable 接口，否则不能序列化。</p>
<h2 id="writeReplace-与-readResolve"><a href="#writeReplace-与-readResolve" class="headerlink" title="writeReplace() 与 readResolve()"></a>writeReplace() 与 readResolve()</h2><p>&emsp;定义 writeReplace() 方法后，当将对象序列化时，会将该方法返回的 Object 替代序列化对象。</p>
<p>&emsp;定义 readResolve() 方法后，当将对象反序列化时，会将该方法返回的 Object 替代反序列化对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">369L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"resolve"</span>, <span class="number">666</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...... 省略了其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;比如将User类修改如上，再度运行 main 方法结果：<code>User{name=&#39;resolve&#39;, age=666}</code>，可以发现，结果已经被替换掉了，这个方法可以用在一些单例模式里保证对象单例。</p>
<h2 id="readObjectNoData"><a href="#readObjectNoData" class="headerlink" title="readObjectNoData"></a>readObjectNoData</h2><p>&emsp;如果序列化流没有将给定的类列为被反序列化的对象的超类，readObjectNoData方法负责初始化其特定类的对象的状态。当接收方使用反序列化实例的类的版本与发送方不同，并且接收方的版本扩展了未被发送方版本扩展的类时，可能会发生这种情况。</p>
<p>&emsp;对上面的User类先执行序列化，然后让User类继承一个父类A，并且在 A 中实现 readObjectNoData 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObjectNoData</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">370L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// ......省略其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;之后再执行反序列化，结果：<code>User{name=&#39;a&#39;, age=1, id=100}</code>，可以看到，对于序列化时没有继承的父类，在反序列化时自动调用了它的 readObjectNoData 方法，可以设置父类属性的值。</p>
<h1 id="Externalizable-接口"><a href="#Externalizable-接口" class="headerlink" title="Externalizable 接口"></a>Externalizable 接口</h1><p>&emsp;该接口是 Serializable 接口的子接口，声明了两个方法 <code>void writeExternal(ObjectOutput out) throws IOException;</code> 与 <code>void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;</code>，通过实现这两个方法可以自定义类的序列化与反序列化。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类加载机制</title>
    <url>/2020/06/25/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="类生命周期"><a href="#类生命周期" class="headerlink" title="类生命周期"></a>类生命周期</h1><p>&emsp;在Java 虚拟机中，类的生命周期包括7个阶段：加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载。</p>
<a id="more"></a>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>&emsp;类的加载过程主要完成3件事：</p>
<ol>
<li>通过类的全限定名获取该类的二进制字节流，这个过程并没有规定从哪里获取，具有很大的操作空间。</li>
<li>将字节流的静态存储结构转为方法区或元空间的动态存储结构。</li>
<li>生成这个类的Class对象，作为该类各种数据的访问入口。</li>
</ol>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>&emsp;确保字节流中包含的信息符合虚拟机的要求，不会危害到虚拟机。主要包括文件格式验证，验证是否以魔数开头，版本号是否被虚拟机接收；元数据验证，验证类的方法，字段是否与父类矛盾；字节码验证，通过数据流与控制流分析，确定程序语义，不会危害虚拟机。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>&emsp;为类变量分配内存并设置默认零值，类变量是指 static 修饰的变量，如果类变量是常量，会初始化为定义的值。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>&emsp;将能替换的符号引用替换为直接引用，为了支持多态，有的符号引用在这个阶段不能被替换掉。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>&emsp;在这个阶段虚拟机会收集赋值语句与静态语句合并为一个clinit方法执行，为类的静态赋予正确的初始值。静态语句的顺序由源文件的顺序决定。</p>
<p>&emsp;执行一个类的clinit方法前，会先执行父类的clinit方法(故虚拟机中第一个执行的类是Object)，但是接口不需要，接口的实现类也不需要。只有接口中定义的变量使用时，才会执行接口的clinit方法。</p>
<p>&emsp;虚拟机会保证一个类的clinit方法在多线程环境下被正确的加锁和同步。</p>
<h1 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h1><h2 id="主动引用"><a href="#主动引用" class="headerlink" title="主动引用"></a>主动引用</h2><p>虚拟机规定在以下五种情况下，必须立即进行初始化：</p>
<ul>
<li>使用 new 关键字实例化对象时，访问类的静态字段，调用类的静态方法时。</li>
<li>使用java.lang.reflect 包的方法对类进行反射调用时。</li>
<li>初始化一个类时，它的父类还没有被初始化。</li>
<li>虚拟机启动时，包含 main() 方法的主类会先被初始化。</li>
<li>java.lang.invoke.MethodHandle 解析结果涉及静态字段与静态方法时，对应的类应该先被初始化。</li>
</ul>
<h2 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h2><p>处理主动引用外的所有引用方式都不会立即触发初始化，称为被动以用，比如：</p>
<ul>
<li>用过字类引用父类的静态字段，子类不会立即初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sytem.out.println(SubClass.value); <span class="comment">// value是父类的静态字段</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过数组定义引用类，不会触发类的初始化，会触发数组类的初始化，数组类是虚拟机自动生成的，包含了数组的属性和方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OneClass[] os = <span class="keyword">new</span> OneClass[<span class="number">100</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>引用一个类的常量也不会导致类的初始化，常量在编译阶段就存入常量池中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(OneClass.MAX_VALUE);</span><br></pre></td></tr></table></figure>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>&emsp;类加载器可以加载类，每一个类加载器都有独立的命名空间，对于任意一个类，它的<strong>类加载器和它本身确定唯一性</strong>。</p>
<h2 id="默认类加载器"><a href="#默认类加载器" class="headerlink" title="默认类加载器"></a>默认类加载器</h2><p>&emsp;启动类加载器 (Bootstrap ClassLoader)负责将存放在 JRE_HOME 下的lib目录中的指定类库加载，用户无法直接引用这个加载器，如果用户需要把加载请求委派给启动类加载器，用null代替即可。</p>
<p>&emsp;扩展类加载器负责加载指定扩展目录下的类库。</p>
<p>&emsp;应用程序类加载器，也叫系统类加载器，根据程序的类路径加载Java类，是程序默认的类加载器。用户自定义的加载器默认父加载器是应用程序类加载器。</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>&emsp;双亲委派模型要求除了顶层的启动类加载器外，所有加载器都有父类加载器，在收到类加载请求时，优先将请求委派给父加载器，父加载器无法处理时，子加载器才会自己加载类。这样做的好处是Java类随着它的类加载器具备一种天然的优先级层次。</p>
<h2 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h2><p>&emsp;线程上下文类加载器能打破双亲委派模型的桎梏，在一些场景十分有用，比如web服务器。通过Thread.currentThread.setContextClassLoader() 与 Thread.currentThread.getContextClassLoader() 使用线程上下文类加载器。</p>
]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>虚拟机</tag>
        <tag>类加载</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合Redis</title>
    <url>/2020/07/19/SpringBoot%E6%95%B4%E5%90%88Redis/</url>
    <content><![CDATA[<h1 id="Spring-Boot-整合-Redis"><a href="#Spring-Boot-整合-Redis" class="headerlink" title="Spring Boot 整合 Redis"></a>Spring Boot 整合 Redis</h1><p>Spring Boot 整合 Redis 十分方便，引入 redis 依赖自后配置 Redis 相关参数即可：</p>
<a id="more"></a>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>默认的 Redis 连接驱动是 Lettuce，Lettuce 是基于 NIO 编写的，性能与效果相比较 Jedis 更优秀。</p>
<p><strong>Spring 根据配置生成一个 RedisConnectionFactory 接口实现类，通过它可以生成一个 RedisConnection 接口对象来对 Redis 进行操作</strong>。</p>
<p><strong>为了更进一步简化开发流程，Spring 提供了 RedisTemplate 类，它会自动从 RedisConnectionFactory 中获取连接，然后执行 Redis 命令，之后自动关闭 Redis 连接</strong>。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>创建一个 Spring Boot 项目，引入 Redis 依赖后在配置文件中配置 Redis 相关信息：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="meta">spring.redis.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>
<p>然后新建一个 HelloController 内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/set"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();</span><br><span class="line">        ops.set(<span class="string">"name"</span>, <span class="string">"helloRedis"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/get"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();</span><br><span class="line">        System.out.println(ops.get(<span class="string">"name"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动项目后可以访问对应 url 测试 Redis 是否成功应用。</p>
<p><strong>上面代码中的 StringRedisTemplate 是 RedisTemplate 的子类，因为 RedisTemplate 默认序列化器是 JdkSerializationRedisSerializer，存入的是类对象序列化后的二进制字符串，使用体验很不好。 StringRedisTemplate 使用了 StringRedisSerializer 序列化器，这样能将数据从二进制字符串编码为简单字符串。但是 StringRedisTemplate 只提供了字符串序列化操作，对于复杂的 Java 对象需要自己实现 RedisSerializer 接口处理</strong>。</p>
<p>StringRedisTemplate 部分源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringRedisTemplate</span> <span class="keyword">extends</span> <span class="title">RedisTemplate</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringRedisTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置键序列化器</span></span><br><span class="line">        <span class="keyword">this</span>.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置值序列化器</span></span><br><span class="line">        <span class="keyword">this</span>.setValueSerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置散列结构的键序列化器</span></span><br><span class="line">        <span class="keyword">this</span>.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置散列结构的值序列化器</span></span><br><span class="line">        <span class="keyword">this</span>.setHashValueSerializer(RedisSerializer.string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Spring封装的数据类型操作"><a href="#Spring封装的数据类型操作" class="headerlink" title="Spring封装的数据类型操作"></a>Spring封装的数据类型操作</h2><p>Redis 支持7种数据类型，Spring 针对每一种都提供了操作接口：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口</th>
<th>获取接口</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>GeoOperations</td>
<td>redisTemplate.opsForGeo()</td>
<td>地理位置数据类型操作</td>
</tr>
<tr>
<td>HashOperations</td>
<td>redisTemplate.opsForHash()</td>
<td>散列数据类型操作</td>
</tr>
<tr>
<td>HyperLogLogOperations</td>
<td>redisTemplate.opsForHyperLogLog()</td>
<td>基数操作</td>
</tr>
<tr>
<td>ListOperations</td>
<td>redisTemplate.opsForList()</td>
<td>列表数据类型操作</td>
</tr>
<tr>
<td>SetOperations</td>
<td>redisTemplate.opsForSet()</td>
<td>集合数据类型操作</td>
</tr>
<tr>
<td>ZSetOperations</td>
<td>redisTemplate.opsForZSet()</td>
<td>有序集合数据类型操作</td>
</tr>
<tr>
<td>ValuerOperations</td>
<td>redisTemplate.opsForValue()</td>
<td>字符串数据类型操作</td>
</tr>
</tbody>
</table>
</div>
<p>在之前的例子中，使用了字符串数据类型的操作，如果需要操作其它数据类型，通过 API 获得相应接口即可。</p>
<h2 id="Spring-Cache-整合-Redis"><a href="#Spring-Cache-整合-Redis" class="headerlink" title="Spring Cache 整合 Redis"></a>Spring Cache 整合 Redis</h2><p>Spring 提供了缓存注解，进一步简化 Redis 的使用。</p>
<p>Spring 支持多种缓存的使用，提供了 CacheManager 接口与之相关的类，当使用 Redis 作为缓存时，主要使用 RedisCacheManager 管理缓存。</p>
<p>在配置文件中加入缓存配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 缓存名字</span></span><br><span class="line"><span class="meta">spring.cache.cache-names</span>=<span class="string">testCache</span></span><br><span class="line"><span class="comment"># 是否允许缓存空值</span></span><br><span class="line"><span class="meta">spring.cache.redis.cache-null-values</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 缓存key的前缀</span></span><br><span class="line"><span class="meta">spring.cache.redis.key-prefix</span>= <span class="string">keyPrefixTest</span></span><br><span class="line"><span class="comment"># 缓存超时时间戳，设置为0则永不过期，单位毫秒</span></span><br><span class="line"><span class="meta">spring.cache.redis.time-to-live</span>=<span class="string">60000</span></span><br><span class="line"><span class="comment"># 默认情况下会自动探测</span></span><br><span class="line"><span class="meta">spring.cache.type</span>=<span class="string">redis</span></span><br></pre></td></tr></table></figure>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>在启动文件上加入注解<code>@EnableCaching</code>，之后新建一个 User 类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", id="</span> + id +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后新建一个 UserService 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="comment">// 配置文件中配置的cacheNames</span></span><br><span class="line"><span class="meta">@CacheConfig</span>(cacheNames = <span class="string">"testCache"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;插入方法调用"</span>);</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;删除方法调用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CachePut</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">updateUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;更新方法调用"</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在单元测试中测试 getUserById 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisdemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userService.getUserById(<span class="number">1</span>);</span><br><span class="line">        userService.getUserById(<span class="number">1</span>);</span><br><span class="line">        userService.getUserById(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果显示只调用了一次 getUserById 方法，在 Redis 中查找存入的缓存结果：</p>
<p><img src="https://raw.githubusercontent.com/LZH-SC/blogImages/master/img/20200720002210.png" alt=""></p>
<p>从缓存结果可以看出，查询结果确实被放入缓存了，缓存名字冒号前面是配置文件中配置的前缀和 cacheNames 的拼接，冒号后面是参数的值(默认，可修改)。</p>
<p>接着测试 deleteUserById 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userService.deleteUserById(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>运行测试后可以查看 Redis 中缓存是否被删除。接着测试 updateUser 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="number">1</span>);</span><br><span class="line">        userService.updateUser(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>方法运行后查看 Redis 缓存如下：</p>
<p><img src="https://raw.githubusercontent.com/LZH-SC/blogImages/master/img/20200720002909.png" alt=""></p>
<p>发现结果与预想有出入，更新的缓存应该与查找的缓存名字一样，对 updateUser 方法做如下修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示取参数 user 的 id 属性做缓存名字</span></span><br><span class="line"><span class="meta">@CachePut</span>(key = <span class="string">"#user.id"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">updateUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;更新方法调用"</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>修改之后再次运行单元测试后查看缓存结果便正确了：</p>
<p><img src="https://raw.githubusercontent.com/LZH-SC/blogImages/master/img/20200720003237.png" alt=""></p>
<h3 id="自定义-KeyGenerator"><a href="#自定义-KeyGenerator" class="headerlink" title="自定义 KeyGenerator"></a>自定义 KeyGenerator</h3><p>新建一个 MyKeyGenerator 类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyKeyGenerator</span> <span class="keyword">implements</span> <span class="title">KeyGenerator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">generate</span><span class="params">(Object o, Method method, Object... objects)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改 UserService 类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="comment">// 引入自定义的 KeyGenerator</span></span><br><span class="line"><span class="meta">@CacheConfig</span>(cacheNames = <span class="string">"testCache"</span>,keyGenerator = <span class="string">"myKeyGenerator"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其它代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后重新在单元测试中测试 getUserById 方法后，查看 Redis 中的内容如下，可以发现缓存的 key 已经按照自定义的设置生成了。</p>
<p><img src="https://raw.githubusercontent.com/LZH-SC/blogImages/master/img/20200720004804.png" alt=""></p>
<h3 id="缓存注解总结"><a href="#缓存注解总结" class="headerlink" title="缓存注解总结"></a>缓存注解总结</h3><div class="table-container">
<table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>@EnableCaching</td>
<td>开启缓存注解</td>
</tr>
<tr>
<td>@CacheConfig</td>
<td>可以配置cacheNames，keyGenerator，cacheManager，cacheResolver</td>
</tr>
<tr>
<td>@Cacheable</td>
<td>先从缓存中查询结果，查询不到再执行方法，然后将方法结果放入缓存</td>
</tr>
<tr>
<td>@CachePut</td>
<td>将方法返回值放入缓存</td>
</tr>
<tr>
<td>@CacheEvict</td>
<td>移除缓存</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Java注解</title>
    <url>/2020/07/17/Java%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Java-注解"><a href="#Java-注解" class="headerlink" title="Java 注解"></a>Java 注解</h1><p>Java 注解从 Java5 开始提供，用于标识(让编译器检查代码)或者注入信息。Jdk 内置了一套注解，分为基本注解与元注解。<br><a id="more"></a></p>
<h2 id="基本注解"><a href="#基本注解" class="headerlink" title="基本注解"></a>基本注解</h2><p>基本注解在 java.lang 包下，主要有以下5个：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>注解</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Override</td>
<td>标识方法为重写方法，覆盖超类中声明的方法</td>
</tr>
<tr>
<td>@Deprecated</td>
<td>标识过时方法</td>
</tr>
<tr>
<td>@FunctionalInterface</td>
<td>标识函数式接口，让编译器检查接口定义是否符合函数式接口定义</td>
</tr>
<tr>
<td>@SuppressWarnings</td>
<td>抑制unchecked警告</td>
</tr>
<tr>
<td>@SafeVarargs</td>
<td>抑制堆污染警告</td>
</tr>
</tbody>
</table>
</div>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解是注解的注解，方便实现自定义注解的功能，主要包括以下几种：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>注解</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Retention</td>
<td>表示注解保留在源码，字节码或运行期，用枚举类 RetentionPolicy 表示保留的时期，默认是字节码时期</td>
</tr>
<tr>
<td>@Target</td>
<td>表示注解的作用范围，例如字段，方法等范围，通过枚举类 ElementType 表示</td>
</tr>
<tr>
<td>@Documented</td>
<td>将注解的元素包含到 Javadoc 中去</td>
</tr>
<tr>
<td>@Inherited</td>
<td>如果它修饰的注解修饰了一个父类，子类会继承父类的注解</td>
</tr>
<tr>
<td>@Repeatable</td>
<td>被它修饰的注解可以同时作用一个对象多次，每次注解可以代表不同的含义</td>
</tr>
<tr>
<td>@Native</td>
<td>表示一个字段可能涉及 native code</td>
</tr>
</tbody>
</table>
</div>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>注解本身是 Annotation 接口的子接口，<strong>注解中的属性相当于接口的方法</strong>，因此自定义注解中的属性需要带有括号。</p>
<p>注解中的属性类型可以有以下的类型：</p>
<ul>
<li>基本数据类型</li>
<li>String</li>
<li>枚举类型</li>
<li>注解类型</li>
<li>Class 类型</li>
<li>以上类型的数组</li>
</ul>
<p>一个自定义的注解如下所示，将 @Retention 注解的值设置为 RUNTIME，后续可以通过反射获取注解中的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "root"</span>;</span><br><span class="line">    <span class="function">String <span class="title">password</span><span class="params">()</span> <span class="keyword">default</span> "123456"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义注解注入信息"><a href="#自定义注解注入信息" class="headerlink" title="自定义注解注入信息"></a>自定义注解注入信息</h2><p>自定义注解后，可以通过反射将注解的属性注入到对象或方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation</span>(name = <span class="string">"testName"</span>, password = <span class="string">"123456"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMyAnnotation</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">"***"</span> + password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class clazz = Main<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Method method = clazz.getDeclaredMethod(<span class="string">"testMyAnnotation"</span>, String<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="keyword">boolean</span> annotationPresent = method.isAnnotationPresent(MyAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (annotationPresent) &#123;</span><br><span class="line">            MyAnnotation myAnnotation = (MyAnnotation) method.getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">// 获得该注解</span></span><br><span class="line">            <span class="comment">// 将注解的值注入方法参数中</span></span><br><span class="line">            method.invoke(<span class="keyword">null</span>, myAnnotation.name(), myAnnotation.password());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义注解注入对象"><a href="#自定义注解注入对象" class="headerlink" title="自定义注解注入对象"></a>自定义注解注入对象</h2><p>注解的属性只有上面提到的六种类型，有的时候需要注入的不仅仅是这六种类型数据，而是一个对象。注入对象相对比较麻烦。</p>
<p>定义一个 User 类，一个 InjectUser 注解与一个 UserDao，为UserDao注入User属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", password='"</span> + password + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> InjectUser &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">password</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过注解注入属性</span></span><br><span class="line">    <span class="meta">@InjectUser</span>(name=<span class="string">"testName"</span>, password = <span class="string">"testPassword"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"UserDao&#123;"</span> +</span><br><span class="line">                <span class="string">"user="</span> + user +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后修改 main 方法如下，为 UserDao 类注入 User 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 使用内省，获得 UserDao 中属性 user 的方法</span></span><br><span class="line">        PropertyDescriptor descriptor = <span class="keyword">new</span> PropertyDescriptor(<span class="string">"user"</span>, UserDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 创建注入的具体对象</span></span><br><span class="line">        User user = (User) descriptor.getPropertyType().newInstance();</span><br><span class="line">        <span class="comment">// 得到 UserDao 中 user 属性的写方法，即 setUser</span></span><br><span class="line">        Method method = descriptor.getWriteMethod();</span><br><span class="line">        <span class="comment">// 获得注解</span></span><br><span class="line">        Annotation annotation = method.getAnnotation(InjectUser<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 获得注解的属性</span></span><br><span class="line">        Method[] methods = annotation.getClass().getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">            String name = m.getName(); <span class="comment">// 得到注解属性的名字</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                PropertyDescriptor descriptor1 = <span class="keyword">new</span> PropertyDescriptor(name, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                Method method1 = descriptor1.getWriteMethod(); <span class="comment">// 得到 User 对象的属性的写方法</span></span><br><span class="line">                Object o = m.invoke(annotation, <span class="keyword">null</span>); <span class="comment">// 得到注解中的属性值</span></span><br><span class="line">                method1.invoke(user, o); <span class="comment">// 将注解中的属性值设置到 user 中去</span></span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        UserDao userDao = <span class="keyword">new</span> UserDao();</span><br><span class="line">        method.invoke(userDao, user); <span class="comment">// 调用 UserDao 的 setUser 方法设置对象即可</span></span><br><span class="line">        System.out.println(userDao.getUser());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java注解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis使用</title>
    <url>/2020/07/01/Redis%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>&emsp;Redis 是广泛应用的一个 NoSQL 数据库，基于 C 开发的键值对存储数据库，Redis一般用作缓存。但实际上 Redis 除了缓存之外，还有许多更加丰富的使用场景。比如 分布式锁，限流等。 </p>
<a id="more"></a>
<p>&emsp;Redis默认不支持远程连接，要开启远程连接，需要修改配置文件的两个地方：注释掉 bind 127.0.0.1 以及 开启密码校验，去掉 requirepass 的注释，修改自己的密码。</p>
<h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>&emsp;Jedis是 Redis 的 Java 客户端开发包之一，它的优点是 API 与 Redis 的原生 API 基本一致，不必花费时间再记忆 Jedis 的 API 使用。</p>
<h2 id="Jedis-连接-Redis"><a href="#Jedis-连接-Redis" class="headerlink" title="Jedis 连接 Redis"></a>Jedis 连接 Redis</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"192.168.43.196"</span>); <span class="comment">// redis地址，默认端口6379</span></span><br><span class="line">jedis.auth(<span class="string">"123456"</span>); <span class="comment">// 密码认证</span></span><br><span class="line">System.out.println(jedis.ping()); <span class="comment">// 返回PONG连接成功</span></span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure>
<p>&emsp;以上代码就是 Jedis 连接 Redis 的代码，连接上 Redis 之后，对 Redis 的各种操作例如 set，get 的 API 与 Redis 原生 API 一致。</p>
<h2 id="Jedis-连接池"><a href="#Jedis-连接池" class="headerlink" title="Jedis 连接池"></a>Jedis 连接池</h2><p>&emsp;Jedis 提供了连接池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JedisPool pool = <span class="keyword">new</span> JedisPool(<span class="string">"192.168.43.196"</span>); <span class="comment">// 创建一个连接池</span></span><br><span class="line"><span class="comment">// Jedis 实现了 Closable 接口</span></span><br><span class="line"><span class="keyword">try</span>(Jedis jedis = pool.getResource()) &#123; <span class="comment">// 获得一个连接并操作</span></span><br><span class="line">	jedis.auth(<span class="string">"123456"</span>);</span><br><span class="line">	System.out.println(jedis.ping());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;还可以使用 GenericObjectPoolConfig 类来配置连接池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JedisPool <span class="title">getJedisPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	GenericObjectPoolConfig config = <span class="keyword">new</span> GenericObjectPoolConfig();</span><br><span class="line">	config.setMaxIdle(<span class="number">300</span>); <span class="comment">// 最大空闲数</span></span><br><span class="line">	config.setMaxTotal(<span class="number">100</span>); <span class="comment">// 最大连接数</span></span><br><span class="line">	config.setMaxWaitMillis(<span class="number">20000</span>); <span class="comment">// 连接最大等待时间，-1表示无限制</span></span><br><span class="line">	config.setTestOnBorrow(<span class="keyword">true</span>); <span class="comment">// 空闲时检查有效性</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> JedisPool(config, <span class="string">"192.168.43.196"</span>, <span class="number">6379</span>, <span class="number">20</span>, <span class="string">"123456"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	JedisPool pool = getJedisPool();</span><br><span class="line">	<span class="keyword">try</span>(Jedis jedis = pool.getResource()) &#123;</span><br><span class="line">		System.out.println(jedis.ping());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="做分布式锁"><a href="#做分布式锁" class="headerlink" title="做分布式锁"></a>做分布式锁</h1><p>&emsp; Redis 除了用作缓存外，还可以用作分布式锁。当有多个线程竞争 key 时，利用分布式锁可以保证对 key 的操作的同步。</p>
<p>&emsp; 在 Redis 中，setnx 指令可以用来实现分布式锁，如果 key 不存在， 它会将 key 的 value 设置并返回1，如果 key 存在，则设置失败返回0。因此多线程竞争时，<strong>setnx 返回1则表示获得了锁，在操作完成后再将设置的 key 删除表示释放了锁</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JedisPool pool = getJedisPool();</span><br><span class="line"><span class="keyword">try</span>(Jedis jedis = pool.getResource())&#123;</span><br><span class="line">	Long setnx = jedis.setnx(<span class="string">"lock"</span>, <span class="string">"v"</span>);</span><br><span class="line">	<span class="keyword">if</span>(setnx == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">// 获得了锁，执行操作</span></span><br><span class="line">				</span><br><span class="line">		jedis.del(<span class="string">"lock"</span>); <span class="comment">// 操作完成后释放资源</span></span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 未获得锁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;但是以上的代码存在问题，如果线程在执行 del 指令之前挂掉了，这个锁就无法释放，后面的所有线程都无法再获得锁。要解决这个问题，最简单的想法是给锁添加过期时间。</p>
<p>&emsp;Redis 支持 setnx 和 expire 通过一个命令来执行：<code>SET key value [EX seconds][PX milliseconds] [NX|XX]</code>，其中，EX seconds 设置键过期时间为秒，PX milliseconds 设置键过期时间为毫秒，NX 表示只有在键不存在时才操作，XX 表示只有键存在时才操作，这个命令操作成功后返回 OK ，失败返回 NIL。例如 <code>SET lock 1 ex 10 nx</code>，表示只有 lock 键不存在时才操作，设置  lock 这个键的值为1，过期时间十秒。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JedisPool pool = getJedisPool();</span><br><span class="line"><span class="keyword">try</span>(Jedis jedis = pool.getResource())&#123;</span><br><span class="line">    <span class="comment">// SetParams类可以定义set指令参数</span></span><br><span class="line">	String result = jedis.set(<span class="string">"lock"</span>,<span class="string">"1"</span>, <span class="keyword">new</span> SetParams().ex(<span class="number">10</span>).nx());</span><br><span class="line">	<span class="keyword">if</span>(result.equals(<span class="string">"OK"</span>)) &#123;</span><br><span class="line">		<span class="comment">// 获得了锁，执行操作</span></span><br><span class="line">				</span><br><span class="line">		jedis.del(<span class="string">"lock"</span>); <span class="comment">// 操作完成后释放资源</span></span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 未获得锁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;但是以上代码依旧有问题，如果某个线程A的正常运行时间大于超时时间，那么该线程还没有执行完锁就被自动释放了，其它线程B就可以获得这个锁，线程B还未执行完，线程A就释放了线程B的锁，线程C又会获得这个锁。</p>
<p>&emsp;解决这个问题就是如果能判断加锁的线程是哪个线程，解锁的时候必须也是加锁线程才行，例如可以将 key 的 value 设置为随机字符串，每次释放锁都比较随机字符串是否是当前线程生成的，如果是，就可以释放，不是就不能释放。但是这样以来每次释放都需要获得 value，然后比较，然后再删除，三个步骤，不具有原子性。为了让其具有原子性，可以使用 Lua 脚本。</p>
<p>&emsp;如果不想编写 Lua 脚本，可以使用 Redission 库，这个库提供了额外的分布式锁的功能。</p>
<h1 id="做消息队列"><a href="#做消息队列" class="headerlink" title="做消息队列"></a>做消息队列</h1><p>&emsp;假如系统比较简单，可以直接使用 Redis 做消息队列，Redis 并不专业做消息队列，仅仅适合用在简单场景中。通过使用 Redis 的 List 数据结构，就可以实现消息队列。可以使用 List 的 blpop 或者 brpop 来实现阻塞式的读取消息。</p>
<p>&emsp;Redis中的 zset 数据结构则可以用来做延迟消息队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMQ</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool = MyJedis.getJedisPool();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span>(Jedis jedis = jedisPool.getResource())&#123;</span><br><span class="line">				<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">while</span>(!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">					<span class="comment">// 向 queue 这个zset中加入消息，延迟3秒</span></span><br><span class="line">					jedis.zadd(<span class="string">"queue"</span>, System.currentTimeMillis() + <span class="number">3000</span>, <span class="string">"msg----"</span> + i);</span><br><span class="line">					System.out.println(<span class="keyword">new</span> Date() + <span class="string">"放入消息-----"</span> + i++);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">500</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      					<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span>(Jedis jedis = jedisPool.getResource())&#123;</span><br><span class="line">				<span class="keyword">while</span>(!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">					Set&lt;String&gt; set = jedis.zrangeByScore(<span class="string">"queue"</span>, <span class="number">0</span>, System.currentTimeMillis());</span><br><span class="line">					<span class="keyword">if</span>(set.isEmpty()) &#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							Thread.sleep(<span class="number">500</span>);</span><br><span class="line">						&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">                      <span class="comment">// 获得集合中第一个元素</span></span><br><span class="line">					String message = set.iterator().next();</span><br><span class="line">                      <span class="comment">// 如果能删掉该元素，说明抢到了该消息</span></span><br><span class="line">					<span class="keyword">if</span>(jedis.zrem(<span class="string">"queue"</span>, message) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">						System.out.println(<span class="keyword">new</span> Date() + <span class="string">"收到了消息--------"</span> + message);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		Thread p = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer());</span><br><span class="line">		Thread c = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer());</span><br><span class="line">		p.start();</span><br><span class="line">		c.start();</span><br><span class="line">		Thread.sleep(<span class="number">8000</span>);</span><br><span class="line">		p.interrupt();</span><br><span class="line">		c.interrupt();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h1><p>&emsp;Redis 中对字符串的操作可以使用位操作，例如保存一个用户一年的签到记录，如果利用位操作来做，只需要365个比特就能完全记录下来，在用户量较大的情况下节省了大量空间。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常用操作</span></span><br><span class="line">setbit key offset value  # 设置key的值中的某一位</span><br><span class="line">getbit key offset   # 获取key的值中的某一位</span><br><span class="line">bitcount key [start end]   # 统计key的值的二进制表示的1的数量，start与end是字符的位置，不是比特位的位置</span><br><span class="line">bitpos key bit [start] [end] # 统计起始位置的0或者1的数量，起始位置也是字符的位置  </span><br><span class="line">bitfield  # 批量位操作</span><br></pre></td></tr></table></figure>
<h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><p>&emsp;HyperLogLog 是用来做<strong>基数统计</strong>的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。但是，因为 HyperLogLog 只会根据输入元素来计算基数，而<strong>不会储存输入元素本身</strong>，所以 HyperLogLog 不能像集合那样，返回输入的各个元素 。 </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常用操作</span></span><br><span class="line">PFADD key element [element ...] # 添加指定元素到 HyperLogLog 中。</span><br><span class="line">PFCOUNT key [key ...] # 返回给定 HyperLogLog 的基数估算值。</span><br><span class="line">PFMERGE destkey sourcekey [sourcekey ...] # 将多个 HyperLogLog 合并为一个 HyperLogLog</span><br></pre></td></tr></table></figure>
<p>&emsp;HyperLogLog 提供了一套不怎么精确但是够用的去重方案，<strong>会有误差</strong>。例如下列代码输出结果5037，并不完全准确。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	JedisPool pool = MyJedis.getJedisPool();</span><br><span class="line">	<span class="keyword">try</span>(Jedis jedis = pool.getResource())&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)</span><br><span class="line">			jedis.pfadd(<span class="string">"count"</span>, <span class="string">"test"</span> + i);</span><br><span class="line">		System.out.println(jedis.pfcount(<span class="string">"count"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p>&emsp;布隆过滤器相当于是一个不太精确的 set 集合，我们可以利用它里边的 contains 方法去判断某一个对象是否存在，但是这个判断不是特别精确。一般来说，通过 contains 判断某个值不存在， 那就一定不存在，但是判断某个值存在的话，则他可能不存在 。   </p>
<p>&emsp;布隆过滤器需要一个巨大的位数组和几个 hash 函数，它的 add 操作相当于对元素分别求出几个 hash 值，将位数组上 hash 值对应的位置设置为1即可。判断一个元素是否存在时，求出这个元素的几个 hash 值，如果它们对应的位都是1，表示这个元素存在，否则，这个元素不存在。因此布隆过滤器可能存在误判，一般位数组越大，误判率越小，占用空间越大。</p>
<h1 id="Redis限流"><a href="#Redis限流" class="headerlink" title="Redis限流"></a>Redis限流</h1><p>&emsp;Redis也可以利用 zset 数据结构作限流，<strong>key 与请求有关，分数保存为请求的时间戳，这样，利用 zrangeByScore 可以求出某一段时间内的请求数量</strong>，当某个时间段内的请求数量达到一定数量，就拒绝其它访问。能够保证每 N 秒至多有 M 个访问能通过。</p>
<h1 id="GeoHash"><a href="#GeoHash" class="headerlink" title="GeoHash"></a>GeoHash</h1><p>&emsp;GeoHash是一种地址编码方式，将二维空间的经纬度编码为一个字符串。它表示的是<strong>一块区域</strong>而不是一个特定的点。例如某地经纬度为(40，116)</p>
<ol>
<li><p>纬度的范围在 (-90,90) 之间，中间值为 0，对于 39.9053908600 值落在 (0,90),因此得到的值为 1 </p>
</li>
<li><p>(0,90) 的中间值为 45，39.9053908600 落在 (0,45) 之间，因此得到一个 0 </p>
</li>
<li><p>(0,45) 的中间值为 22.5，39.9053908600 落在 (22.5,45)之间，因此得到一个 1</p>
</li>
<li><p>……</p>
</li>
</ol>
<p>&emsp;最后计算出的纬度二进制是 101，经度二进制是110，之后按照经度占偶数位，纬度占奇数位合并，结果为111001，然后按照 Base32 （0-9,b-z,去掉 a i l 0）对合并后的二进制数据进行编码，编码的时候，先将二进制转换为十进制，然后进行编码。</p>
<p>&emsp;这种编码格式有特定的规律，例如一个地址编码之后的格式是 123，另一个地址编码之后的格式是 123456， 从字符串上就可以看出来，123456 表示的区域处于 123 表示的区域之中。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>&emsp;Redis 中的事务并不是严格的事务，它只保证了隔离性，即事务不会被其它事务打断，并不保证原子性。Redis 事务对应的指令有 watch，multi，exec，discard。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">multi</span><br><span class="line">set k1 v1</span><br><span class="line">set k2 v2</span><br><span class="line">get k2</span><br><span class="line">incr k2</span><br><span class="line">get k2</span><br><span class="line">exec</span><br><span class="line"><span class="comment">// 以上命令执行后结果</span></span><br><span class="line"><span class="number">1</span>) OK</span><br><span class="line"><span class="number">2</span>) OK</span><br><span class="line"><span class="number">3</span>) <span class="string">"v2"</span></span><br><span class="line"><span class="number">4</span>) (error) ERR value is not an integer or out of range</span><br><span class="line"><span class="number">5</span>) <span class="string">"v2"</span></span><br></pre></td></tr></table></figure>
<p>&emsp;可以看到，虽然事务中有一条指令出现了错误，但是并没有像 MySQL 一样整个事务都被回滚了。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Jedis</tag>
      </tags>
  </entry>
  <entry>
    <title>Jdk 动态代理</title>
    <url>/2020/06/29/Jdk-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>&emsp;所谓代理模式，就是为其它对象提供一个代理来控制对目标对象的访问，代理类不实现具体的服务，利用委托类来完成服务。</p>
<a id="more"></a>
<h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>&emsp;静态代理十分简单。创建一个接口，然后创建被代理的类实现该接口并且实现该接口中的抽象方法。之后再创建一个代理类，同时使其也实现这个接口。在代理类中持有一个被代理对象的引用，而后在代理类方法中调用该对象的方法 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设计一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String s)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被代理类实现该接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String s)</span> <span class="keyword">throws</span> IllegalArgumentException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数不合法"</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类也实现该接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloStaticProxy</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    Hello hello; <span class="comment">// 被代理的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloStaticProxy</span><span class="params">(Hello hello)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hello = hello; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String s)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before method invoke"</span>);</span><br><span class="line">        String re = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isException = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.hello.say(s);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IllegalArgumentException e)&#123;</span><br><span class="line">            isException = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"after method invoke"</span>);</span><br><span class="line">        <span class="keyword">if</span>(isException)</span><br><span class="line">            System.out.println(<span class="string">"after method throw Exception"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Hello hello = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">        Hello proxy = <span class="keyword">new</span> HelloStaticProxy(hello); <span class="comment">// 将被代理对象传入新建一个代理对象</span></span><br><span class="line">        proxy.say(<span class="keyword">null</span>);  <span class="comment">// 代理类在执行具体方法时通过所持用的被代理类完成调用</span></span><br><span class="line">        System.out.println(<span class="string">"------------------"</span>);</span><br><span class="line">        proxy.say(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;以上代码运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">before method invoke</span><br><span class="line">after method invoke</span><br><span class="line">after method throw Exception</span><br><span class="line">------------------</span><br><span class="line">before method invoke</span><br><span class="line">hello</span><br><span class="line">after method invoke</span><br></pre></td></tr></table></figure>
<p>&emsp;这样，当需要代理一个类的时候，只要编写一个该类的静态代理对象即可，但是，如果需要代理的对象很多，就需要编写大量的代理类，十分麻烦 。</p>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>&emsp;动态代理能够利用反射机制在程序运行期间生成代理类。在 java.lang.reflect 包下的 Proxy 类有一个静态方法 newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)，通过该方法可以获得动态代理类。它需要一个类加载器，类的接口数组，以及一个实现 InvocationHandler 接口的类。</p>
<p>&emsp; InvocationHandler 中只声明了一个方法：Object invoke(Object proxy, Method method, Object[] args) throws Throwable ，通过这个方法，可以调用被代理类的方法，需要注意，<strong>invoke 参数中的 proxy 表示的是代理对象，而不是被代理对象</strong>，因此 method.invoke() 传入的参数不能是它，否则会循环调用。</p>
<p>&emsp;上面的接口与接口实现类不变，创建一个实现了 InvocationHandler 的类完成动态代理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    Object target; <span class="comment">// 被代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyProxyHandler</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before method invoke"</span>);</span><br><span class="line">        Object re = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isException = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            re = method.invoke(target, args); <span class="comment">// 调用被代理对象的方法</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            isException = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"after method invoke"</span>);</span><br><span class="line">        <span class="keyword">if</span>(isException) &#123;</span><br><span class="line">            System.out.println(<span class="string">"after method throw Exception"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Hello hello = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">        Hello helloProxy = (Hello)Proxy.newProxyInstance(hello.getClass().getClassLoader(),</span><br><span class="line">                hello.getClass().getInterfaces(), <span class="keyword">new</span> MyProxyHandler(hello));</span><br><span class="line">        helloProxy.say(<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line">        helloProxy.say(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">before method invoke</span><br><span class="line">after method invoke</span><br><span class="line">after method throw Exception</span><br><span class="line">-----------------</span><br><span class="line">before method invoke</span><br><span class="line">hello</span><br><span class="line">after method invoke</span><br></pre></td></tr></table></figure>
<p>&emsp;jdk动态代理必须要依靠接口实现，因为<strong>生成的代理类是 Proxy 的子类</strong>，而 Java 不允许多继承，所以需要接口来连接代理类与被代理类。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot配置文件</title>
    <url>/2020/07/17/SpringBoot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="Spring-Boot-配置文件"><a href="#Spring-Boot-配置文件" class="headerlink" title="Spring Boot 配置文件"></a>Spring Boot 配置文件</h1><p>在 Spring Boot 中，有两种配置文件：一种是 properties，一种是 yaml。两种的区别主要在于 yaml 的数据是有序的， properties 的数据是无序的。另外， yaml 配置文件不支持 @PropertySource 注解。<br><a id="more"></a></p>
<h2 id="配置文件位置"><a href="#配置文件位置" class="headerlink" title="配置文件位置"></a>配置文件位置</h2><p>Spring Boot 默认有以下4个地方可以存放配置文件，优先级依次降低：</p>
<ul>
<li>当前项目根目录下的 config 目录</li>
<li>当前项目根目录</li>
<li>resources 目录下的 config 目录</li>
<li>resources 目录</li>
</ul>
<p>如果配置文件所在的目录或名称不是默认的，需要在项目启动时指定配置文件。</p>
<h2 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h2><p>Spring Boot 支持配置文件属性注入，新建一个 Spring Boot 项目，在 application.properties 文件中中添加如下配置:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">book.name</span>=<span class="string">aaaa</span></span><br><span class="line"><span class="meta">book.id</span>=<span class="string">100</span></span><br><span class="line"><span class="meta">book.author</span>=<span class="string">tt</span></span><br></pre></td></tr></table></figure>
<p>新建一个 Book 类如下，@Component 注解将 Book 交给 Spring IoC容器管理，@Value 注解为 Book 类的字段注入配置文件中的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;book.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;book.id&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;book.author&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="comment">// 省略了其它代码....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过单元测试测试注入是否成功：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropertiesdemoApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Book book;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>application.properties 主要存放系统配置，可以新建一个 book.properties 配置文件存放自定义的 book 配置，配置内容与原来一样，之后，在 Book 类上通过注解 @PropertySource 指定配置文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:book.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;book.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;book.id&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;book.author&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="comment">// 省略了其它代码....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型安全的属性注入"><a href="#类型安全的属性注入" class="headerlink" title="类型安全的属性注入"></a>类型安全的属性注入</h2><p>当属性较多时，这种一个一个属性注入的方式比较麻烦，而且容易出错，可以使用类型安全的属性注入，通过 @ConfigurationProperties 注解，指定 prefix 字段即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:book.properties"</span>)</span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"book"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="comment">// 省略了其它代码....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外， @ConfigurationProperties 注解还支持JSR303数据校验，松散绑定等功能。</p>
<h2 id="引入-xml-配置文件"><a href="#引入-xml-配置文件" class="headerlink" title="引入 xml 配置文件"></a>引入 xml 配置文件</h2><p>如果想引入 xml 配置文件，可以使用 @ImportResource 注解。</p>
<p>在 resources 目录下新建 book.xml 文件如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"book"</span> <span class="attr">class</span>=<span class="string">"top.liuzhenhui.propertiesdemo.Book"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"bookName"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">value</span>=<span class="string">"bookAuthor"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"111"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改 Book 类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String name, <span class="keyword">int</span> id, String author)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略了其它代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在启动程序引入 xml 配置文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ImportResource</span>(<span class="string">"classpath:book.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesdemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PropertiesdemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行单元测试，发现确实已经生成了 xml 中定义的 Bean。</p>
<h2 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h2><p>为了方便切换不同的开发环境，配置文件的名称可以是 application-{profile}.properties/yml，然后在 application.properties 中指定环境，项目启动时会去读取相应的配置文件。</p>
<p>在 resources 目录下分别创建 application-dev.properties 与 application-test.properties 如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># application-dev.properties 文件内容</span></span><br><span class="line"><span class="meta">book.name</span>=<span class="string">devName</span></span><br><span class="line"><span class="meta">book.id</span>=<span class="string">222</span></span><br><span class="line"><span class="meta">book.author</span>=<span class="string">devAuthor</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># application-test.properties 文件内容</span></span><br><span class="line"><span class="meta">book.name</span>=<span class="string">testName</span></span><br><span class="line"><span class="meta">book.id</span>=<span class="string">99</span></span><br><span class="line"><span class="meta">book.author</span>=<span class="string">testAuthor</span></span><br></pre></td></tr></table></figure>
<p>在启动方法上去掉之前的 @ImportResource 注解，然后修改 Book 类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"book"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="comment">// 省略其它代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在 application.properties 文件中指定环境:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spring.profiles.active=dev</span></span><br><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">test</span></span><br></pre></td></tr></table></figure>
<p>通过单元测试可以知道确实根据 application.properties 中的配置切换了读取的配置文件。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
        <tag>配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2020/06/24/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="部分背包问题"><a href="#部分背包问题" class="headerlink" title="部分背包问题"></a>部分背包问题</h1><p>&emsp;部分背包问题即装入背包的物品可分割，可以用简单的贪心算法解决，物品平均价值由高到低排序，依次放入背包，直到放不下。<br><a id="more"></a></p>
<p>&emsp;例如：有一堆金粉，银粉，铜粉和铁粉，用一个固定大小的袋子去装，只要从平均价值最大的金粉开始装，装完后装下一堆平均价值最大的物品，直到袋子装满为止即可。</p>
<h1 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>&emsp;有N件物品，第 i 件物品重Ci，价值Wi，你有一个能装重量V的背包，每件物品只有一个，你需要装入哪些物品才能使背包内的价值总和最大？</p>
<h2 id="动态规划公式"><a href="#动态规划公式" class="headerlink" title="动态规划公式"></a>动态规划公式</h2><p>&emsp;定义dp[i, v]表示将前 i 件物品放入容量为 v 的背包可以获得最大价值总和，那么在这个情况下，有两种可能，要么第 i 件物品放入了背包内， 要么第 i 件物品没有放入背包内。</p>
<p>&emsp;如果第 i 件物品没有放入背包内，相当于<strong>dp[i, v] = dp[i - 1, v]</strong>，即将前面 i - 1件物品放入容量为v的背包中的最大价值总和。</p>
<p>&emsp;如果第 i 件物品放入了背包内，相当于<strong>dp[i, v] = dp[i - 1, v - Ci] + Wi</strong>，因为第 i 件物品放入了背包，所以相当于前面 i - 1 件物品占用v - Ci的空间的最大价值总和再加上第 i 件物品的价值。</p>
<p>&emsp;但是两种可能只能选择一种，价值最大的那种，所以01背包的递推公式为：<strong>dp[i, v] = max{dp[i - 1, v], dp[i - 1, v - Ci] + Wi}</strong></p>
<h2 id="解法与优化"><a href="#解法与优化" class="headerlink" title="解法与优化"></a>解法与优化</h2><p>&emsp;既然已经得到了递推公式，根据递推公式不断计算，最终算到<code>dp[N, V]</code>就是问题的答案了，可以创建一个二维数组计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bagProblem</span><span class="params">(<span class="keyword">int</span>[] C, <span class="keyword">int</span>[] W, <span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> dp[C.length + <span class="number">1</span>][V + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C.length; i++)&#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> j = C[i]; j &lt;= V; j++)&#123;</span><br><span class="line">        	dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - C[i]] + W[i]);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;   </span><br><span class="line">    <span class="keyword">return</span> dp[C.length][[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;从代码中不难看出，二维数组在计算过程中是逐行计算的，并且第 i 行的数据只依赖于第 i - 1行的数据，因此前面已经计算过的行其实已经无用了，可以删掉它们优化空间。最佳的优化下，可以只使用一维数组来计算。<br>&emsp;只用一维数组来计算的关键点在于，每一行数据在计算的时候，都依赖前面已经计算的元素，依赖于前面的 j - C[i]位置上的元素，<strong>如果依旧从前到后依次计算，拿到的这个位置的元素的值就是错的。所以这个时候需要从后到前计算</strong>，这样就能保证每次取 j - C[i]位置上的元素，都是上一次计算的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bagProblem</span><span class="params">(<span class="keyword">int</span>[] C, <span class="keyword">int</span>[] W, <span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> dp[V + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = V; j &gt;= C[i]; j--)&#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - C[i] + W[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[V];                                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;另外，在这个代码中，可以抽象出处理一件01背包问题的代码作为一个函数调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zeroOneBag</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> c, <span class="keyword">int</span> V, <span class="keyword">int</span>[] dp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = V; j &gt;= c; j--)</span><br><span class="line">    	dp[j] = Math.max(dp[j], dp[j - c] + w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bagProblem</span><span class="params">(<span class="keyword">int</span>[] C, <span class="keyword">int</span>[] W, <span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> dp[V + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C.length; i++)</span><br><span class="line">    	zeroOneBag(W[i], C[i], V, dp);</span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>&emsp;完全背包问题与01背包问题唯一的区别在于，每一种物品都有无限多个，可以拿0个，1个，任意个。很显然，直觉上看，这种情况下问题的复杂性十分高，可能的情况实在太多。</p>
<h2 id="动态规划公式推导"><a href="#动态规划公式推导" class="headerlink" title="动态规划公式推导"></a>动态规划公式推导</h2><p>&emsp;完全背包问题的递推式如下所示：</p>
<p>&emsp;  dp[i, j] = max( dp[i - 1, j - k<em>C[i] ] + k </em> W[i] )  其中 0 &lt;= k &lt;= V/C[i]       (1)</p>
<p>&emsp;即利用穷举的方式从不拿第 i 件物品到拿第 i 件物品装满背包都试一遍，看哪一种方案价值更大就选择哪一种方案。对于这种思路，就是将完全背包问题转化为01背包问题来求解，也有一些优化手段，比如如果两件物品 i 与 j 满足 C[i]  &lt;= C[j] &amp;&amp; W[i] &gt;= W[j]， 那么可以直接不用考虑 j 物品，因为每个物品可以拿无限多个，所以用价值高费用小的 i 替换 j 是显然不亏的。再比如用二进制编码的思想降低复杂度。</p>
<p>&emsp;但是，通过完全背包问题的递推式推导，却可以得到一个简单易懂的解决方法：</p>
<p>&emsp;完全背包问题递推式可以写成：</p>
<p>&emsp; dp[i, j] = max( dp[i - 1, j], dp[i - 1, j - k<em>C[i]] + k </em> W[i] )  其中 1 &lt;= k &lt;= V/C[i]       (2)</p>
<p>&emsp;由(1)式可得：</p>
<p>&emsp; dp[i, j - C[i]] = max( dp[i - 1, j - C[i] - k<em>C[i]] + k </em> W[i] )  其中 1 &lt;= k + 1 &lt;= V/C[i]   </p>
<p>&emsp; dp[i, j - C[i]] = max( dp[i - 1, j - (k + 1)<em>C[i]] + (k + 1) </em> W[i] - W[i] )  其中 1 &lt;= k + 1 &lt;= V/C[i]</p>
<p>&emsp;令 m = k + 1 则可推导出：</p>
<p>&emsp; dp[i, j - C[i]] = max( dp[i - 1, j - m<em>C[i]] + m </em> W[i] - W[i] )  其中 1 &lt;= m&lt;= V/C[i] </p>
<p>&emsp;故可以得到：</p>
<p>&emsp; dp[i, j - C[i]] + W[i] = max( dp[i - 1, j - m<em>C[i]] + m </em> W[i] )   其中 1 &lt;= m &lt;= V/C[i]       (3)</p>
<p>&emsp;将(3)代入(2)中有：</p>
<p>&emsp; dp[i, j] = max( dp[i - 1, j], dp[i, j - C[i]] + W[i] ) </p>
<p>&emsp;最终的这个公式与01背包的递推式相比较只有一处不同，而且由01背包需要逆序求解容易推导出，完全背包问题只需正序求解就能在一维数组下解决问题：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeBag</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> c, <span class="keyword">int</span> V, <span class="keyword">int</span>[] dp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = c; j &lt;= V; j++)</span><br><span class="line">    	dp[j] = Math.max(dp[j], dp[j - c] + w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bagProblem</span><span class="params">(<span class="keyword">int</span>[] C, <span class="keyword">int</span>[] W, <span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> dp[V + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C.length; i++)</span><br><span class="line">    	completeBag(W[i], C[i], V, dp);</span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h1><p>&emsp;多重背包问题就是每个物品能拿的数量是有限数m，这种情况下，如果一个物品的费用与能拿的次数的积大于背包容量，那么可以转化为完全背包问题求解，否则，要转化为01背包问题求解，可以用二进制编码优化时间复杂度。二进制编码优化是指，可以不用从0遍历到m次，可以转为1，2，4，2^(k-1) 与m - 2^k  + 1，其中k表示使2^k - 1 &lt;  m的最大k值。例如，m = 19，可以转为1， 2， 4， 8， 12，这样从1到19都能用这几个数组合得到，可以优化时间复杂度。<br>&emsp;传入一个数组M表示第i件物品只能拿M[i]次：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiBag</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> c, <span class="keyword">int</span> V, <span class="keyword">int</span>[] dp, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m * c &gt;= V)</span><br><span class="line">        completeBag(w, c, V, dp);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">2</span> * k - <span class="number">1</span> &lt; m)&#123;</span><br><span class="line">            zeroOneBag(w * k, c * k, V, dp);</span><br><span class="line">            k = <span class="number">2</span> * k;</span><br><span class="line">        &#125;</span><br><span class="line">        m = m - k / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        zeroOneBag(w * m, c * m, V, dp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bagProblem</span><span class="params">(<span class="keyword">int</span>[] C, <span class="keyword">int</span>[] W, <span class="keyword">int</span> V, <span class="keyword">int</span>[] M)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> dp[V + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C.length; i++)</span><br><span class="line">    	multiBag(W[i], C[i], V, dp, M[i]);</span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;假设每件物品平均能拿K次，多重背包问题在这种情况下时间复杂度为 $O(NVlgK)$ 。多重背包问题其实存在更好的方法可以达到 $O(NV)$ 的时间复杂度。</p>
<h1 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h1><p>&emsp;混合背包问题即之前三种背包问题的混合，有的物品最多只能拿1次，有的能拿无限次，有的能拿有限次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bagProblem</span><span class="params">(<span class="keyword">int</span>[] C, <span class="keyword">int</span>[] W, <span class="keyword">int</span> V, <span class="keyword">int</span>[] M)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> dp[V + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(M[i] == <span class="number">1</span>)</span><br><span class="line">        	zeroOneBag(w, c, V, dp);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(M[i] == <span class="number">0</span>) <span class="comment">// 表示能拿无限次</span></span><br><span class="line">        	completeBag(w, c, V, dp);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	multiBag(w[i], c[i], V, dp, M[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>背包问题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>约定编程AOP</title>
    <url>/2020/07/18/%E7%BA%A6%E5%AE%9A%E7%BC%96%E7%A8%8BAOP/</url>
    <content><![CDATA[<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><p>Spring AOP 是一种约定编程，通过约定，将对应的方法以动态代理的方式织入约定的流程之中，在 Spring Boot 中，主要使用注解的方式配置 AOP。<br><a id="more"></a></p>
<p>Spring AOP 是一种基于方法的 AOP，只能应用在方法上。AOP 有一些基本术语如下：</p>
<ul>
<li>连接点：对应被拦截的具体对象，在 Spring AOP 中指具体的方法。</li>
<li>切点：通过正则式或者规则定义连接点。</li>
<li>通知：在 Spring AOP 中根据执行顺序分为前置通知，后置通知，环绕通知，返回通知(未发生异常)和异常通知(发生异常)。</li>
<li>目标对象：被代理的对象。</li>
<li>引入：引入新的类和方法增强现有 Bean 的功能。</li>
<li>切面：定义切点、各类通知和引入的内容。</li>
</ul>
<h2 id="开发连接点"><a href="#开发连接点" class="headerlink" title="开发连接点"></a>开发连接点</h2><p>AOP 编程首先要确定在哪个地方需要用到 AOP，新建一个 Spring Boot 项目，定义一个 Hello 接口与一个 HelloImpl 实现类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello "</span> + s);</span><br><span class="line">        <span class="comment">// 测试异常通知</span></span><br><span class="line">        <span class="comment">// int i = 1 / 0;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="开发切面"><a href="#开发切面" class="headerlink" title="开发切面"></a>开发切面</h2><p>开发切面主要需要用的注解如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>注解</th>
<th>传入参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Aspect</td>
<td></td>
<td>定义一个切面</td>
</tr>
<tr>
<td>@Pointcut</td>
<td>正则式或指示器</td>
<td>定义一个切点</td>
</tr>
<tr>
<td>@Before</td>
<td>切点</td>
<td>定义前置通知</td>
</tr>
<tr>
<td>@After</td>
<td>切点</td>
<td>定义后置通知，无论是否发生异常，都会执行</td>
</tr>
<tr>
<td>@AfterReturning</td>
<td>切点</td>
<td>定义返回通知</td>
</tr>
<tr>
<td>@AfterThrowing</td>
<td>切点</td>
<td>定义异常通知</td>
</tr>
<tr>
<td>@Around</td>
<td>切点</td>
<td>定义环绕通知</td>
</tr>
<tr>
<td>@DeclareParents</td>
<td>需要增强的对象与引入增强功能的类</td>
<td>增强接口功能</td>
</tr>
</tbody>
</table>
</div>
<p>定义一个切面 MyAspect 如下，需要将定义的切面交由 IoC 容器管理才会生效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *execution表示在执行的时候拦截匹配的方法</span></span><br><span class="line"><span class="comment">    * *这个符号表示匹配任意返回值</span></span><br><span class="line"><span class="comment">    * (..)表示匹配任意参数的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* top.liuzhenhui.aopdemo.HelloImpl.hello(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;前置通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;后置通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;返回通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;异常通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义完之后，可以在单元测试中测试 AOP 是否生效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AopdemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Hello helloImpl;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        helloImpl.hello(<span class="string">"AOP"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h2><p>刚刚定义的切面中并没有加入环绕通知，环绕通知功能十分强大，一般也不常用，它是一个能取代原有目标对象方法的通知，可以传入一个 ProceedingJoinPoint 类型的参数给它，它有一个 prodeed 方法回调原目标函数的方法。在刚刚定义的切面中加入环绕通知：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint jp)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;环绕前"</span>);</span><br><span class="line">    <span class="comment">// 回调目标对象原有方法，如果注释掉下一行代码，原有方法将不会执行！！！！</span></span><br><span class="line">    jp.proceed();</span><br><span class="line">    System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;环绕后"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加入环绕通知后再次执行单元测试结果如下：</p>
<p><img src="https://raw.githubusercontent.com/LZH-SC/blogImages/master/img/20200719013054.png" alt=""></p>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>引入能通过引入新的接口增强接口的功能，创建新的接口 Hello2 与 接口实现类 Hello2Impl 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello2Impl</span> <span class="keyword">implements</span> <span class="title">Hello2</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;hello2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后在定义的切面 MyAspect 中添加引入功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeclareParents</span>(value = <span class="string">"top.liuzhenhui.aopdemo.HelloImpl+"</span>,</span><br><span class="line">            defaultImpl = Hello2Impl<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Hello2</span> <span class="title">hello2</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* top.liuzhenhui.aopdemo.HelloImpl.hello(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其它代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中， 在 <code>@DeclareParents</code> 注解中， <strong>value 的值是需要增强功能的目标对象，defaultImpl 的值是引入增强功能的类</strong>。</p>
<p>之后，在单元测试中测试引入功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AopdemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Hello helloImpl;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 测试引入功能</span></span><br><span class="line">        Hello2 hello2 = (Hello2) helloImpl;</span><br><span class="line">        hello2.hello2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        helloImpl.hello(<span class="string">"AOP"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引入功能的原理是<strong>创建代理对象时，将增强的接口也传递进去</strong>，这样生成的代理对象就能够转换为增强的接口的类型，获得它的方法。</p>
<h2 id="多个切面"><a href="#多个切面" class="headerlink" title="多个切面"></a>多个切面</h2><p>Spring 支持多个切面共存，你也可以通过注解 <code>@Order</code> 指定它们之间的顺序即可，新建一个新的切面 MyAspect2 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* top.liuzhenhui.aopdemo.HelloImpl.hello(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint jp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyAspect2&gt;&gt;&gt;&gt;&gt;&gt;&gt;环绕前"</span>);</span><br><span class="line">        <span class="comment">// 回调目标对象原有方法，如果注释掉下一行代码，原有方法将不会执行！！！！</span></span><br><span class="line">        jp.proceed();</span><br><span class="line">        System.out.println(<span class="string">"MyAspect2&gt;&gt;&gt;&gt;&gt;&gt;&gt;环绕后"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyAspect2&gt;&gt;&gt;&gt;&gt;&gt;&gt;前置通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyAspect2&gt;&gt;&gt;&gt;&gt;&gt;&gt;后置通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyAspect2&gt;&gt;&gt;&gt;&gt;&gt;&gt;返回通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyAspect2&gt;&gt;&gt;&gt;&gt;&gt;&gt;异常通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改 MyAspect 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeclareParents</span>(value = <span class="string">"top.liuzhenhui.aopdemo.HelloImpl"</span>,</span><br><span class="line">            defaultImpl = Hello2Impl<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Hello2</span> <span class="title">hello2</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* top.liuzhenhui.aopdemo.HelloImpl.hello(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint jp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyAspect1&gt;&gt;&gt;&gt;&gt;&gt;&gt;环绕前"</span>);</span><br><span class="line">        <span class="comment">// 回调目标对象原有方法，如果注释掉下一行代码，原有方法将不会执行！！！！</span></span><br><span class="line">        jp.proceed();</span><br><span class="line">        System.out.println(<span class="string">"MyAspect1&gt;&gt;&gt;&gt;&gt;&gt;&gt;环绕后"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyAspect1&gt;&gt;&gt;&gt;&gt;&gt;&gt;前置通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyAspect1&gt;&gt;&gt;&gt;&gt;&gt;&gt;后置通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyAspect1&gt;&gt;&gt;&gt;&gt;&gt;&gt;返回通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyAspect1&gt;&gt;&gt;&gt;&gt;&gt;&gt;异常通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过单元测试查看多个切面的执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyAspect2&gt;&gt;&gt;&gt;&gt;&gt;&gt;环绕前</span><br><span class="line">MyAspect2&gt;&gt;&gt;&gt;&gt;&gt;&gt;前置通知</span><br><span class="line">MyAspect1&gt;&gt;&gt;&gt;&gt;&gt;&gt;环绕前</span><br><span class="line">MyAspect1&gt;&gt;&gt;&gt;&gt;&gt;&gt;前置通知</span><br><span class="line">hello AOP</span><br><span class="line">MyAspect1&gt;&gt;&gt;&gt;&gt;&gt;&gt;环绕后</span><br><span class="line">MyAspect1&gt;&gt;&gt;&gt;&gt;&gt;&gt;后置通知</span><br><span class="line">MyAspect1&gt;&gt;&gt;&gt;&gt;&gt;&gt;返回通知</span><br><span class="line">MyAspect2&gt;&gt;&gt;&gt;&gt;&gt;&gt;环绕后</span><br><span class="line">MyAspect2&gt;&gt;&gt;&gt;&gt;&gt;&gt;后置通知</span><br><span class="line">MyAspect2&gt;&gt;&gt;&gt;&gt;&gt;&gt;返回通知</span><br></pre></td></tr></table></figure>
<p>通过执行结果可以看出，多个切面之间的执行是<strong>责任链模型</strong>的顺序来执行的。</p>
<h2 id="获取方法参数"><a href="#获取方法参数" class="headerlink" title="获取方法参数"></a>获取方法参数</h2><p>想要在通知中获取方法参数，如果是环绕通知，它的 ProceedingJoinPoint 类型的参数的 getArgs 方法就可以获得参数。</p>
<p>如果是非环绕通知，可以通过一个 JoinPoint 类型的参数的 getArgs 方法获得参数。</p>
<p>在前置通知与环绕通知中测试获取参数，修改 MyAspect 中的两个方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint jp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"MyAspect1&gt;&gt;&gt;&gt;&gt;&gt;&gt;环绕前"</span>);</span><br><span class="line">    <span class="comment">// 回调目标对象原有方法，如果注释掉下一行代码，原有方法将不会执行！！！！</span></span><br><span class="line">    jp.proceed();</span><br><span class="line">    System.out.println(Arrays.toString(jp.getArgs()));</span><br><span class="line">    System.out.println(<span class="string">"MyAspect1&gt;&gt;&gt;&gt;&gt;&gt;&gt;环绕后"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint jp)</span> </span>&#123;</span><br><span class="line">    System.out.println(Arrays.toString(jp.getArgs()));</span><br><span class="line">    System.out.println(<span class="string">"MyAspect1&gt;&gt;&gt;&gt;&gt;&gt;&gt;前置通知"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在单元测试中测试获取参数的结果即可。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis基础使用(二)</title>
    <url>/2020/07/05/mybatis%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8-%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="主键返回"><a href="#主键返回" class="headerlink" title="主键返回"></a>主键返回</h1><p>对于新 insert 的记录，如果想要得到它的主键，有两种方法。一种是设置 useGeneratedKeys，这种方式需要数据库支持自动生成的字段，然后将 keyProperty 设置到目标属性上。另一种是使用子标签 <code>&lt;selectKey&gt;</code> 来实现。<br><a id="more"></a></p>
<p>在 mapper.xml 中添加 SQL ：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addUser1"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">    insert into user (username, address, interests) values</span><br><span class="line">    (#&#123;u.username&#125;, #&#123;u.address&#125;, #&#123;u.interests&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addUser2"</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- order表示是在 insert 语句执行之后还是之前调用 selectKey子标签下的语句 </span></span><br><span class="line"><span class="comment">         resultType标识返回主键的类型--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注意，因为使用了 @Param 注解，故 keyProperty 的值不能直接填 id，否则会无法成功返回 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">"u.id"</span> <span class="attr">resultType</span>=<span class="string">"int"</span> <span class="attr">order</span>=<span class="string">"AFTER"</span>&gt;</span></span><br><span class="line">        SELECT LAST_INSERT_ID()</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    insert into user (username, address, interests) values</span><br><span class="line">    (#&#123;u.username&#125;, #&#123;u.address&#125;, #&#123;u.interests&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 mapper 接口中声明方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addUser1</span><span class="params">(@Param(<span class="string">"u"</span>)</span> User user)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser2</span><span class="params">(@Param(<span class="string">"u"</span>)</span> User user)</span>;</span><br></pre></td></tr></table></figure>
<p>需要注意，<strong>方法的返回值是影响的行数并不是主键值，主键值是设置在传入的对象中的，要使用 getId() 方法来获取自增主键值</strong>，因此，其实方法声明为 void 也并不影响。其次，因为使用了 @Param 注解，所以在 selectKey 标签中 keyProperty的值不能直接设置为 id， 否则无法获取到主键值。另外实体类中，主键也需要有 setter 方法，否则不能设置。</p>
<h1 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h1><p>逆向⼯程实际上就是想⾃动⽣成基础的 mapper.xml 和 mapper 接口，并且内置了一些基础的增删改查操作，不⽤⾃⼰写对应的映射⽂件和接⼝。</p>
<p>先在数据库中添加学生表，分数表，班级表与课程表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> card</span><br><span class="line">(</span><br><span class="line">    card_id  <span class="built_in">int</span> auto_increment</span><br><span class="line">        primary <span class="keyword">key</span>,</span><br><span class="line">    card_num <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="literal">null</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">class</span></span><br><span class="line">(</span><br><span class="line">    class_id   <span class="built_in">int</span> auto_increment</span><br><span class="line">        primary <span class="keyword">key</span>,</span><br><span class="line">    class_name <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="literal">null</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> course</span><br><span class="line">(</span><br><span class="line">    course_id   <span class="built_in">int</span> auto_increment</span><br><span class="line">        primary <span class="keyword">key</span>,</span><br><span class="line">    course_name <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="literal">null</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> course_student_middle</span><br><span class="line">(</span><br><span class="line">    course_id  <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    student_id <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (course_id, student_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student</span><br><span class="line">(</span><br><span class="line">    student_id <span class="built_in">int</span> auto_increment</span><br><span class="line">        primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span>       <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="literal">null</span>,</span><br><span class="line">    card_id    <span class="built_in">int</span>         <span class="literal">null</span>,</span><br><span class="line">    class_id   <span class="built_in">int</span>         <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">constraint</span> card_fk</span><br><span class="line">        <span class="keyword">foreign</span> <span class="keyword">key</span> (card_id) <span class="keyword">references</span> card (card_id),</span><br><span class="line">    <span class="keyword">constraint</span> class_fk</span><br><span class="line">        <span class="keyword">foreign</span> <span class="keyword">key</span> (student_id) <span class="keyword">references</span> <span class="keyword">class</span> (class_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>其中 student 与 card 是一对一映射，class 与 student 是一对多映射， course 与 student 是多对多映射。并向其中随意添加一些数据做测试。</p>
<p>在 idea 中下载插件 <code>Better-Mybatis-Generator</code>，之后 idea 连接数据库，右键表即可生成。 </p>
<p><img src="https://raw.githubusercontent.com/LZH-SC/blogImages/master/img/sdjfskdjfsdEKP.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/LZH-SC/blogImages/master/img/skdfksdjfTS.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/LZH-SC/blogImages/master/img/20200706194932.png" alt=""></p>
<p>可以看到，通过逆向工程插件，根据数据中的表自动生成了一系列需要的文件，十分方便。</p>
<h1 id="一对一映射"><a href="#一对一映射" class="headerlink" title="一对一映射"></a>一对一映射</h1><p>上述逆向工程创建的实体类需要进行简单修改实现一对一映射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer studentId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Card card; <span class="comment">// 一对一映射</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其它代码....</span></span><br></pre></td></tr></table></figure>
<p>修改 StudentMapper.xml 中的 resultMap 定义查询结果映射关系：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"student"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"student_id"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> <span class="attr">property</span>=<span class="string">"studentId"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"class_id"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> <span class="attr">property</span>=<span class="string">"classId"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"card"</span> <span class="attr">javaType</span>=<span class="string">"card"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"cardId"</span> <span class="attr">column</span>=<span class="string">"card_id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"cardNum"</span> <span class="attr">column</span>=<span class="string">"card_num"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getById"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">  select * from student s, card c where s.card_id = c.card_id and s.student_id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>之后运行 getById 方法，结果为 <code>Student{studentId=5, name=&#39;test1&#39;, card=Card{cardId=1, cardNum=&#39;card1&#39;}, classId=1}</code> 可以看出，已经成功实现了一对一映射。</p>
<p>在 resultMap 标签中，<strong>子标签 association 用于描述一对一关系，封装返回结果</strong>，association 的子标签 id 与 result 的用法与 resultMap 一样，association 需要配置 property 表示实体类中的属性，javaType表示属性的类型。</p>
<h1 id="一对多映射"><a href="#一对多映射" class="headerlink" title="一对多映射"></a>一对多映射</h1><p>一个班级可以有多个学生，修改 class 实体类是实现一对多映射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer classId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; students;</span><br><span class="line">    <span class="comment">// 省略其它代码....</span></span><br></pre></td></tr></table></figure>
<p>修改 ClassMapper.xml 中的 resultMap 定义查询结果：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"top.liuzhenhui.model.Class"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"class_id"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> <span class="attr">property</span>=<span class="string">"classId"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"class_name"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"className"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"students"</span> <span class="attr">javaType</span>=<span class="string">"java.util.List"</span> <span class="attr">ofType</span>=<span class="string">"student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"student_id"</span> <span class="attr">property</span>=<span class="string">"studentId"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"class_id"</span> <span class="attr">property</span>=<span class="string">"classId"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"card"</span> <span class="attr">javaType</span>=<span class="string">"card"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"cardId"</span> <span class="attr">column</span>=<span class="string">"card_id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"cardNum"</span> <span class="attr">column</span>=<span class="string">"card_num"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getClassById"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">  select * from class c, student s where c.class_id = s.class_id and c.class_id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>resultMap 标签中的 collection 标签定义结果中的集合，property 定义属性名， javaType 定义属性的类型，ofType 属性定义集合的元素的类型，其中的子标签与 resultMap 子标签的使用一样。</p>
<p>运行 getClassById方法查询结果如下，由结果可知成功实现了一对多映射：</p>
<p><img src="https://raw.githubusercontent.com/LZH-SC/blogImages/master/img/20200706172309.png" alt=""></p>
<h1 id="多对多映射"><a href="#多对多映射" class="headerlink" title="多对多映射"></a>多对多映射</h1><p>一门课程可以有多个学生，一个学生可以选择多门课程，这是多对多映射关系，修改 Student 类与 Class 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer studentId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Card card;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Class&gt; classes;</span><br><span class="line">    <span class="comment">// 省略其它代码.....</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer courseId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String courseName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; students;</span><br><span class="line">    <span class="comment">// 省略其它代码.....</span></span><br></pre></td></tr></table></figure>
<p>多对多查询类似于双面性的一对多查询，只要分别对两个 mapper.xml 都定义方法与 resultMap 即可。</p>
<h1 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h1><p>在进⾏数据查询时， 为了提⾼数据库查询性能，尽量使⽤单表查询，因为单表查询⽐多表关联查询速度要快。延迟加载就是⼀开始先查询单表，当需要关联信息时，再关联查询。</p>
<p>在 mybatis-config.xml 中配置延迟加载生效：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span> <span class="comment">&lt;!-- 开启懒加载 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span> <span class="comment">&lt;!-- 设置属性按需加载 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 省略其它配置 --&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在 StudentMapper.xml 中使用延迟加载：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"student_id"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> <span class="attr">property</span>=<span class="string">"studentId"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"class_id"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> <span class="attr">property</span>=<span class="string">"classId"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"card"</span> <span class="attr">javaType</span>=<span class="string">"card"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">select</span>=<span class="string">"top.liuzhenhui.mapper.CardMapper.selectByPrimaryKey"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">column</span>=<span class="string">"card_id"</span> <span class="attr">fetchType</span>=<span class="string">"lazy"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getById"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">    select * from student where student_id = #&#123;id&#125;;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>配置延迟加载后，association 中的 select 指定需要执行的语句， column 是传递的参数， fetchType = “lazy” 标识使用懒加载</strong>。</p>
<p>修改 main 方法测试懒加载：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 建立一个SqlSessionFactory用户获取SqlSession</span></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder()</span><br><span class="line">            .build(Resources.getResourceAsStream(<span class="string">"mybatis-config.xml"</span>));</span><br><span class="line">    <span class="keyword">try</span>(SqlSession sqlSession = sqlSessionFactory.openSession())&#123;</span><br><span class="line">        <span class="keyword">if</span>(sqlSession.getConnection() != <span class="keyword">null</span>)&#123; <span class="comment">// 不为空说明能获取到与数据库的连接</span></span><br><span class="line">            System.out.println(<span class="string">"连接成功"</span>);</span><br><span class="line">            StudentMapper mapper = sqlSession.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            Student s = mapper.getById(<span class="number">8</span>);</span><br><span class="line">            System.out.println(<span class="string">"测试延迟加载"</span>);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"连接失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码执行结果如下，可以看到，确实对 card 属性延迟加载了。</p>
<p><img src="https://raw.githubusercontent.com/LZH-SC/blogImages/master/img/20200706175951.png" alt=""></p>
]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis基础使用</title>
    <url>/2020/07/04/mybatis%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Mybatis-简介"><a href="#Mybatis-简介" class="headerlink" title="Mybatis 简介"></a>Mybatis 简介</h1><p>MyBatis 官网：<a href="https://mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh/index.html</a></p>
<p>MyBatis 是一个持久层框架，它对 jdbc 的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建 connection、创建 statement、手动设置参数、结果集检索等 jdbc 繁杂的过程代码。<br><a id="more"></a></p>
<p>Mybatis 通过 xml 或注解的方式将要执行的各种 statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过 java 对象和 statement 中的 sql 进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射成 java 对象并返回。</p>
<h1 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h1><p>首先在数据库中建立一个 user 表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    username <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">null</span>,</span><br><span class="line">    address  <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>新建 maven 项目，引入相关依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 resources 目录下新建 mybatis-config.xml 文件，文件内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span> <span class="comment">&lt;!-- 指定环境 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span>  <span class="comment">&lt;!-- 配置环境 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///mybatis?serverTimezone=Asia/Shanghai"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"your_username"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"your_password"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span> <span class="comment">&lt;!-- 指定mapper路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"mapper/UserMapper.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>之后，建立一个与数据库表对应的 Java 实体类 User ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">// ...... 省略了其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 resources 目录下新建 mapper 文件夹，在 mapper 文件夹下新建一个 UserMapper.xml如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace必须是唯一标识，避免不同 mapper 的方法冲突 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"top.liuzhenhui.mapper.UserMapper"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- resultType写全限定名，id表示语句名字在同一个namesapce下唯一，#&#123;id&#125; 接收传入参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserById"</span> <span class="attr">resultType</span>=<span class="string">"top.liuzhenhui.model.User"</span>&gt;</span></span><br><span class="line">        select * from user where id = #&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后，编写主方法运行 UserMapper.xml 下定义的 sql 语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 建立一个SqlSessionFactory用户获取SqlSession</span></span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder()</span><br><span class="line">                .build(Resources.getResourceAsStream(<span class="string">"mybatis-config.xml"</span>));</span><br><span class="line">        <span class="keyword">try</span>(SqlSession sqlSession = sqlSessionFactory.openSession())&#123;</span><br><span class="line">            <span class="keyword">if</span>(sqlSession.getConnection() != <span class="keyword">null</span>)&#123; <span class="comment">// 不为空说明能获取到与数据库的连接</span></span><br><span class="line">                System.out.println(<span class="string">"连接成功"</span>);</span><br><span class="line">                <span class="comment">// 通过 namespace 与其中语句定义的 id 找到编写的 sql 语句</span></span><br><span class="line">                User u = sqlSession.selectOne(<span class="string">"top.liuzhenhui.mapper.UserMapper.getUserById"</span>, <span class="number">1</span>);</span><br><span class="line">                System.out.println(u);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                System.out.println(<span class="string">"连接失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目录结构如下图</p>
<p><img src="https://raw.githubusercontent.com/LZH-SC/blogImages/master/img/20200704193232.png" alt=""></p>
<p>以上便是最基础的 mybatis 使用，需要通过配置文件创建一个 SqlSessionFactory 用于获取 SqlSession，SqlSession 中对数据库操作的进行了封装。</p>
<h1 id="使用-mapper-代理"><a href="#使用-mapper-代理" class="headerlink" title="使用 mapper 代理"></a>使用 mapper 代理</h1><p>在 mybatis 中，还可以通过定义接口进一步简化 dao 层的开发，也是常用的方法，新建一个 mapper 包，在其中新建一个 UserMapper 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法名必须与 UserMapper.xml 中的语句 id 一致</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口的全限定名必须与 UserMapper.xml 中的 namespace 一致。然后，修改 mybatis-config.xml 中的配置，将新建的 Mapper 接口配置上：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span> <span class="comment">&lt;!-- 指定mapper路径 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;mapper resource="mapper/UserMapper.xml"/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定mappe接口的包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"top.liuzhenhui.mapper"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于 mybatis 要求 mapper.xml 与 mapper 接口必须放在同一个包下，所以需要在 resources 目录下新建与 mapper 接口包名一致的文件夹，将 UserMapper.xml 放在该文件夹下。</p>
<p><img src="https://raw.githubusercontent.com/LZH-SC/blogImages/master/img/20200704223131.png" alt=""></p>
<p>之后，修改主方法如下即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 建立一个SqlSessionFactory用户获取SqlSession</span></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder()</span><br><span class="line">            .build(Resources.getResourceAsStream(<span class="string">"mybatis-config.xml"</span>));</span><br><span class="line">    <span class="keyword">try</span>(SqlSession sqlSession = sqlSessionFactory.openSession())&#123;</span><br><span class="line">        <span class="keyword">if</span>(sqlSession.getConnection() != <span class="keyword">null</span>)&#123; <span class="comment">// 不为空说明能获取到与数据库的连接</span></span><br><span class="line">            System.out.println(<span class="string">"连接成功"</span>);</span><br><span class="line">            <span class="comment">// 通过动态代理返回一个对象</span></span><br><span class="line">            UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="comment">// 直接调用方法即可</span></span><br><span class="line">            User u = mapper.getUserById(<span class="number">8</span>);</span><br><span class="line">            System.out.println(u);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"连接失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 SqlSession 的 getMapper 方法，传入自定义 Mapper 接口的类，mybatis 会通过动态代理自动创建一个对象，对象中的方法代理了 sql 语句的执行。</p>
<h1 id="配置-typeAliase"><a href="#配置-typeAliase" class="headerlink" title="配置 typeAliase"></a>配置 typeAliase</h1><p>之前的代码在写返回类型的时候，必须写类的全限定名 <code>top.liuzhenhui.model.User</code>，这种做法显然十分麻烦，mybatis 支持自定义别名，在 mybatis-config.xml 文件中添加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"top.liuzhenhui.model"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 后面配置省略.... --&gt;</span></span><br></pre></td></tr></table></figure>
<p>它会自动利用包扫描批量给对象定义别名，批量定义默认的类的别名，是类名首字母小写。之后就可以在 UserMapper.xml 中使用别名： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"top.liuzhenhui.mapper.UserMapper"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- resultType写别名即可 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserById"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        select * from user where id = #&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>mybatis 已经对基本数据类型以及他们的包装类和 String 类定义了别名，直接使用即可。</p>
<h1 id="定义-TypeHandler"><a href="#定义-TypeHandler" class="headerlink" title="定义 TypeHandler"></a>定义 TypeHandler</h1><p>在 mybatis 中，内置了一些 TypeHandler，能够将 jdbc 数据映射为 Java 类型，例如 StringTypeHandler，EnumTypeHandler等，但是在某些情况下，还是需要自定义 TypeHandler 处理特殊类型。</p>
<p>例如，给之前的 user 表添加一个字段 interests 表示爱好，一个 user 可能不止一个爱好，因此用列表表示，修改 User 类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; interests;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其它代码......</span></span><br></pre></td></tr></table></figure>
<p>然后，自定义一个 TypeHandler，自定义的 TypeHandler 需要实现 TypeHandler 接口，可以使用注解 @MappedJdbcType 标注 Jdbc 类型，@MappedTypes 标注 Java 类型。如果不使用注解标注，需要在配置文件里标注。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MappedJdbcTypes</span>(JdbcType.VARCHAR)</span><br><span class="line"><span class="meta">@MappedTypes</span>(List<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">List2VarcharTypeHandler</span> <span class="keyword">implements</span> <span class="title">TypeHandler</span>&lt;<span class="title">List</span>&lt;<span class="title">String</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, List&lt;String&gt; parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String s : parameter)&#123;</span><br><span class="line">            sb.append(s);</span><br><span class="line">            sb.append(<span class="string">','</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ps.setString(i, sb.toString());  <span class="comment">// 设置到对应的参数上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        String s = rs.getString(columnName);</span><br><span class="line">        <span class="comment">// 避免空指针异常</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String[] strings = s.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(strings);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        String s = rs.getString(columnIndex);</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String[] strings = s.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(strings);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        String s = cs.getString(columnIndex);</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String[] strings = s.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(strings);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义 TypeHandler 后还需要在 mybatis-config.xml 中做全局配置，或者在 mapper.xml 里做局部配置亦可，这里配置全局配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"top.liuzhenhui.model"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"top.liuzhenhui.typehandler"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 后面配置省略.... --&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置完成后，就可以正常使用了。</p>
<h1 id="传入参数"><a href="#传入参数" class="headerlink" title="传入参数"></a>传入参数</h1><h2 id="与-的区别"><a href="#与-的区别" class="headerlink" title="#{} 与 ${} 的区别"></a>#{} 与 ${} 的区别</h2><p>在 mybatis 中，在 mapper.xml 中引用传入的变量时，可以使用 #{} 和 ${}，这两种方式的区别是，<strong>#{} 是采用符号占位，${} 是 SQL 拼接，而且在低版本中 ${} 需要使用 @Param 注解为参数取别名</strong>。</p>
<p>如下图是 #{} 执行时的 SQL：</p>
<p><img src="https://raw.githubusercontent.com/LZH-SC/blogImages/master/img/20200705010655.png" alt=""></p>
<p>下图是 ${} 执行时的 SQL：</p>
<p><img src="https://raw.githubusercontent.com/LZH-SC/blogImages/master/img/20200705011026.png" alt=""></p>
<h2 id="传入多个简单类型参数"><a href="#传入多个简单类型参数" class="headerlink" title="传入多个简单类型参数"></a>传入多个简单类型参数</h2><p>在 UserMapper.xml 中加入新的语句：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUser"</span>&gt;</span></span><br><span class="line">    update user set username = #&#123;username&#125; where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 UserMapper 接口中声明该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(String username, Integer id)</span></span>;</span><br></pre></td></tr></table></figure>
<p>发现调用这个方法时会报错：</p>
<p><img src="https://raw.githubusercontent.com/LZH-SC/blogImages/master/img/BMPB.png" alt=""></p>
<p>这是因为传入多个参数时要使用系统提供的默认名字 arg0,arg1… 或者 param1, param2….，这样不太方便，可以使用 @Param 注解指定参数名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(@Param(<span class="string">"username"</span>)</span> String username, @<span class="title">Param</span><span class="params">(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="传入对象参数"><a href="#传入对象参数" class="headerlink" title="传入对象参数"></a>传入对象参数</h2><p>在 UserMapper.xml 中加入新语句：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addUser"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    insert into user (username, address, interests) values (#&#123;username&#125;, #&#123;address&#125;, #&#123;interests&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 UserMapper 接口中声明对应方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure>
<p>调用能成功，在传入参数只有一个对象时，可以直接解析出对象的字段，有时候需要传入多个对象，同样也需要 @Param 注解指定参数名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(@Param(<span class="string">"u"</span>)</span> User user)</span>;</span><br></pre></td></tr></table></figure>
<p>这样 UserMapper.xml 中的语句也需要变化，利用 . 符号来访问值：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addUser"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    insert into user (username, address, interests) values</span><br><span class="line">    (#&#123;u.username&#125;, #&#123;u.address&#125;, #&#123;u.interests&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Map参数"><a href="#Map参数" class="headerlink" title="Map参数"></a>Map参数</h2><p>在传入参数时也可以传入一个 Map 作为参数。Map 中的 key 作为 #{} 或 ${} 中引用的变量名即可。</p>
<h1 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h1><p>resultType 返回的类型可以是简单类型，可以是对象，可以是集合，也可以是一个 hashmap，如果是 hashmap，map 中的 key 就是字段名，value 就是字段的值。但是有的时候需要返回的对象比较复杂，需要使用 resultMap 来自定义映射的结果。</p>
<p>在 mapper.xml 中定义一个 resultMap，之后便可使用这个 resultMap 定义返回值。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- id 标识 resultMap 的名字， type 是 Java 类型，这里用的之前定义的别名，也可以用全限定名 top.liuzhenhui.model.User --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"MyResultMap"</span> <span class="attr">type</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--id 用来描述主键</span></span><br><span class="line"><span class="comment">        column 是数据库查询出来的列名</span></span><br><span class="line"><span class="comment">        property 则是对象中的属性名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">property</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"address"</span> <span class="attr">property</span>=<span class="string">"address"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 返回值用定义的 resultMap --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserById"</span> <span class="attr">resultMap</span>=<span class="string">"MyResultMap"</span>&gt;</span></span><br><span class="line">    select * from user where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 mybatis 低版本中，使用 resultMap 还需要有一个无参构造方法，resultMap 中也支持选定指定的构造函数：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"MyResultMap"</span> <span class="attr">type</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- idArg 标识主键</span></span><br><span class="line"><span class="comment">    name 标识构造函数传入的形参名 </span></span><br><span class="line"><span class="comment">    column标识数据库列名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">idArg</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">idArg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样还需要在 User 类的构造函数中加入 @Param 注解才能解析成功，因为 mybatis 提供的默认参数名是 arg0,arg1… 以及 param1, param2…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Integer id, @<span class="title">Param</span><span class="params">(<span class="string">"username"</span>)</span> String username)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a>动态 SQL</h1><p>动态 SQL 功能十分强大，在许多场景都能使用， mybatis 中提供了许多动态 SQL 节点。</p>
<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>if 是一个判断节点，如果满足某个条件，节点中的 SQL 就会生效。</p>
<p>在 mapper.xml 中加入如下语句：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserByPage"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"start != null and count != null"</span>&gt;</span></span><br><span class="line">    limit #&#123;start&#125;, #&#123;count&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 mapper 接口中声明该方法即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserByPage</span><span class="params">(@Param(<span class="string">"start"</span>)</span> Integer start, @<span class="title">Param</span><span class="params">(<span class="string">"count"</span>)</span> Integer count)</span>;</span><br></pre></td></tr></table></figure>
<p>if 节点中，test 表示判断条件，如果判断结果为 true，则 if 节点的中的 SQL 会生效，否则不会生效。</p>
<h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><p>where 可以处理查询参数，有满足的条件，where 节点会自动加上，还<strong>会自动处理 and 关键字</strong>。</p>
<p>在 mapper.xml 中加入以下语句：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserByUsernameOrId"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username != null"</span>&gt;</span></span><br><span class="line">            and username = #&#123;username&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"id != null"</span>&gt;</span></span><br><span class="line">            and id = #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 mapper 接口中声明该方法即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserByUsernameOrId</span><span class="params">(@Param(<span class="string">"username"</span>)</span> String username, @<span class="title">Param</span><span class="params">(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>foreach 用于处理数组/集合参数，在 mapper.xml 中加入以下语句：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserByIds"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"ids != null and ids.size() &gt; 0"</span>&gt;</span></span><br><span class="line">        where id in</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"ids"</span> <span class="attr">item</span>=<span class="string">"id"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>再在 mapper 接口中声明方法后，上述语句调用时的 sql 语句是 <code>select * from user where id in ( ? , ? , ? , ? , ? , ? , ? )</code> 由此可知在 foreach 标签中，collection 是传入的集合或数组参数，open 表示开始符号，close 表示结束符号，separator 是分隔符，item 表示每一个元素。</p>
<h2 id="sql片段"><a href="#sql片段" class="headerlink" title="sql片段"></a>sql片段</h2><p>在开发中，SQL 的拼接很常见，由于一些拼接的 sql 具有重复性高的特点，这时最好把重复的 sql 抽取出来，作为公用的 sql 片段。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"base_column"</span>&gt;</span></span><br><span class="line">    id,username,address,interests</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- resultType写别名即可 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserById"</span> <span class="attr">resultMap</span>=<span class="string">"MyResultMap"</span>&gt;</span></span><br><span class="line">    select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"base_column"</span> /&gt;</span></span><br><span class="line">    from user where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过 sql 标签定义一个 sql 片段，可以在语句中用 include 标签引用它。</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set 标签通常用于更新中，因为大部分情况下，更新的字段可能不确定，如果对象中存在该字段的值，就更新该字段，不存在，就不更新。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUser"</span>&gt;</span></span><br><span class="line">    update user</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username!=null"</span>&gt;</span></span><br><span class="line">            username = #&#123;username&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"address!=null"</span>&gt;</span></span><br><span class="line">            address = #&#123;address&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"interests!=null"</span>&gt;</span></span><br><span class="line">            interests = #&#123;interests&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>mybatis <strong>一级缓存的作用域是同一个 SqlSession</strong>，在同一个 SqlSession 中两次执行相同的 sql 语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。当一个 SqlSession 结束后该 SqlSession 中的一级缓存也就不存在了。Mybatis 默认开启一级缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 建立一个SqlSessionFactory用户获取SqlSession</span></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder()</span><br><span class="line">            .build(Resources.getResourceAsStream(<span class="string">"mybatis-config.xml"</span>));</span><br><span class="line">    <span class="keyword">try</span>(SqlSession sqlSession = sqlSessionFactory.openSession())&#123;</span><br><span class="line">        <span class="keyword">if</span>(sqlSession.getConnection() != <span class="keyword">null</span>)&#123; <span class="comment">// 不为空说明能获取到与数据库的连接</span></span><br><span class="line">            System.out.println(<span class="string">"连接成功"</span>);</span><br><span class="line">            <span class="comment">// 通过动态代理返回一个对象</span></span><br><span class="line">            UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            User u = mapper.getUserById(<span class="number">11</span>);</span><br><span class="line">            u = mapper.getUserById(<span class="number">11</span>);</span><br><span class="line">            u = mapper.getUserById(<span class="number">11</span>);</span><br><span class="line">            u = mapper.getUserById(<span class="number">12</span>);</span><br><span class="line">            System.out.println(u);</span><br><span class="line">            sqlSession.commit();</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"连接失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如以上一段代码日志输出如下，getUserById(11) 的语句只执行了一次：</p>
<p><img src="https://raw.githubusercontent.com/LZH-SC/blogImages/master/img/20200705203909.png" alt=""></p>
<p>需要注意，Spring 整合 mybatis 后，由于 Spring 提供的 SqlSessionTemplate 会在每一次查询后及时关闭 SqlSession，因此<strong>一级缓存看起来失效了</strong>。但是开启事务的情况下，spring 使用 ThreadLocal 获取当前资源绑定同一个 sqlSession，因此此时一级缓存是有效的。</p>
<p>mybatis <strong>二级缓存是多个 SqlSession 共享的，其作用域是 mapper 的同一个 namespace</strong>，不同的 sqlSession 两次执行相同 namespace 下的 sql 语句且向 sql 中传递参数也相同即最终执行相同的 sql 语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。mybatis 默认没有开启二级缓存需要在 setting 全局参数中配置开启二级缓存。</p>
<p>在 mybatis-config.xml 中的配置二级缓存<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 省略其它配置 --&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在 mapper.xml 中开启二级缓存</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"top.liuzhenhui.mapper.UserMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 省略其它语句 --&gt;</span></span><br></pre></td></tr></table></figure>
<p>二级缓存需要让 User 类实现 Serializable 接口(如果 User 类中包含其它类，也需要实现序列化)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其它代码....</span></span><br></pre></td></tr></table></figure>
<p>最后，修改 main 方法查看开启二级缓存后在不同 SqlSession 下的执行情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 建立一个SqlSessionFactory用户获取SqlSession</span></span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder()</span><br><span class="line">                .build(Resources.getResourceAsStream(<span class="string">"mybatis-config.xml"</span>));</span><br><span class="line">        testCache(sqlSessionFactory);</span><br><span class="line">        testCache(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testCache</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(SqlSession sqlSession = sqlSessionFactory.openSession())&#123;</span><br><span class="line">            <span class="keyword">if</span>(sqlSession.getConnection() != <span class="keyword">null</span>)&#123; </span><br><span class="line">                System.out.println(<span class="string">"连接成功"</span>);</span><br><span class="line">                UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                User u = mapper.getUserById(<span class="number">11</span>);</span><br><span class="line">                System.out.println(u);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                System.out.println(<span class="string">"连接失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码执行后，日志输出如下：</p>
<p><img src="https://raw.githubusercontent.com/LZH-SC/blogImages/master/img/20200705205755.png" alt=""></p>
<p>可以看到，在开启二级缓存后，在同一个 namespace 下，查询结果确实被缓存了。</p>
]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合Mybatis</title>
    <url>/2020/07/19/SpringBoot%E6%95%B4%E5%90%88Mybatis/</url>
    <content><![CDATA[<h1 id="Spring-Boot-整合-Mybatis"><a href="#Spring-Boot-整合-Mybatis" class="headerlink" title="Spring Boot 整合 Mybatis"></a>Spring Boot 整合 Mybatis</h1><p>Spring Boot 对于 Mybatis的整合十分方便，基本可以做到开箱即用。<br><a id="more"></a></p>
<h2 id="Mybatis-配置"><a href="#Mybatis-配置" class="headerlink" title="Mybatis 配置"></a>Mybatis 配置</h2><p>Mybatis 是基于 SqlSessionFactory 构建的框架，SqlSessionFactory 的作用是生成 SqlSession 接口对象，通过 SqlSession 对象操作数据库。在 Spring Boot 中，自动配置了上述两个对象，因此只需要关注业务代码即可。</p>
<p>在 Spring Boot 中，可以在配置文件中配置 SqlSessionFactory 对象，可配置的主要内容如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>配置</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>settings</td>
<td>对应于 xml 配置中的 settings 子标签</td>
</tr>
<tr>
<td>typeAliases</td>
<td>配置类型别名</td>
</tr>
<tr>
<td>typeHandlers</td>
<td>配置自定义类型处理器</td>
</tr>
<tr>
<td>plugins</td>
<td>配置拦截器</td>
</tr>
<tr>
<td>mappers</td>
<td>配置mapper</td>
</tr>
</tbody>
</table>
</div>
<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>首先新建一个 Spring Boot 项目，添加 MyBatis 依赖与 Mysql 依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>新建在项目中新建 model 包，在包中新建实体类 User 与性别枚举类 SexEnum 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> SexEnum sex;</span><br><span class="line">    <span class="comment">// 省略其它代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SexEnum &#123;</span><br><span class="line"></span><br><span class="line">    MALE(<span class="number">1</span>,<span class="string">"男"</span>),</span><br><span class="line">    FEMALE(<span class="number">2</span>,<span class="string">"女"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    SexEnum(<span class="keyword">int</span> id, String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SexEnum <span class="title">getEnumById</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (SexEnum sex : SexEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sex.getId() == id)</span><br><span class="line">                <span class="keyword">return</span> sex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后新建一个 mapper 包，在包中创建 UserMapper 接口与 UserMapper.xml 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"top.liuzhenhui.mybatisdemo.mapper.UserMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"sex"</span> <span class="attr">property</span>=<span class="string">"sex"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">        insert into user (name, sex) values (#&#123;name&#125;,#&#123;sex&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserById"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">        select *</span><br><span class="line">        from user</span><br><span class="line">        where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUser"</span>&gt;</span></span><br><span class="line">        update user</span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name != null and name.length() &gt; 0"</span>&gt;</span></span><br><span class="line">                name = #&#123;name&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"sex != null"</span>&gt;</span></span><br><span class="line">                sex = #&#123;sex&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于 mapper 接口与 mapper.xml 都在 java 目录下的包中，需要在 pom.xml 中加入如下代码让 xml 文件能够被扫描到：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java/<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>创建一个 dao 包，新建 UserDao 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.insertUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.updateUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.getUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 User 类中的性别是枚举类，需要编写一个类型转换器，新建 typehandler 包之后新建 SexTypeHandler 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java类型</span></span><br><span class="line"><span class="meta">@MappedTypes</span>(SexEnum<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">// 数据库中存的类型</span></span><br><span class="line"><span class="class">@<span class="title">MappedJdbcTypes</span>(<span class="title">JdbcType</span>.<span class="title">INTEGER</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SexHandler</span> <span class="keyword">implements</span> <span class="title">TypeHandler</span>&lt;<span class="title">SexEnum</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(PreparedStatement preparedStatement, <span class="keyword">int</span> i, SexEnum sexEnum, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// 为语句设置值</span></span><br><span class="line">        preparedStatement.setInt(i, sexEnum.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SexEnum <span class="title">getResult</span><span class="params">(ResultSet resultSet, String s)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// s 代表 columnName</span></span><br><span class="line">        <span class="keyword">int</span> sexId = resultSet.getInt(s);</span><br><span class="line">        <span class="keyword">if</span>(sexId != <span class="number">1</span> &amp;&amp; sexId != <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> SexEnum.getEnumById(sexId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SexEnum <span class="title">getResult</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sexId = resultSet.getInt(i);</span><br><span class="line">        <span class="keyword">if</span>(sexId != <span class="number">1</span> &amp;&amp; sexId != <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> SexEnum.getEnumById(sexId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SexEnum <span class="title">getResult</span><span class="params">(CallableStatement callableStatement, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// 存储过程的类型转换</span></span><br><span class="line">        <span class="keyword">int</span> sexId = callableStatement.getInt(i);</span><br><span class="line">        <span class="keyword">if</span>(sexId != <span class="number">1</span> &amp;&amp; sexId != <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> SexEnum.getEnumById(sexId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在配置文件中加入如下配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据库基础配置</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="meta">spring.datasource.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql:///mybatisdemo?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置别名</span></span><br><span class="line"><span class="meta">mybatis.type-aliases-package</span>=<span class="string">top.liuzhenhui.mybatisdemo.model</span></span><br><span class="line"><span class="comment"># 配置类型转换器</span></span><br><span class="line"><span class="meta">mybatis.type-handlers-package</span>=<span class="string">top.liuzhenhui.mybatisdemo.typehandler</span></span><br></pre></td></tr></table></figure>
<p>在数据库中新建对应的数据库与表之后在启动文件中加入 <code>@MapperScan(basePackages = &quot;top.liuzhenhui.mybatisdemo.mapper&quot;)</code> 注解，之后在单元测试中分别测试各个方法是否能正确运行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MybatisdemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserDao userDao;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"test4"</span>);</span><br><span class="line">        user.setSex(SexEnum.MALE);</span><br><span class="line">        userDao.insertUser(user);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testGetUserById</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(userDao.getUserById(<span class="number">1L</span>));</span><br><span class="line">        System.out.println(userDao.getUserById(<span class="number">2L</span>));</span><br><span class="line">        System.out.println(userDao.getUserById(<span class="number">3L</span>));</span><br><span class="line">        System.out.println(userDao.getUserById(<span class="number">4L</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="number">1l</span>);</span><br><span class="line">        <span class="comment">//user.setName("update1");</span></span><br><span class="line">        user.setSex(SexEnum.FEMALE);</span><br><span class="line">        userDao.updateUser(user);</span><br><span class="line">        System.out.println(userDao.getUserById(<span class="number">1L</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
</search>
